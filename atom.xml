<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decision&#39;s Blog</title>
  
  <subtitle>山河犹在 故人长绝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://decision01.cn/"/>
  <updated>2019-09-18T12:53:21.027Z</updated>
  <id>http://decision01.cn/</id>
  
  <author>
    <name>Decision</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向工程学习--Acid burn</title>
    <link href="http://decision01.cn/2019/09/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0-Acid-burn/"/>
    <id>http://decision01.cn/2019/09/18/逆向工程学习-Acid-burn/</id>
    <published>2019-09-18T12:25:03.000Z</published>
    <updated>2019-09-18T12:53:21.027Z</updated>
    
    <content type="html"><![CDATA[<h5 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h5><blockquote><p>这些CreakMe小程序是从吾爱破解上找到的160个练习<br>然后最近在学逆向&amp;汇编就拿来练练手</p></blockquote><h5 id="0x01-注册码的破解"><a href="#0x01-注册码的破解" class="headerlink" title="0x01 注册码的破解"></a>0x01 注册码的破解</h5><p>最近才开始学用Ollydbg不熟悉。。然后快捷键还有功能什么的还没有把握<br>所以一开始动态调试就是一个断点一个断点的下跟踪程序的运行，要找到主要执行的地方就异常的慢。。<br>看了一下别人做的才学会在运行过程中F12直接暂停程序运行跟踪汇编位置。。<br>程序界面是这么一个样子：<br><img src="./0x00.png" alt="程序界面"><br>就是要输入用户名对应注册码的样子，先随便输入一个，然后等提示框，F12暂停定位到对应的位置<br><code>Alt-K</code>到堆栈界面，可以看到MessageBox函数的调用<br><img src="./0x01.png" alt="堆栈界面"><br>有两个对MessageBox的调用，能大致确定是下面一个才是后面弹出提示框的时候调用的函数<br>然后进到这个函数的位置，在调用MessageBox的函数头部打个断点，再重复一次<br>运行到断点位置能看到右下角的栈窗口看到被压栈的有个可疑的字符串。。<br><img src="./0x02.png" alt="堆栈界面"><br>试一试输入然后提交试试，然后就成功了<br>调用的这个函数应该是为了输出失败信息，然后在这之前应该有一个函数是用于验证注册码的，可以在栈里看到，这里用于下面的分析注册码生成算法<br><img src="./0x03.png" alt="注册成功"></p><h5 id="0x02-注册码算法分析"><a href="#0x02-注册码算法分析" class="headerlink" title="0x02 注册码算法分析"></a>0x02 注册码算法分析</h5><p>（学业繁忙，咕一下）</p><h5 id="0x03-另外一个注册界面的分析"><a href="#0x03-另外一个注册界面的分析" class="headerlink" title="0x03 另外一个注册界面的分析"></a>0x03 另外一个注册界面的分析</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;这些CreakMe小程序是从吾爱破解上找到的160个练习&lt;br&gt;然后最近在
      
    
    </summary>
    
      <category term="Reverse" scheme="http://decision01.cn/categories/Reverse/"/>
    
    
      <category term="CreakMe" scheme="http://decision01.cn/tags/CreakMe/"/>
    
  </entry>
  
  <entry>
    <title>PE文件结构</title>
    <link href="http://decision01.cn/2019/09/17/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://decision01.cn/2019/09/17/PE文件结构/</id>
    <published>2019-09-17T15:07:27.000Z</published>
    <updated>2019-09-17T15:17:05.049Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><blockquote><p>PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软Windows操作系统上的程序文件（可能是间接被执行，如DLL）<br>——百度百科</p></blockquote><h5 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h5><p>PE文件使用的是平面地址空间，代码和数据被合并在一起，组成庞大的组织结构。文件的内容分割为不同的区块（如.data、.idata、.text，这些区块甚至可以自己命名），区段中包含代码数据，各个区块按照页边界来对齐，区块没有限制大小，是一个连续的结构。每块都有他自己在内存中的属性，比如：这个块是否可读可写，或者只读等等。<br>在加载的时候，windows加载器遍历整个PE文件并决定文件的哪个部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。<br><img src="./1568626216975.png" alt="PE文件加载到内存中的情形"></p><h5 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA &amp; RVA"></a>VA &amp; RVA</h5><p>VA：进程虚拟内存的绝对地址<br>RVA：相对虚拟地址，从某个基准地址开始的相对地址</p><h5 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h5><p>在PE头的最前面有一个<code>IMAGE_DOS_HEADER</code>结构体，用于扩展已有的DOS EXE头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      </span><br><span class="line">    WORD   e_magic;                     </span><br><span class="line">    WORD   e_cblp;                      </span><br><span class="line">    WORD   e_cp;                        </span><br><span class="line">    WORD   e_crlc;                      </span><br><span class="line">    WORD   e_cparhdr;                   </span><br><span class="line">    WORD   e_minalloc;                  </span><br><span class="line">    WORD   e_maxalloc;                  </span><br><span class="line">    WORD   e_ss;                       </span><br><span class="line">    WORD   e_sp;                     </span><br><span class="line">    WORD   e_csum;                      </span><br><span class="line">    WORD   e_ip;                       </span><br><span class="line">    WORD   e_cs;                        </span><br><span class="line">    WORD   e_lfarlc;                    </span><br><span class="line">    WORD   e_ovno;                      </span><br><span class="line">    WORD   e_res[4];                   </span><br><span class="line">    WORD   e_oemid;                     </span><br><span class="line">    WORD   e_oeminfo;                   </span><br><span class="line">    WORD   e_res2[10];                 </span><br><span class="line">    LONG   e_lfanew;                   </span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure></p><p>两个重要成员：</p><ul><li><code>e_magic</code>：DOS签名，一般为ASCII值”MZ“</li><li><code>e_lfanew</code>：指示NT头的偏移</li></ul><h5 id="DOS存根（stub）"><a href="#DOS存根（stub）" class="headerlink" title="DOS存根（stub）"></a>DOS存根（stub）</h5><p>由代码和数据混合而成的一个大小不固定的可选项，可以存放一些不会影响程序运行的数据，在通常的程序中，会存放<code>This program cannot be run in Dos mode</code></p><h5 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h5><p>NT头结构体有三个成员：签名结构体、文件头、可选头<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">DWORD Signatured;</span><br><span class="line">IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADER32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure></p><h5 id="NT头：文件头"><a href="#NT头：文件头" class="headerlink" title="NT头：文件头"></a>NT头：文件头</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WORD Machine;                   <span class="comment">// 文件运行平台</span></span><br><span class="line">    WORD NumberOfSections;          <span class="comment">// 区段个数</span></span><br><span class="line">    DWORD TimeDateStamp;            <span class="comment">// 文件创建时间</span></span><br><span class="line">    DWORD PointerToSymbolTable;     <span class="comment">// 符号表偏移</span></span><br><span class="line">    DWORD NumberOfSymbols;          <span class="comment">// 符号个数</span></span><br><span class="line">    WORD SizeOfOptionalHeader;      <span class="comment">// 扩展头大小</span></span><br><span class="line">    WORD Characteristics;           <span class="comment">// PE文件属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>（待续。。。）</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、S
      
    
    </summary>
    
      <category term="Reverse" scheme="http://decision01.cn/categories/Reverse/"/>
    
    
      <category term="File Struct" scheme="http://decision01.cn/tags/File-Struct/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces1207-C Gas Pipeline</title>
    <link href="http://decision01.cn/2019/08/23/Codeforces1207C/"/>
    <id>http://decision01.cn/2019/08/23/Codeforces1207C/</id>
    <published>2019-08-23T14:43:49.000Z</published>
    <updated>2019-08-23T14:58:23.388Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：在$x$轴的非负区域，有长度为$n$的路，需要在这条路上铺设管道；如果在某个位置是十字路口的话，需要将这个位置的管道高度铺设在$y = 2$的位置上面，而在非十字路口的位置，可以铺设在$y = 1$的位置，也可以铺设在$y = 1$的位置，而不同高度的情况下需要对应高度的管道架；设一单位的管道需要的费用是$a$，一单位管道架需要的费用是$b$，求铺设到终点所需的最小费用</p><p>被B题卡了快一个小时才看C题。。满足最优子结构和无后效性就是DP了<br>这次又是写出了C的时候没写出B呢。。。<br>设$f_{i,j}$为铺设到$i$位置的时候高度为j的最小花费<br>那么可以得到转移方程<br>在$s_i$为1的时候：</p><script type="math/tex; mode=display">\begin{cases}f[i][0] = INF\\f[i][1] = min(f[i-1][0] + 2a,f[i-1][1] + a) + 2b\\\end{cases}</script><p>在$s_i$为0的时候：</p><script type="math/tex; mode=display">\begin{cases}f[i][0] = min(f[i-1][1] + 2a,f[i-1][0] + a) + b\\f[i][1] = min(f[i-1][0] + 2a,f[i-1][1] + a) + 2b\\\end{cases}</script><p>时间复杂度：$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">2</span> * maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = INF;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = INF;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">2</span> * b + a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>] + a,dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">2</span> * a) + b;</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> *a,dp[i - <span class="number">1</span>][<span class="number">1</span>] + a) + <span class="number">2</span> * b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目大意：在$x$轴的非负区域，有长度为$n$的路，需要在这条路上铺设管道；如果在某个位置是十字路口的话，需要将这个位置的管道高度铺设在$y = 2$的位置上面，而在非十字路口的位置，可以铺设在$y = 1$的位置，也可以铺设在$y = 1$的位置，而不同高度的情况下需要对
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://decision01.cn/categories/Codeforces/"/>
    
    
      <category term="DP" scheme="http://decision01.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces1207-B Square Filling</title>
    <link href="http://decision01.cn/2019/08/23/Codeforces1207B/"/>
    <id>http://decision01.cn/2019/08/23/Codeforces1207B/</id>
    <published>2019-08-23T13:09:33.000Z</published>
    <updated>2019-08-23T13:26:17.230Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：给出两个$n \cdot m$的矩阵$A$和$B$,一开始矩阵$B$全为0，每次可以选定一个坐标$(x,y)(1 \le x &lt; n、1 \le y &lt; m)$，将$(x,y)、(x,y + 1)、(x + 1,y)、(x + 1,y + 1)$都变成1，求将矩阵$B$变为$A$的最小步数，并输出所有的操作的坐标。</p><p>这个思维题又把我卡死了，C题都写得出来但是我写不出这个B，结束前3分钟才给A掉然后没时间写别的了。。<br>要操作的次数最少，也就是说每次操作要保证改变的0的数量最多<br>把一个0的位置变成1，假设这个坐标是$(x,y)$，那么可以通过修改$(x - 1,y - 1)、(x - 1,y)、(x,y - 1)、(x,y)$这四个位置来达到<br>那么每次直接扫描一下$B$中是0但$A$中是1的位置，如果操作的区域中在$A$中没有0，就可以求出一个能使得这次操作最大化的操作位置来进行操作<br>显然时间复杂度是$O(nm)$的，然后我这里还带了一些常数，但是影响不大</p><p>这一场从$\Delta$-80+在最后3分钟拉回来。。最后涨了一分。。。（我还真是个弟弟。。<br><del>思维题必杀我</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>][<span class="number">60</span>],b[<span class="number">60</span>][<span class="number">60</span>],cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[x][y] == <span class="number">0</span> || a[x][y + <span class="number">1</span>] == <span class="number">0</span> || a[x + <span class="number">1</span>][y] == <span class="number">0</span> || a[x + <span class="number">1</span>][y + <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    b[x][y] = b[x][y + <span class="number">1</span>] = b[x + <span class="number">1</span>][y] = b[x + <span class="number">1</span>][y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i][j] != a[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_fix</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">1</span> || x &gt;= n || y &lt; <span class="number">1</span> || y &gt;= m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(b[x + i][y + j] == <span class="number">0</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    mst(b,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i][j] == <span class="number">0</span> &amp;&amp; a[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> fixed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> posx = <span class="number">0</span>,posy = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">-1</span>;k &lt;= <span class="number">0</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">-1</span>;l &lt;= <span class="number">0</span>;l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(check(i + k,j + l)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> tmp = get_fix(i + k,j + l);</span><br><span class="line">                            <span class="keyword">if</span>(fixed &lt; tmp) &#123;</span><br><span class="line">                                fixed = tmp;</span><br><span class="line">                                posx = i + k;posy = j + l;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fixed != <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    modify(posx,posy);</span><br><span class="line">                    ans.push_back(make_pair(posx,posy));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkans() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x.first&lt;&lt;<span class="string">" "</span>&lt;&lt;x.second&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目大意：给出两个$n \cdot m$的矩阵$A$和$B$,一开始矩阵$B$全为0，每次可以选定一个坐标$(x,y)(1 \le x &amp;lt; n、1 \le y &amp;lt; m)$，将$(x,y)、(x,y + 1)、(x + 1,y)、(x + 1,y + 1)$都变成
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://decision01.cn/categories/Codeforces/"/>
    
    
      <category term="思维" scheme="http://decision01.cn/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-Round#580(Div.2)解题报告</title>
    <link href="http://decision01.cn/2019/08/18/Codeforces1206/"/>
    <id>http://decision01.cn/2019/08/18/Codeforces1206/</id>
    <published>2019-08-18T15:57:39.000Z</published>
    <updated>2019-08-19T15:26:31.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A - Choose Two Numbers<br>给出两个数组，长度分别为$ n、m(1 \le n \le 100、1 \le m \le 100)$，找出两个分别属于两个数组的数，使得它们的和不在两个数组里</p></blockquote><p><code>暴力</code></p><p>裸暴力，手滑了两发白给。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">300</span>],b[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">bool</span> mp[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mst(mp,<span class="number">0</span>);</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],mp[a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">cin</span>&gt;&gt;b[i],mp[b[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[a[i] + b[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;b[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>B - Make Product Equal One<br>给定一个数组$a$,其长度为$n$，每次可以花费1的代价使得一个数加1或者减1，求出最小的代价使得变化后所有数的乘积为1</p></blockquote><p><code>贪心</code><br>会影响最终数值的是-1的地方，那么先统计一下小于等于-1以及等于0的数有多少个<br>先把小于等于-1的数变到-1的代价求出来，以及大于等于1的数变到1的代价求出来<br>最后再判断小于等于-1的数的个数是不是奇数，以及等于0的数是不是大于0，分类讨论一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            cnt1 ++;</span><br><span class="line">            ans += (<span class="number">-1L</span>L) - a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="number">0</span>) cnt2++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += a[i] - <span class="number">1L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1 % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt2 &gt; <span class="number">0</span>) ans += cnt2;</span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ans += cnt2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C - Almost Equal<br>给出一个数$n(1 \le n \le 1e5)$,然后问能不能将$1 - 2n$的$2n$个数排成一个环，使得在环上任意取$n$个连续的数所得到的和$sum_i$两两之间的差值小于等于1，如果可以，输出环的方案</p></blockquote><p><code>数学</code><br>一开始看了样例猜了一下是不是只有n = 1和n = 3的情况下才能得到。。交了一发的确WA了<br>然后冷静分析.jpg<br>这$2n$个数每个数在加的情况下最多只能被取到$n$次，而且最后连续的$n$个数的和的情况就只有$x、x+1$的形式<br>那么可以得到一个方程$nx + n(x + 1) = n^2 \cdot (1 + 2n)$<br>得到$x = \frac {n - 1} {2} + n ^ 2$<br>也就是说只有在n是奇数的情况下才可以得到这个环，偶数的时候直接输出NO<br>那么在奇数的情况下，按照样例的方式构造答案即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> pos1,pos2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>,pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            pos = i + j;</span><br><span class="line">            <span class="keyword">if</span>(pos &gt; <span class="number">2</span> * n) pos = pos % (<span class="number">2</span> * n);</span><br><span class="line">            tmp += ans[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES\n"</span>;</span><br><span class="line">        pos1 = <span class="number">2</span>;</span><br><span class="line">        pos2 = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; <span class="number">2</span> * n;i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[pos2++] = i;</span><br><span class="line">                ans[pos2++] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[pos1++] = i;</span><br><span class="line">                ans[pos1++] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">2</span> * n] = <span class="number">2</span> * n;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">2</span> * n;i++) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>D - Shortest Cycle<br>给出$n(1 \le n \le 1e5)$个数$a_i(1 \le a_i \le 1e18)$，如果两个数$a_i$和$a_j$的与运算不为0的话，这两个数之间就存在一条边，求出最小的环的长度</p></blockquote><p><code>dfs</code> <code>位运算</code></p><p>本来一开始都快想到正解了但是又想偏了。。想了个假算法<br>最开始的想法：<br>考虑到如果暴力建边的话就是$n^2$的，但是可以利用位的信息来建图，可以降到$O(64n)$建图<br>两个数之间有路径，也就是说它们在某个位上同时为1，那么就可以开一个不定长数组，表示某一位上为1的数的编号，按位运算就可以得到这个数组<br>每次遍历的时候可以之间遍历这个数组得到当前点连接的边，就可以dfs一下。。<br>但是我TLE11。。改了之后又WA12<br>极限提交但是没过，白给。<br><del>然后看了一下别人的代码。。。特判了某个位为1的个数大于等于3的时候直接输出3，然后小于200的时候直接暴力建图跑bfs。。这里没想到</del><br>那么也就是说只要大于$64 \cdot  3$的情况下，暴力建图是可行的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; all;</span><br><span class="line">ll dist[<span class="number">200</span>][<span class="number">200</span>],ans = INF;</span><br><span class="line">ll mp[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; (<span class="keyword">int</span>)all.size();k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; k;j++) &#123;</span><br><span class="line">                ans = min(ans,dist[i][j] + mp[i][k] + mp[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)all.size();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; (<span class="keyword">int</span>)all.size();j++) &#123;</span><br><span class="line">                dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        ll tmp = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;tmp != <span class="number">0</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &amp; <span class="number">1</span>) cnt[j]++;</span><br><span class="line">            tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="number">0</span>) all.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">64</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"3\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)all.size();i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((all[i] &amp; all[j]) != <span class="number">0</span>) &#123;</span><br><span class="line">                dist[i][j] = dist[j][i] = <span class="number">1</span>;</span><br><span class="line">                mp[i][j] = mp[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dist[i][j] = dist[j][i] = INF;</span><br><span class="line">                mp[i][j] = mp[j][i] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">if</span>(ans == INF) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A - Choose Two Numbers&lt;br&gt;给出两个数组，长度分别为$ n、m(1 \le n \le 100、1 \le m \le 100)$，找出两个分别属于两个数组的数，使得它们的和不在两个数组里&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://decision01.cn/categories/Codeforces/"/>
    
    
      <category term="C/C++" scheme="http://decision01.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Recency</title>
    <link href="http://decision01.cn/2019/07/29/Recency/"/>
    <id>http://decision01.cn/2019/07/29/Recency/</id>
    <published>2019-07-28T17:22:50.000Z</published>
    <updated>2019-07-28T17:30:36.611Z</updated>
    
    <content type="html"><![CDATA[<p>本来也没有写点什么打算了，但是觉得还是有必要写点东西。放在博客里面有路人愿意看看就看，没人看也挺好。<br>这一年走过来，一开始是第一个学期开学跟着摸了两个星期的CNSS招新，最后也没进去，虽然本来也只是抱着玩玩的心态去的，因为ctf给我的是一种和acm不太一样的感觉吧。然后在这之后开始接触acm相关的东西，这个时候我其实和刚开始学编程差不多，因为学过的东西也忘完了，况且以前也没有学过些什么。然后进到了院学生会的技术中心，听说学长学姐都很厉害，关姐姐和许部他们成绩都很好，orz。然后进来之后发现其实也没有学到些什么太多的，只是说剪视频还有合成的东西在以前家里那台电脑上不太好进行但是基本操作都会了。然后部门里面很愧对苏部，当时他是想让我画画然后帮忙画小二的东西来着，结果我咕了一年，现在画画也没学到些什么。<br>前一年吧，也差不多是这个时候，刚结束NOI2017，很自闭，在day2结束之后什么活动我都没去，甚至闭幕式什么的，也都没去，一直在寝室里面一边打着文明一边想着后面该怎么做。现在我也想不清楚为什么我明明知道没有拿奖的希望下还要去WC2017和NOI2017，可能也是想去尝试一下，不过那个时候只学了不到一年的我又能拿到些什么呢。我到现在都还记得省队名单刚下来的时候，某天物理课下了之后趴在桌子上睡觉醒来听到备师说我要是能拿奖就能保送，但是我心里也很清楚，我拿不了奖。<br>两年过后的今天，我还是这个样子，甚至没有参加二轮集训的资格。很多学长都觉得我应该是稳进的，其实我自己在集训开始前心里也是比较清楚的，如果真的比赛起来我的思维是跟不上的，光是从Codeforces上面的比赛里就看得出来，我的思维能力还不够，还没有能够参加比赛的能力。哦对，还有我英语的确该补了。很对不起一些学长对我的期望，特别是强哥，从去年的寒假开始就问我要不要跟着做做寒假集训的题，我嘴上答应了但是寒假里基本上因为天气冷窝在被子里颓，而且也经常忘记这件事所以没有写。然后这次集训看到我发挥不好强哥也会来问我怎么回事，后面还会问我后面的打算，真的很感谢。还有技术中心的晨曦姐姐，甚至还觉得我能稳进队给他的室友刘大爷打招呼说照顾我。感觉很对不起他们的期望，但是我明年还会重来，虽然说我少了一年在队里集训的时间。而且这一年，我也不会继续荒废了。<br>大学好像就是这样，一直觉得自己很忙，但是现在回过头去看，好像也没有忙到些什么。在去年9月到10月是忙着CNSS的招新赛，结束了之后就基本上期中考试，期中考完后是迎新晚会的视频要剪，突然发现其实我并没有忙得太多，只是一直觉得自己忙罢了。然后这个学期比较长的一个事情也就是暑假前集训了，拼命写板题，除了凑了一堆板子一无所有，自己觉得很大的进步也就只是把以前没学会的动态规划基本入门了而已，然后Codeforces的分高了一些，的确有了进步，但是比起别人，我还是菜。最大的一个体会是明白了为什么很多人说ACM是性价比最低的比赛，虽然这个学期投入了不少的时间，有时候上课都在想题，但是最后数学课物理课的绩点没有上去，也没有进二轮，可笑呵。<br>也不知道是什么东西一直支撑着我走到现在甚至还想明年再来一次。很多时候我都在想，如果3年前的那个男孩子没有听到同桌嘴里随口所说的一句要去厦门大学，没有在网上查厦门大学自主招生简介的话，他就不会知道奥赛里面还有OI的存在，也就不会为了一个不切实际的梦想而去追逐了。甚至搞得高二一年的成绩一团糟，一直只在年纪二三十名徘徊，而且学着一些在旁人看来并没有什么用的东西。明明当时只是想要混一个省一等奖然后去搞个自招，结果现在甚至会把自己坑到大二都还想打ACM，这种天分就能拉开很大差距的东西。<br>然后这一年，收获？说起来好像没有什么收获。就连高中的班长问起来，问我今年收获了什么，我也只是说认识了很多不同的人，然后学了点东西，这算什么收获啊。不过唯一做的比较爽快的一件事是断了自己四年的执念，虽然现在还是会时不时想起，但是相比起来因为没有了周遭环境的影响，所以基本上会慢慢淡掉，也挺好的。曾经在那个环境里面，时不时都会听到那个名字，甚至有时候在家里吃饭父母都会无意间问到，虽然这只是因为她成绩很好所以受关注会被别人提起而已。不过现在也不会受到她的影响了，挺安心。<br>最后再说一下吧，虽然没有进二轮集训，但是得到了一个月的假期，有多出来的时间回家去陪陪父母，然后吃吃家里的菜、家里的特色，好像也没有什么不好。也许这就是有得必有失吧。<br>大体也就是这些了，现在算是。。半年一次的总结了？<br>往昔不悔，来日可期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来也没有写点什么打算了，但是觉得还是有必要写点东西。放在博客里面有路人愿意看看就看，没人看也挺好。&lt;br&gt;这一年走过来，一开始是第一个学期开学跟着摸了两个星期的CNSS招新，最后也没进去，虽然本来也只是抱着玩玩的心态去的，因为ctf给我的是一种和acm不太一样的感觉吧。然
      
    
    </summary>
    
      <category term="杂记" scheme="http://decision01.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="http://decision01.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-570-div3解题报告</title>
    <link href="http://decision01.cn/2019/06/28/Codeforces-570-div3%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://decision01.cn/2019/06/28/Codeforces-570-div3解题报告/</id>
    <published>2019-06-28T15:57:18.000Z</published>
    <updated>2019-07-05T17:36:36.315Z</updated>
    
    <content type="html"><![CDATA[<p>div3都能给我打掉分，我真的是个菜狗了。。</p><h5 id="A-Nearest-Interesting-Number"><a href="#A-Nearest-Interesting-Number" class="headerlink" title="A - Nearest Interesting Number"></a>A - Nearest Interesting Number</h5><blockquote><p>给出一个数$ n $问大于等于它的哪个数的每个位相加起来和是4的倍数</p></blockquote><p><code>枚举</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a;i &lt;= <span class="number">2000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            x += tmp % <span class="number">10</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="B-Equalize-Prices"><a href="#B-Equalize-Prices" class="headerlink" title="B - Equalize Prices"></a>B - Equalize Prices</h5><blockquote><p>给出一个数列$a_i$,问能不能找到一个尽量大的数使得把所有数变成这一个数之后与原来的数的绝对值不超过$k$</p></blockquote><p><code>贪心</code><br>考虑最小的直接加$k$即可<br>然后这题第二个循环变量我还是用$i$调了十多分钟。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll q;</span><br><span class="line">ll n,k,sum;</span><br><span class="line">ll B,a[<span class="number">200</span>],b[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        B = INF;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[j];</span><br><span class="line">            B = min(a[j] + k,B);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(B - a[j]) &gt; k)&#123;</span><br><span class="line">                B = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;B&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="C-Computer-Game"><a href="#C-Computer-Game" class="headerlink" title="C - Computer Game"></a>C - Computer Game</h5><blockquote><p>给出电脑一开始的电量$ k $，要玩$ n $轮游戏，不充电玩的时候一轮消耗$ a $的电量，充电玩的时候一轮消耗$ b $的电量，$a &gt; b$，求出在不充电的情况下能玩多少游戏，如果$ n $轮游戏都无法完成的话输出$ - 1 $</p></blockquote><p><code>二分</code><br>考虑n轮游戏下来，不充电玩了$ x $轮，那么n轮后花费就是$ax + b(n - x)$，又因为$a &gt; b$，所以$ax + b(n - x)$是单调的，直接二分即可<br>然后我初始值没有设成0导致疯狂wa就卡在这题了。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ll q;</span><br><span class="line">ll n,k,a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll now)</span></span>&#123;</span><br><span class="line">    ll sum = now * a + (n - now) * b;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        ll l,r;</span><br><span class="line">        l = <span class="number">0</span>,r = n;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            ll mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                l = mid + <span class="number">1L</span>L;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1L</span>L;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check(ans)) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="D-Candy-Box-easy-version"><a href="#D-Candy-Box-easy-version" class="headerlink" title="D - Candy Box (easy version)"></a>D - Candy Box (easy version)</h5><blockquote><p>给出$ q $个询问，然后每个询问给出$ n $个数，选出最多数使得每个数出现的次数都不一样</p></blockquote><p><code>贪心</code> <code>排序</code><br>就记一下出现次数然后排序从高到底开始选取就可以了。。<br>看了题解里面有一个比较巧妙的用法以前没见过<br>定义了一个<code>vector cnt(n + 1)</code>，然后排序的时候是<code>sort(cnt.rbegin().cnt.rend())</code>就直接是降序了<br><code>vector</code>的<code>rbegin()</code>和<code>rend()</code>是反向迭代器的用法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            cnt[tmp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(cnt.rbegin(),cnt.rend());</span><br><span class="line">        <span class="keyword">int</span> ans = cnt[<span class="number">0</span>],lst = cnt[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lst == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt[j] &gt;= lst)&#123;</span><br><span class="line">                ans += lst - <span class="number">1</span>;</span><br><span class="line">                lst -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += cnt[j];</span><br><span class="line">                lst = cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="E-Subsequences-easy-version"><a href="#E-Subsequences-easy-version" class="headerlink" title="E - Subsequences (easy version)"></a>E - Subsequences (easy version)</h5><blockquote><p>给出两个整数$ n $，$ k $以及字符串$ s $，问能不能删除字符串的一些字符不改变顺序得到一个大小为$ k $的子串集合，并且总共删除的字符要最少</p></blockquote><p><code>bfs</code> <code>字符串</code><br><del>你以为我是字符串，其实我是bfs哒，cf脑洞题惹不起惹不起</del><br>每次删除某个位置的字符，用<code>set</code>检查出现过没有，没有的话加入队列，然后统计答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f_read;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    q.push(s);</span><br><span class="line">    st.insert(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty() &amp;&amp; <span class="keyword">int</span>(st.size()) &lt; k)&#123;</span><br><span class="line">        <span class="built_in">string</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">int</span>(now.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = now;</span><br><span class="line">            tmp.erase(i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!st.count(tmp) &amp;&amp; <span class="keyword">int</span>(st.size()) + <span class="number">1</span> &lt;= k)&#123;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">                st.insert(tmp);</span><br><span class="line">                ans += n - tmp.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">int</span>(st.size()) &lt; k) <span class="built_in">cout</span>&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（于是在打了一个多小时群星后只看了题意。。。。）</p><h5 id="F-Topforces-Strikes-Back"><a href="#F-Topforces-Strikes-Back" class="headerlink" title="F - Topforces Strikes Back"></a>F - Topforces Strikes Back</h5><blockquote><p>给出$ n $个数，找出里面的三个数不存在整除的关系并且要最大</p></blockquote><p><code>set</code> <code>暴力</code> <code>贪心</code><br>考虑把每个数依次加到set里面，先取最大的，如果说这个最大的数除以2、3、5之后的数在set里面，那么就先把答案定为这三个之和<br>然后遍历集合，依次把能整除最大的筛掉，选出三个到答案的<code>vector</code>里面，最后求和即可<br>康题解学到了<code>accumulate</code>函数的用法,包含在头文件<code>&lt;numeric&gt;里面</code>，之后还得去学学c++11里面的一些用法。。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tmp,anss;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> query = <span class="number">1</span>;query &lt;= q;query ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        a.clear();</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            a.insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anss = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxx = *a.rbegin();</span><br><span class="line">        <span class="keyword">if</span>(maxx % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; maxx % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; maxx % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.count(maxx / <span class="number">2</span>) &amp;&amp; a.count(maxx / <span class="number">3</span>) &amp;&amp; a.count(maxx / <span class="number">5</span>))&#123;</span><br><span class="line">                anss = max(anss,maxx / <span class="number">2</span> + maxx / <span class="number">3</span> + maxx / <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a.empty() &amp;&amp; ans.size() &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = *a.rbegin();</span><br><span class="line">            a.erase(prev(a.end()));</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : ans) flag &amp;= (it % x != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag) ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anss = max(anss,accumulate(ans.begin(),ans.end(),<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;anss&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="G-Candy-Box-hard-version"><a href="#G-Candy-Box-hard-version" class="headerlink" title="G - Candy Box (hard version)"></a>G - Candy Box (hard version)</h5><blockquote><p>给出$ n $个数，选择在选择个数最大的情况下，另外一个数的和也最大，要保证每个数出现次数不一样，和D题类似</p></blockquote><h5 id="H-Subsequences-hard-version"><a href="#H-Subsequences-hard-version" class="headerlink" title="H - Subsequences (hard version)"></a>H - Subsequences (hard version)</h5><blockquote><p>在给定的字符串中选出尽可能长的$ k $个子串</p></blockquote><p><code>dp</code> <code>字符串</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;div3都能给我打掉分，我真的是个菜狗了。。&lt;/p&gt;
&lt;h5 id=&quot;A-Nearest-Interesting-Number&quot;&gt;&lt;a href=&quot;#A-Nearest-Interesting-Number&quot; class=&quot;headerlink&quot; title=&quot;A - Ne
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://decision01.cn/categories/Codeforces/"/>
    
      <category term="ICPC" scheme="http://decision01.cn/categories/Codeforces/ICPC/"/>
    
    
      <category term="C/C++" scheme="http://decision01.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>UESTC暑假前集训-字符串与搜索-解题报告</title>
    <link href="http://decision01.cn/2019/06/22/UESTC%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
    <id>http://decision01.cn/2019/06/22/UESTC暑期前集训-字符串与搜索/</id>
    <published>2019-06-22T04:02:27.000Z</published>
    <updated>2019-06-22T04:18:30.953Z</updated>
    
    <content type="html"><![CDATA[<h5 id="A-qh与复读机I"><a href="#A-qh与复读机I" class="headerlink" title="A - qh与复读机I"></a>A - qh与复读机I</h5><blockquote><p>A、每次按顺序给出$ n $个字符串，求出每个字符串是前面多少个字符串的前缀和后缀</p></blockquote><p><code>tire树</code><br>因为题面给定数据范围$\sum |S_i| &lt; 1e6$，也就是说如果建一棵树的话结点数是不会超过这么多的，而且遍历的时候也是，那么考虑正序和逆序建树，每次建树的同时到达最后一个结点返回当前结点已经记录的单词数量，也就分别对应了前缀和后缀<br>时间复杂度$O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> child[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) child[i] = <span class="number">0</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Tree[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">bool</span> statu,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> pos = s[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(Tree[statu][now].child[pos] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> nxt = (statu ? ++cnt2 : ++cnt1);</span><br><span class="line">Tree[statu][now].child[pos] = nxt;</span><br><span class="line">Tree[statu][nxt].init();</span><br><span class="line">&#125;</span><br><span class="line">now = Tree[statu][now].child[pos];</span><br><span class="line">Tree[statu][now].sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Tree[statu][now].sum - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;insert(<span class="number">0</span>,s)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">reverse(s.begin(),s.end());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;insert(<span class="number">1</span>,s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="B-qh与复读机II"><a href="#B-qh与复读机II" class="headerlink" title="B - qh与复读机II"></a>B - qh与复读机II</h5><blockquote><p>B、给定一个字符串$ S $，求出这个字符串的所有循环节大小</p></blockquote><p><code>KMP</code> <code>fail数组</code><br>有一个结论是字符串的$ border $的 $border$还是这个字符串的$border$，那么用KMP算法求出fail数组后，对应的就是$border$，那么就依次求出$fail[n]、fail[fail[n]]…..$然后用原串长度减去就可以了<br>直接把以前写的KMP算法拿过来了（逃<br>时间复杂度$O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">1000007</span>]; </span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000007</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        j = nxt[i];</span><br><span class="line">        <span class="keyword">while</span>(s[i]!=s[j]&amp;&amp;j) j = nxt[j];</span><br><span class="line">        nxt[i+<span class="number">1</span>] = s[i]==s[j]?j+<span class="number">1</span>:<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    KMP(s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> x = nxt[len];</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans.push_back(len - x);</span><br><span class="line">        x = nxt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="C-qh与复读机III"><a href="#C-qh与复读机III" class="headerlink" title="C - qh与复读机III"></a>C - qh与复读机III</h5><blockquote><p>C、给出字符串$ S $和$ T $，求出$ T $在$ S $中出现的每一个位置</p></blockquote><p><code>KMP</code><br>KMP板题，求出匹配位置即可，时间复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">1000007</span>],s2[<span class="number">1000007</span>]; </span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = nxt[i];</span><br><span class="line">        <span class="keyword">while</span>(s[i]!=s[j]&amp;&amp;j) j = nxt[j];</span><br><span class="line">        nxt[i+<span class="number">1</span>] = s[i]==s[j]?j+<span class="number">1</span>:<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s1),m = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">while</span>(s1[i]!=s2[j]&amp;&amp;j) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==s2[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;<span class="built_in">cout</span>&lt;&lt;i-j+<span class="number">2</span>&lt;&lt;<span class="string">" "</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    KMP(s2);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-qh与复读机IV"><a href="#D-qh与复读机IV" class="headerlink" title="D - qh与复读机IV"></a>D - qh与复读机IV</h5><blockquote><p>D、给出一堆模式串$T_i$，求出每个模式串在待匹配串里面的出现次数</p></blockquote><p><code>AC自动机</code><br>AC自动机的板题，把模式串放到AC自动机里面然后用匹配串放进去匹配求出次数输出即可，这个题没有加强数据，所以平常的AC自动机就可以过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1000007</span>],s2[<span class="number">1000007</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">100007</span>];</span><br><span class="line"><span class="keyword">int</span> tid[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acnode</span>&#123;</span></span><br><span class="line">    acnode *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    acnode *fail;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(acnode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) root-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;id = <span class="number">0</span>;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(acnode *root,<span class="keyword">char</span> *s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    acnode *t = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;child[pos] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            acnode *newnode = <span class="keyword">new</span> acnode;</span><br><span class="line">            init(newnode);</span><br><span class="line">            t-&gt;child[pos] = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        t = t-&gt;child[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t -&gt; id != <span class="number">0</span>) tid[id] = t -&gt; id;</span><br><span class="line">    <span class="keyword">else</span> t -&gt; id = id,tid[id] = t -&gt; id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">(acnode *root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;acnode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        acnode *now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;child[i] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                acnode *p;</span><br><span class="line">                <span class="keyword">if</span>(now == root)&#123;</span><br><span class="line">                    now-&gt;child[i]-&gt;fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    p = now-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p-&gt;child[i] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            now-&gt;child[i]-&gt;fail = p-&gt;child[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = p-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) now-&gt;child[i]-&gt;fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push(now-&gt;child[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(acnode *root,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    acnode *p = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;child[pos] == <span class="literal">NULL</span> &amp;&amp; p!= root) p = p-&gt;fail;</span><br><span class="line">        p = p-&gt;child[pos];</span><br><span class="line">        <span class="keyword">if</span>(!p) p = root;</span><br><span class="line">        acnode *now = p;</span><br><span class="line">        <span class="keyword">while</span>(now != root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;id &gt; <span class="number">0</span>)</span><br><span class="line">                ans[now-&gt;id] ++;</span><br><span class="line">            now = now-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">acnode *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    root = <span class="keyword">new</span> acnode;</span><br><span class="line">    init(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">        insert(root,s1,i);</span><br><span class="line">    &#125;</span><br><span class="line">    getfail(root);</span><br><span class="line">    query(root,s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[tid[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-qh与复读机V"><a href="#E-qh与复读机V" class="headerlink" title="E - qh与复读机V"></a>E - qh与复读机V</h5><blockquote><p>E、和上一个题一样，但是有数据加强</p></blockquote><p><code>AC自动机</code> <code>last优化</code><br>这个题我改成了用数组写，因为指针写优化容易出现空指针的问题，所以改成用数组写要稳妥一点。。。加一个last优化直接跳到对应的位置避免了重复跳位置的效率低下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1000007</span>],s2[<span class="number">1000007</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">100007</span>];</span><br><span class="line"><span class="keyword">int</span> tid[<span class="number">100007</span>];</span><br><span class="line"><span class="keyword">int</span> last[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) child[i] = <span class="number">0</span>;</span><br><span class="line">        fail = <span class="number">0</span>;</span><br><span class="line">        id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[now].child[s[i] - <span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            Node[now].child[s[i] - <span class="string">'a'</span>] = ++cnt;</span><br><span class="line">            Node[cnt].init();</span><br><span class="line">        &#125;</span><br><span class="line">        now = Node[now].child[s[i] - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Node[now].id == <span class="number">0</span>) Node[now].id = id,tid[id] = id;</span><br><span class="line">    <span class="keyword">else</span> tid[id] = Node[now].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[<span class="number">0</span>].child[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            Node[Node[<span class="number">0</span>].child[i]].fail = <span class="number">0</span>;</span><br><span class="line">            q.push(Node[<span class="number">0</span>].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Node[now].child[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = Node[now].child[i];</span><br><span class="line">                Node[Node[now].child[i]].fail = Node[Node[now].fail].child[i];</span><br><span class="line">                q.push(Node[now].child[i]);</span><br><span class="line">                last[nxt] = Node[Node[nxt].fail].id ? Node[nxt].fail : last[Node[nxt].fail]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> Node[now].child[i] = Node[Node[now].fail].child[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        now = Node[now].child[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = now;t;t = last[t])&#123;</span><br><span class="line">            <span class="keyword">if</span>(Node[t].id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans[Node[t].id] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">        insert(s1,i);</span><br><span class="line">    &#125;</span><br><span class="line">    getfail();</span><br><span class="line">    query(s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[tid[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="F-qh与复读机VI"><a href="#F-qh与复读机VI" class="headerlink" title="F - qh与复读机VI"></a>F - qh与复读机VI</h5><blockquote><p>F、给定一个字符串$S$，以及一个字符串$T$，要求求出所有的$S$的子串与$T$的一个前缀拼起来是回文串的情况的总数，而且要求子串长度大于前缀</p></blockquote><p><code>exkmp</code> <code>manacher</code><br>一开始找字符串算法的时候发现了exkmp这个东西，可以求出一个串的所有后缀和另外一个串的最长前缀，然后感觉可以用一下，没有注意读题导致我以为是长度没有关系要找出所有的拼起来的是回文的情况有多少。。<br>然后我就傻逼的写了一发exkmp求出对应的extend数组就放上去了。。后面一看题目，然后看了一下样例（其实样例给的很明显了，就中间回文然后两边是相同的）<br>那么就是需要manacher和exkmp，exkmp的时候把原串倒过来，求出每个位置开头的回文串数量和这个位置对应的extend数组然后相乘相加即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s,t;</span><br><span class="line">ll nxt[<span class="number">1000007</span>],exnxt[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">2000007</span>];</span><br><span class="line">ll p[<span class="number">2000007</span>],id = <span class="number">1</span>,mx = <span class="number">1</span>,ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ll pre[<span class="number">2000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll len = t.length(),pos,i = <span class="number">0</span>,j;</span><br><span class="line">    nxt[<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">while</span>(t[i] == t[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; len) i++;</span><br><span class="line">    nxt[<span class="number">1</span>] = i;</span><br><span class="line">    pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nxt[i - pos] + i &lt; nxt[pos] + pos) nxt[i] = nxt[i - pos];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    j = nxt[pos] + pos - i;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i + j &lt; len &amp;&amp; t[i + j] == t[j]) j++;</span><br><span class="line">    nxt[i] = j;</span><br><span class="line">    pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exkmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll i = <span class="number">0</span>,j,pos = <span class="number">0</span>,len1 = s.length(),len2 = t.length();</span><br><span class="line"><span class="keyword">while</span>(s[i] == t[i] &amp;&amp; i &lt; len1 &amp;&amp; i &lt; len2) i++;</span><br><span class="line">exnxt[<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; len1;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nxt[i - pos] + i &lt; exnxt[pos] + pos) exnxt[i] = nxt[i - pos];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j = exnxt[pos] + pos - i;</span><br><span class="line"><span class="keyword">if</span>(j &lt; <span class="number">0</span>) j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i + j &lt; len1 &amp;&amp; j &lt; len2 &amp;&amp; s[j + i] == t[j]) j++;</span><br><span class="line">exnxt[i] = j;</span><br><span class="line">pos = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    s2[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    ll j = <span class="number">2</span>;</span><br><span class="line">    ll len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        s2[j++] = s[i];</span><br><span class="line">        s2[j++] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s2[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll len = init();</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; mx) p[i] = min(p[<span class="number">2</span> * id - i],mx - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s2[i - p[i]] == s2[i + p[i]]) p[i] ++;</span><br><span class="line">        <span class="keyword">if</span>(mx &lt; i + p[i])&#123;</span><br><span class="line">            id = i;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">manacher();</span><br><span class="line">ll len = s.length();</span><br><span class="line"><span class="keyword">for</span>(ll i = len * <span class="number">2</span>;i &gt;= <span class="number">2</span>;i--)&#123;</span><br><span class="line">ll x = i / <span class="number">2</span>;</span><br><span class="line">pre[x]++;</span><br><span class="line">pre[x - (p[i] / <span class="number">2</span>)] --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = len;i &gt;= <span class="number">1</span>;i--) pre[i] += pre[i + <span class="number">1</span>];</span><br><span class="line">reverse(s.begin(),s.end());</span><br><span class="line">KMP();</span><br><span class="line">exkmp();</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= len;i++)&#123;</span><br><span class="line">ans += exnxt[len - i + <span class="number">1</span>] * pre[i] * <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="G-qh与复读机VII"><a href="#G-qh与复读机VII" class="headerlink" title="G - qh与复读机VII"></a>G - qh与复读机VII</h5><blockquote><p>G、给出一个数字串已经一个模数，求出对应数字串的每个不同回文数相加的和在取模后的值的大小</p></blockquote><p><code>快速幂</code> <code>回文自动机</code><br>果然是个回文自动机的板题。。。每个节点对应了一个回文串，那么每次加到这个节点的时候根据上面位置的回文对应的值算出来这个回文的值再加进答案就好了。。当然要注意的是长度奇数和偶数不同情况要处理一下，取10的高次方的时候用快速幂取模<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> fail,len;</span><br><span class="line">    ll value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mst(child,<span class="number">0</span>);</span><br><span class="line">        fail = len = <span class="number">0</span>;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last,tot = <span class="number">0</span>;</span><br><span class="line">ll ans = <span class="number">0</span>,xyy;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">QuickMod</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>,t = a;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res * t) % xyy;</span><br><span class="line">        t = (t * t) % xyy;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last;</span><br><span class="line">    <span class="keyword">while</span>(s[x - node[p].len - <span class="number">1</span>] != s[x]) p = node[p].fail;</span><br><span class="line">    <span class="keyword">if</span>(!node[p].child[c])&#123;</span><br><span class="line">        <span class="keyword">int</span> v = ++tot,k = node[p].fail;</span><br><span class="line">        node[v].len = node[p].len + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[x - node[k].len - <span class="number">1</span>] != s[x]) k = node[k].fail;</span><br><span class="line">        node[v].fail = node[k].child[c];</span><br><span class="line">        node[p].child[c] = v;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">1</span>)&#123;</span><br><span class="line">            node[v].value = c;</span><br><span class="line">            ans = (ans + c) % xyy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll value = (node[p].value * <span class="number">10</span> % xyy + c * QuickMod(<span class="number">10</span>,node[v].len - <span class="number">1</span> % xyy) + c) % xyy;</span><br><span class="line">            ans = (ans + value) % xyy;</span><br><span class="line">            node[v].value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = node[p].child[c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node[<span class="number">0</span>].init();</span><br><span class="line">    node[<span class="number">1</span>].init();</span><br><span class="line">    node[<span class="number">0</span>].fail = <span class="number">1</span>;</span><br><span class="line">    node[<span class="number">1</span>].len = <span class="number">-1</span>;</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s + <span class="number">1</span>&gt;&gt;xyy;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;s[i];i++)&#123;</span><br><span class="line">        insert(s[i] - <span class="string">'0'</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="H-qh与复读机VIII"><a href="#H-qh与复读机VIII" class="headerlink" title="H - qh与复读机VIII"></a>H - qh与复读机VIII</h5><blockquote><p>H、给出一堆模式串以及对应的权重，要求组出一个字符串让其权重和最大，对应某一个模式串出现一次算一次这个模式串的权重，字符串长度限制为$L$</p></blockquote><p><code>AC自动机</code> <code>trie图</code><br>将每个模式串以及对应权重放到AC自动机里面，在AC自动机里面跑一遍动态规划求出一个最长的路径，如果动态规划的话，设$f_{i,j}$为长度为i到达AC自动机的第$j$个对应结点的时候得到的最大权重，$S_k$表示的是对应于$k$结点在trie图上的后继集合，转移方程：</p><script type="math/tex; mode=display">f_{i,j} = max \{ f_{i,k} + w_j | j \in S_k \}</script><p>我写到中间的时候甚至想把图扒出来跑最长路来着。。。但是写不出来还是弃了<br>要从根节点开始，然后到不了的结点设置为inf，然后后面的更新状态也差不多，每次拓展的时候要当前到的结点不是inf才能往下更新<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child[<span class="number">26</span>];</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) child[i] = <span class="number">0</span>;</span><br><span class="line">        fail = <span class="number">0</span>;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line">ll cnt;</span><br><span class="line">ll n,l,w;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">600</span>];</span><br><span class="line">ll f[<span class="number">2007</span>][<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[<span class="number">0</span>].child[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            Node[Node[<span class="number">0</span>].child[i]].fail = <span class="number">0</span>;</span><br><span class="line">            q.push(Node[<span class="number">0</span>].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(Node[Node[now].fail].val) Node[now].val += Node[Node[now].fail].val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Node[now].child[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = Node[now].child[i];</span><br><span class="line">                Node[nxt].fail = Node[Node[now].fail].child[i];</span><br><span class="line">                q.push(nxt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> Node[now].child[i] = Node[Node[now].fail].child[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[now].child[s[i] - <span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            Node[now].child[s[i] - <span class="string">'a'</span>] = ++cnt;</span><br><span class="line">            Node[cnt].init();</span><br><span class="line">        &#125;</span><br><span class="line">        now = Node[now].child[s[i] - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Node[now].val += w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;w;</span><br><span class="line">        insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l;</span><br><span class="line">    getfail();</span><br><span class="line">    mst(f,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line">        f[<span class="number">1</span>][i] = f[<span class="number">2</span>][i] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= l;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= cnt;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[<span class="number">1</span>][j] == -INF) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">26</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = Node[j].child[k];</span><br><span class="line">                f[<span class="number">2</span>][nxt] = max(f[<span class="number">2</span>][nxt],f[<span class="number">1</span>][j] + Node[nxt].val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= cnt;j++) f[<span class="number">1</span>][j] = f[<span class="number">2</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= cnt;i++) ans = max(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="I-qh与复读机IX"><a href="#I-qh与复读机IX" class="headerlink" title="I - qh与复读机IX"></a>I - qh与复读机IX</h5><blockquote><p>I、给出一堆模式串，要求求出长度小于等于$L$并且包含其中任意一个字符串为子串的字符串的总类数量</p></blockquote><p><code>AC自动机</code> <code>矩阵乘法</code> <code>快速幂</code><br>和上面的类似，不过这里的话需要把一trie图中能到达的位置放在矩阵里面，将trie图建成一个邻接矩阵，在图论中一个邻接矩阵$A$，那么$A^k$表示的是路径长度为$k$的对应邻接矩阵，但是这里要求的是至少存在一个模式串的，那么反过来考虑，求出所有的不包含的，剩下的就是包含的，就把trie图上不可达的路径在矩阵中表示出来，求出$l$次幂，统计答案之后，$26^l$表示的是全排列的情况，直接减去就可以，注意取模<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) child[i] = <span class="number">0</span>;</span><br><span class="line">        fail = <span class="number">0</span>;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    ll num[<span class="number">250</span>][<span class="number">250</span>];</span><br><span class="line">    ll w,h;</span><br><span class="line"></span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">        matrix res;</span><br><span class="line">        mst(res.num,<span class="number">0</span>);</span><br><span class="line">        res.h = h;</span><br><span class="line">        res.w = a.w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= h;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= a.w;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= w;k++)&#123;</span><br><span class="line">                    res.num[i][j] = (res.num[i][j] + num[i][k] * a.num[k][j] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll hh,ll ww)</span></span>&#123;</span><br><span class="line">        h = hh;</span><br><span class="line">        w = ww;</span><br><span class="line">        mst(num,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= h;i++) num[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ll n,l,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">1000</span>];</span><br><span class="line">matrix f,x;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">MatrixQuickMod</span><span class="params">(<span class="keyword">const</span> matrix&amp; a,ll b)</span></span>&#123;</span><br><span class="line">    matrix t = a,res;</span><br><span class="line">    res.init(a.h,a.w);</span><br><span class="line">    <span class="keyword">if</span>(b &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * t;</span><br><span class="line">        t = t * t;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[now].child[s[i] - <span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            Node[now].child[s[i] - <span class="string">'a'</span>] = ++cnt;</span><br><span class="line">            Node[cnt].init();</span><br><span class="line">        &#125;</span><br><span class="line">        now = Node[now].child[s[i] - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Node[now].val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[<span class="number">0</span>].child[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            Node[Node[<span class="number">0</span>].child[i]].fail = <span class="number">0</span>;</span><br><span class="line">            q.push(Node[<span class="number">0</span>].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(Node[Node[now].fail].val == <span class="number">1</span>) Node[now].val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Node[now].child[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = Node[now].child[i];</span><br><span class="line">                Node[Node[now].child[i]].fail = Node[Node[now].fail].child[i];</span><br><span class="line">                q.push(Node[now].child[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> Node[now].child[i] = Node[Node[now].fail].child[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ss;</span><br><span class="line">        insert(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l;</span><br><span class="line">    getfail();</span><br><span class="line">    cnt++;</span><br><span class="line">    f.w = f.h = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Node[Node[i].child[j]].val == <span class="number">0</span>) f.num[i + <span class="number">1</span>][Node[i].child[j] + <span class="number">1</span>]++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= cnt;i++) f.num[i + <span class="number">1</span>][cnt + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    f = MatrixQuickMod(f,l);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt + <span class="number">1</span>;i++) ans = (ans + f.num[<span class="number">1</span>][i]) % mod;</span><br><span class="line">    f.num[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">26</span>;</span><br><span class="line">    f.num[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    f.num[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    f.num[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    f.w = f.h = <span class="number">2</span>;</span><br><span class="line">    f = MatrixQuickMod(f,l + <span class="number">1</span>);</span><br><span class="line">    ans = f.num[<span class="number">1</span>][<span class="number">2</span>] - ans;</span><br><span class="line">    ans = (ans + mod) % mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="J-qh与复读机X"><a href="#J-qh与复读机X" class="headerlink" title="J - qh与复读机X"></a>J - qh与复读机X</h5><blockquote><p>J、给出一堆模式串，求出每个模式串在所有的模式串中出现的次数</p></blockquote><p><code>AC自动机</code> <code>SAM</code><br>本来一开始我的想法是每个模式串中间用#号隔开然后拼接，跑一遍AC自动机，结果交上去是TLE。。。（下来之后cjj说我的string+string的那个位置复杂度可能有点大）<br>然后我换成了SAM，直接求出对应的right集合的大小统计一下。。然后就是答案了。。<br><del>然后复杂度的话。。。自动机的复杂度我算不来（逃</del><br><del>后缀自动机txdy!</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[maxn],s2[maxn];</span><br><span class="line"><span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len[maxn],ans[maxn],sum[maxn],tmp[maxn],ccnt[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>,cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">27</span>],fa[maxn&lt;&lt;<span class="number">1</span>],l[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last,np=++cnt;</span><br><span class="line">    last=np,l[np]=l[p]+<span class="number">1</span>;</span><br><span class="line">    ccnt[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fa[p]) ch[p][c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p) fa[np]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(l[q]==l[p]+<span class="number">1</span>) fa[np]=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++cnt;l[nq]=l[p]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">            fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">            <span class="keyword">for</span>(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) sum[l[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) tmp[sum[l[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i;i--) ccnt[fa[tmp[i]]] += ccnt[tmp[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">        len[i] = <span class="built_in">strlen</span>(s1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span>;j &lt; len[i];j++) insert(s2[++len2] = s1[j] - <span class="string">'a'</span>);</span><br><span class="line">        insert(s2[++len2] = <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cal();</span><br><span class="line">    len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len[i];j++)  x = ch[x][s2[++len2]];</span><br><span class="line">        ans[i] = ccnt[x];</span><br><span class="line">        ++len2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="K-qh与复读机XI"><a href="#K-qh与复读机XI" class="headerlink" title="K - qh与复读机XI"></a>K - qh与复读机XI</h5><blockquote><p>K、给出一个字符串$S$，要求输出长度为$1到|S|$的出现次数最多的子串的数量</p></blockquote><p><code>SAM</code> <code>基数排序``right集合</code> <code>Parent树</code><br>SAM的每个节点都对应了一类的子串，那么统计每个right集合的大小，right的集合大小按照parent树往上加，然后根据maxlen数组依次求出对应长度子串的大小最后输出答案即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">2000007</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>,ans[<span class="number">2000007</span>],sum[<span class="number">2000007</span>],f[<span class="number">2000007</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">2000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>,cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">26</span>],fa[maxn&lt;&lt;<span class="number">1</span>],l[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last,np=++cnt;</span><br><span class="line">    last=np,l[np]=l[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fa[p]) ch[p][c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p) fa[np]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(l[q]==l[p]+<span class="number">1</span>) fa[np]=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++cnt;l[nq]=l[p]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">            fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">            <span class="keyword">for</span>(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    f[np]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) insert(s1[i] - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1 + <span class="number">1</span>;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">    build(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) sum[l[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) id[sum[l[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i;i--) f[fa[id[i]]] += f[id[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) ans[l[i]] = max(ans[l[i]],f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len;i;i--) ans[i] = max(ans[i + <span class="number">1</span>],ans[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="L-qh与复读机XII"><a href="#L-qh与复读机XII" class="headerlink" title="L - qh与复读机XII"></a>L - qh与复读机XII</h5><blockquote><p>L、给出一个字符串$ S $，然后给出$ q $个询问，每个询问对应输出$S[l_1,r_1]$在$S[l_2,r_2]$中的出现次数</p></blockquote><p><code>后缀自动机</code> <code>线段树合并</code> <code>倍增</code> <code>right集合</code> <code>Parent树</code><br><del>什么好(po)题想了我三天时间</del><br>后缀自动机的构造过程我其实是比较懵的×<br>但是了解后缀自动机的性质的话这个题实际上就是一个数据结构题了。。。<br>首先要考虑的是找到$S[l_1,r_1]$在后缀自动机上对应的结点的位置，如果暴力的话就是$O(n^2)$了。。<br>然后去康了康<code>倍增算法</code>，先把$S[1,i]$能到达的结点位置预处理出来，实际上就是标记一下last的位置。。<br>然后$O(nlogn)$倍增找到$S[l_1,r_1]$的位置，那么剩下的事情就是要查询这个结点位置对应的$right集合$<br>$right$集合是需要从$parent$树自底向上合并集合得到，集合的合并？<br>用<code>set</code>的<code>insert</code>暴力搞？复杂度太大，启发式合并也救不了。。。。<br>那么用<code>pb_ds</code>的红黑树<code>join</code>？不行，区间不能相交（事后xyy给我说可以启发式合并一个一个插入是能保证复杂度的<br>然后我找到了一个神奇的东西——<code>线段树合并</code><br>线段树合并的时候，如果某个子节点是空的，那么就不需要合并下去了，这里用启发式合并的话保证了合并的复杂度是$O(nlog^2n)$<br>于是就可以做这个题了<br>最开始每个集合对应了一个$endpos$，那么先把它对应在线段树上的位置$+1$，那么查询在某个区间的子串出现次数的时候就只需要查询区间和即可，也就是用线段树维护一个区间和<br>令$len = r_1 - l_1 + 1$,每次查询的区间就是$[ l_2 + len  - 1, r_2]$，返回的区间和就是答案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[maxn];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>,cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">26</span>],fa[maxn],l[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,l1,r1,l2,r2;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lchild[maxn&lt;&lt;<span class="number">3</span>],rchild[maxn&lt;&lt;<span class="number">3</span>],rt[maxn&lt;&lt;<span class="number">3</span>],sum[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> c[maxn],a[maxn],in[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> lp,<span class="keyword">int</span> rp,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) root = ++tot;</span><br><span class="line">    <span class="keyword">if</span>(lp == rp) &#123;</span><br><span class="line">        sum[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (lp + rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) modify(lchild[root],lp,mid,x);</span><br><span class="line">    <span class="keyword">else</span> modify(rchild[root],mid + <span class="number">1</span>,rp,x);</span><br><span class="line">    sum[root] = sum[lchild[root]] + sum[rchild[root]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x^y;</span><br><span class="line">    <span class="keyword">int</span> p = ++tot;</span><br><span class="line">    lchild[p] = merge(lchild[x],lchild[y]);</span><br><span class="line">    rchild[p] = merge(rchild[x],rchild[y]);</span><br><span class="line">    sum[p] = sum[x] + sum[y];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> lp,<span class="keyword">int</span> rp,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= lp &amp;&amp; rp &lt;= R) <span class="keyword">return</span> sum[root];</span><br><span class="line">    <span class="keyword">int</span> mid = (lp + rp) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> query(lchild[root],lp,mid,L,R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> query(rchild[root],mid + <span class="number">1</span>,rp,L,R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (query(lchild[root],lp,mid,L,R) + query(rchild[root],mid + <span class="number">1</span>,rp,L,R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last,np=++cnt;</span><br><span class="line">    last=np,l[np]=l[p]+<span class="number">1</span>;</span><br><span class="line">    in[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fa[p]) ch[p][c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p) fa[np]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(l[q]==l[p]+<span class="number">1</span>) fa[np]=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++cnt;l[nq]=l[p]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">            fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">            <span class="keyword">for</span>(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = insert(s1[i] - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1 + <span class="number">1</span>;</span><br><span class="line">    build(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) c[l[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) a[c[l[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt;i;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = a[i];</span><br><span class="line">        <span class="keyword">if</span>(in[pos]) modify(rt[pos],<span class="number">1</span>,n,l[pos]);</span><br><span class="line">        rt[fa[pos]] = merge(rt[fa[pos]],rt[pos]);</span><br><span class="line">        f[pos][<span class="number">0</span>] = fa[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">18</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++)&#123;</span><br><span class="line">            f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        <span class="keyword">int</span> len1 = r1 - l1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = id[r1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">18</span>;j &gt;=<span class="number">0</span>;j--) <span class="keyword">if</span>(l[f[pos][j]] &gt;= len1) pos = f[pos][j];</span><br><span class="line">        <span class="keyword">int</span> lp = l2 + len1 - <span class="number">1</span>,rp = r2;</span><br><span class="line">        <span class="keyword">if</span>(lp &gt; rp) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = query(rt[pos],<span class="number">1</span>,n,lp,rp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="M-一切的开始-世界树的测验"><a href="#M-一切的开始-世界树的测验" class="headerlink" title="M - 一切的开始,世界树的测验"></a>M - 一切的开始,世界树的测验</h5><blockquote><p>M、给出$ n $个数，可以有$ k $次机会将一个数改成$\sum _{ i = 1} ^ {x} i$，求选出若干个数字可以得到$ s $的方案数</p></blockquote><p><code>dfs</code> <code>meet in middle</code><br><del>又是您，您出的题可卡死我啰</del><br> 直接交了个裸的$O(3^n)$然后被制裁了<br> 顺着题解给的板子敲了一下$meet\ in \ middle$，zdynb<br> 先搜索一半把可能的情况存储起来，中间有一点剪枝<br> 然后再搜索后一半满足条件的就加到方案数里面<br> 时间复杂度$O(3^{n/2})$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[<span class="number">30</span>];</span><br><span class="line">ll n,k,s,mid;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt; M[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll sum,ll cur,ll cnt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == mid + <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(M[cnt][sum] == <span class="number">0</span>) M[cnt][sum] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> M[cnt][sum] ++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll tmp = (a[cur] + <span class="number">1</span>) * a[cur] / <span class="number">2</span>;</span><br><span class="line">dfs1(sum,cur + <span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">if</span>(a[cur] + sum &lt;= s) dfs1(sum + a[cur],cur + <span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">if</span>(cnt &lt; k &amp;&amp; tmp + sum &lt;= s) dfs1(sum + tmp,cur + <span class="number">1</span>,cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll sum,ll cur,ll cnt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == n + <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i + cnt &lt;= k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(M[i].count(s - sum)) ans += M[i][s - sum];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll tmp = (a[cur] + <span class="number">1</span>) * a[cur] / <span class="number">2</span>;</span><br><span class="line">dfs2(sum,cur + <span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">if</span>(a[cur] + sum &lt;= s) dfs2(sum + a[cur],cur + <span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">if</span>(cnt &lt; k &amp;&amp; tmp + sum &lt;= s) dfs2(sum + tmp,cur + <span class="number">1</span>,cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">mid = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    dfs1(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">0</span>,mid + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="N-第一个征程，噩梦的开始"><a href="#N-第一个征程，噩梦的开始" class="headerlink" title="N - 第一个征程，噩梦的开始"></a>N - 第一个征程，噩梦的开始</h5><blockquote><p>N、给出一个地图以及限制条件，输出最多能到达的位置数量</p></blockquote><p><code>BFS</code><br>一开始没读懂题。。。然后就都是等到题解下来了才写的。。<br>其实思路很简单，就是BFS一遍，不过要用deque维护一下优先拓展上下位置，因为花费是0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line"><span class="keyword">int</span> xx,yy;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"></span><br><span class="line">node(<span class="keyword">int</span> posx,<span class="keyword">int</span> posy,<span class="keyword">int</span> posl,<span class="keyword">int</span> posr):x(posx),y(posy),l(posl),r(posr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> mmp[<span class="number">2500</span>][<span class="number">2500</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2500</span>][<span class="number">2500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; Q;</span><br><span class="line">Q.push_back(node(x,y - <span class="number">1</span>,xx,yy));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">vis[x][y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">node cur = Q.front();</span><br><span class="line">Q.pop_front();</span><br><span class="line"><span class="keyword">if</span>(cur.y + <span class="number">1</span> &lt; m &amp;&amp; mmp[cur.x][cur.y + <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; !vis[cur.x][cur.y + <span class="number">1</span>] &amp;&amp; cur.r != <span class="number">0</span>)&#123;</span><br><span class="line">vis[cur.x][cur.y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line">Q.push_back(node(cur.x,cur.y + <span class="number">1</span>,cur.l,cur.r - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur.y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; mmp[cur.x][cur.y - <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; !vis[cur.x][cur.y - <span class="number">1</span>] &amp;&amp; cur.l != <span class="number">0</span>)&#123;</span><br><span class="line">vis[cur.x][cur.y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line">Q.push_back(node(cur.x,cur.y - <span class="number">1</span>,cur.l - <span class="number">1</span>,cur.r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur.x - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; mmp[cur.x - <span class="number">1</span>][cur.y] != <span class="string">'*'</span> &amp;&amp; !vis[cur.x - <span class="number">1</span>][cur.y])&#123;</span><br><span class="line">vis[cur.x - <span class="number">1</span>][cur.y] = <span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line">Q.push_front(node(cur.x - <span class="number">1</span>,cur.y,cur.l,cur.r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur.x + <span class="number">1</span> &lt;= n &amp;&amp; mmp[cur.x + <span class="number">1</span>][cur.y] != <span class="string">'*'</span> &amp;&amp; !vis[cur.x + <span class="number">1</span>][cur.y])&#123;</span><br><span class="line">vis[cur.x + <span class="number">1</span>][cur.y] = <span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line">Q.push_front(node(cur.x + <span class="number">1</span>,cur.y,cur.l,cur.r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y&gt;&gt;xx&gt;&gt;yy;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;mmp[i];</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="O-第二个征程，拔起剪枝哀伤"><a href="#O-第二个征程，拔起剪枝哀伤" class="headerlink" title="O - 第二个征程，拔起剪枝哀伤"></a>O - 第二个征程，拔起剪枝哀伤</h5><blockquote><p>O、给定$n$个数，求出一个序列使得这n个数均可以由所得序列中的数作差得到</p></blockquote><p><code>dfs</code> <code>迭代加深</code><br>用状态压缩将现在能得到的$a_i$表示出来，然后每次搜索如果在某个深度不能得到解，就向下加深。。<br>主要的就是状态变换的位置容易写错，而且用lower_bound的话可以优化一下时间复杂度<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a[<span class="number">60</span>],ans[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> dep = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">long</span> <span class="keyword">long</span> statu)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == dep)&#123;</span><br><span class="line">ans[cur] = a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= cur - <span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a[n] - ans[k];</span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(a + <span class="number">1</span>,a + n + <span class="number">1</span>,tmp) - a;</span><br><span class="line"><span class="keyword">if</span>(a[pos] == tmp)&#123;</span><br><span class="line">statu = statu | (<span class="number">1l</span>l &lt;&lt; (pos - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> statu == (<span class="number">1l</span>l &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cur - <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n - <span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(statu &amp; (<span class="number">1l</span>l &lt;&lt; (j - <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = ans[i] + a[j];</span><br><span class="line"><span class="keyword">if</span>(tmp &lt;= ans[cur - <span class="number">1</span>] || tmp &gt;= a[n]) <span class="keyword">continue</span>;</span><br><span class="line">ans[cur] = tmp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nxt = statu;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= cur - <span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">int</span> ttmp = tmp - ans[k];</span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(a + <span class="number">1</span>,a + n + <span class="number">1</span>,ttmp) - a;</span><br><span class="line"><span class="keyword">if</span>(a[pos] == ttmp)&#123;</span><br><span class="line">nxt = nxt | (<span class="number">1l</span>l &lt;&lt; (pos - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfs(cur + <span class="number">1</span>,nxt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sort(a + <span class="number">1</span>,a + n + <span class="number">1</span>);</span><br><span class="line">n = unique(a + <span class="number">1</span>,a + n + <span class="number">1</span>) - (a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;a[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">mst(ans,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!dfs(<span class="number">2</span>,<span class="number">0</span>))&#123;</span><br><span class="line">dep++;</span><br><span class="line">mst(ans,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dep&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= dep;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="P-征程的结束，吉安娜"><a href="#P-征程的结束，吉安娜" class="headerlink" title="P - 征程的结束，吉安娜"></a>P - 征程的结束，吉安娜</h5><blockquote><p>P、先给出一个01矩阵，0表示不能移动的建筑，1表示能移动的建筑或者水晶，给出水晶坐标位置，以及两个坐标，问从一个坐标到另外一个坐标的最小时间花费</p></blockquote><p><code>dfs</code> <code>spfa</code> <code>最短路</code></p><p>先spfa预处理出可能的空白格子（就是1的位置）到某个指定位置的上下左右的时间代价<br>这里用$dist_{x_1,y_1,x_2,y_2,dir}$表示状态<br>然后用启发式搜索减小dfs经过重复路径的次数来加快dfs的效率即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line">pos(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy):x(xx),y(yy)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mmp[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,q,ans;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">40</span>][<span class="number">40</span>][<span class="number">40</span>][<span class="number">40</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">40</span>][<span class="number">40</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dirx[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> diry[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,ex,ey;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cx,<span class="keyword">int</span> cy)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cx &gt;= <span class="number">1</span> &amp;&amp; cx &lt;= n &amp;&amp; cy &gt;= <span class="number">1</span> &amp;&amp; cy &lt;= m &amp;&amp; mmp[cx][cy]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> nowx,<span class="keyword">int</span> nowy,<span class="keyword">int</span> dir)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> vvis[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;pos&gt; q;</span><br><span class="line">q.push(pos(x,y));</span><br><span class="line">dist[x][y][x][y][dir] = <span class="number">0</span>;</span><br><span class="line">mst(vvis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">pos now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vvis[now.x][now.y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> nxtx = now.x + dirx[i],nxty = now.y + diry[i];</span><br><span class="line"><span class="keyword">if</span>(check(nxtx,nxty) &amp;&amp; (nxtx != nowx || nxty != nowy))&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[x][y][nxtx][nxty][dir] &gt; dist[x][y][now.x][now.y][dir] + <span class="number">1</span>)&#123;</span><br><span class="line">dist[x][y][nxtx][nxty][dir] = dist[x][y][now.x][now.y][dir] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!vvis[nxtx][nxty])&#123;</span><br><span class="line">q.push(pos(nxtx,nxty));</span><br><span class="line">vvis[nxtx][nxty] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> kx,<span class="keyword">int</span> ky,<span class="keyword">int</span> sx,<span class="keyword">int</span> sy,<span class="keyword">int</span> cnt,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(sx == ex &amp;&amp; sy == ey) &#123;</span><br><span class="line">ans = cnt;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[sx][sy][k] &lt;= cnt) <span class="keyword">return</span> ;</span><br><span class="line">    vis[sx][sy][k] = cnt;</span><br><span class="line">    <span class="keyword">int</span> used[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dir,len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        len = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = sx + dirx[j],y = sy + diry[j];</span><br><span class="line">            <span class="keyword">if</span>(check(x,y) &amp;&amp; len &gt; dist[x][y][kx][ky][(j+<span class="number">2</span>)%<span class="number">4</span>] &amp;&amp; !used[j])</span><br><span class="line">                len = dist[x][y][kx][ky][(j+<span class="number">2</span>)%<span class="number">4</span>],dir = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len != INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x = sx + dirx[dir],y = sy + diry[dir];</span><br><span class="line">            used[dir] = <span class="number">1</span>;</span><br><span class="line">            dfs(sx,sy,x,y,cnt+dist[x][y][kx][ky][(dir+<span class="number">2</span>)%<span class="number">4</span>]+<span class="number">1</span>,(dir+<span class="number">2</span>)%<span class="number">4</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;mmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mst(dist,<span class="number">0x3f</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mmp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line"><span class="keyword">int</span> nxtx = i + dirx[k];</span><br><span class="line"><span class="keyword">int</span> nxty = j + diry[k];</span><br><span class="line"><span class="keyword">if</span>(check(nxtx,nxty))&#123;</span><br><span class="line">spfa(i,j,nxtx,nxty,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;ex&gt;&gt;ey;</span><br><span class="line">ans = INF;</span><br><span class="line">mst(vis,<span class="number">0x3f</span>);</span><br><span class="line">dfs(a,b,c,d,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(ans == INF) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Q-猛男24点"><a href="#Q-猛男24点" class="headerlink" title="Q - 猛男24点"></a>Q - 猛男24点</h5><blockquote><p>Q、两个人对弈，给出牌区的4张牌以及两个人的手牌，先手的获胜策略是到他的时候牌区能凑成24点，而后手的获胜条件是到他的时候牌区不能凑成24点，先手可以进行的操作是将自己的牌换到牌区里面，后手可以进行的操作是将牌区的牌与自己手中的黑牌进行交换。如果先手第一局不换牌，那么游戏会继续，反之游戏结束。</p></blockquote><p><code>博弈</code> <code>搜索</code> <code>枚举</code><br>到先手的时候，如果能够凑成24点，那么当前不是第一局或者后手必败的情况下即可获胜<br>而到后手的时候，只要不能凑成24点，那么就可以获胜了<br>先枚举24点的情况将其哈希之后可以方便判断<br>然后每次回溯注意要写在dfs的前后。。。如果放在if后面的情况下可能没法回溯回去就直接返回了（我傻了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">statu</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">statu(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)&#123;</span><br><span class="line">num[<span class="number">0</span>] = a;</span><br><span class="line">num[<span class="number">1</span>] = b;</span><br><span class="line">num[<span class="number">2</span>] = c;</span><br><span class="line">num[<span class="number">3</span>] = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> statu &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] == a.num[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> statu &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[<span class="number">0</span>] == a.num[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[<span class="number">1</span>] == a.num[<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(num[<span class="number">2</span>] == a.num[<span class="number">2</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> num[<span class="number">3</span>] &lt; a.num[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[<span class="number">2</span>] &lt; a.num[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[<span class="number">1</span>] &lt; a.num[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[<span class="number">0</span>] &lt; a.num[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span>&#123;</span></span><br><span class="line"><span class="keyword">bool</span> color;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> nows[<span class="number">4</span>];</span><br><span class="line">card cards[<span class="number">10</span>],card1[<span class="number">10</span>],card2[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> (a + b);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>) <span class="keyword">return</span> (a - b);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">3</span>) <span class="keyword">return</span> (a * b);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">4</span>) <span class="keyword">return</span> (a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">4</span>;k++)&#123;</span><br><span class="line"><span class="keyword">double</span> tmp1,tmp2,tmp3;</span><br><span class="line">tmp1 = cal(a[<span class="number">0</span>],a[<span class="number">1</span>],i);</span><br><span class="line">tmp2 = cal(tmp1,a[<span class="number">2</span>],j);</span><br><span class="line">tmp3 = cal(tmp2,a[<span class="number">3</span>],k);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp3 - <span class="number">24</span>) &lt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">tmp1 = cal(a[<span class="number">0</span>],a[<span class="number">1</span>],i);</span><br><span class="line">tmp2 = cal(a[<span class="number">2</span>],a[<span class="number">3</span>],k);</span><br><span class="line">tmp3 = cal(tmp1,tmp2,j);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp3 - <span class="number">24</span>) &lt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">tmp1 = cal(a[<span class="number">1</span>],a[<span class="number">2</span>],j);</span><br><span class="line">tmp2 = cal(a[<span class="number">0</span>],tmp1,i);</span><br><span class="line">tmp3 = cal(tmp2,a[<span class="number">3</span>],k);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp3 - <span class="number">24</span>) &lt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">tmp1 = cal(a[<span class="number">1</span>],a[<span class="number">2</span>],j);</span><br><span class="line">tmp2 = cal(tmp1,a[<span class="number">3</span>],k);</span><br><span class="line">tmp3 = cal(tmp2,a[<span class="number">0</span>],i);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp3 - <span class="number">24</span>) &lt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">tmp1 = cal(a[<span class="number">2</span>],a[<span class="number">3</span>],k);</span><br><span class="line">tmp2 = cal(a[<span class="number">1</span>],tmp1,j);</span><br><span class="line">tmp3 = cal(a[<span class="number">0</span>],tmp2,i);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp3 - <span class="number">24</span>) &lt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> i = <span class="number">1.0</span>;i &lt;= <span class="number">10.0</span>;i += <span class="number">1.0</span>)&#123;</span><br><span class="line">a[<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> j = <span class="number">1.0</span>;j &lt;= <span class="number">10.0</span>;j += <span class="number">1.0</span>)&#123;</span><br><span class="line">a[<span class="number">1</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> k = <span class="number">1.0</span>;k &lt;= <span class="number">10.0</span>;k += <span class="number">1.0</span>)&#123;</span><br><span class="line">a[<span class="number">2</span>] = k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> l = <span class="number">1.0</span>;l &lt;= <span class="number">10.0</span>;l += <span class="number">1.0</span>)&#123;</span><br><span class="line">a[<span class="number">3</span>] = l;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span>(check())&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) b[i] = a[i];</span><br><span class="line">    sort(b,b + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) tmp = tmp * <span class="number">11</span> + b[i];</span><br><span class="line"><span class="keyword">if</span>(M[tmp] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        M[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(statu x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) b[i] = nows[i];</span><br><span class="line">sort(b,b + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) tmp = tmp * <span class="number">11</span> + b[i];</span><br><span class="line">    <span class="keyword">if</span>(M[tmp] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">bool</span> now,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> nowstatu = find(statu(nows[<span class="number">0</span>],nows[<span class="number">1</span>],nows[<span class="number">2</span>],nows[<span class="number">3</span>]));</span><br><span class="line"><span class="keyword">if</span>(now == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(nowstatu)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep != <span class="number">1</span> || dfs(!now,dep + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++)&#123;</span><br><span class="line">swap(card1[i],cards[j]);</span><br><span class="line">nows[j - <span class="number">1</span>] = cards[j].num;</span><br><span class="line">used[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = dfs(!now,dep + <span class="number">1</span>);</span><br><span class="line">used[i] = <span class="number">0</span>;</span><br><span class="line">swap(card1[i],cards[j]);</span><br><span class="line">nows[j - <span class="number">1</span>] = cards[j].num;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!nowstatu) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(card2[i].color == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++)&#123;</span><br><span class="line">swap(card2[i],cards[j]);</span><br><span class="line">nows[j - <span class="number">1</span>] = cards[j].num;</span><br><span class="line"><span class="keyword">bool</span> flag = dfs(!now,dep + <span class="number">1</span>);</span><br><span class="line">swap(card2[i],cards[j]);</span><br><span class="line">nows[j - <span class="number">1</span>] = cards[j].num;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= T;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num&gt;&gt;c;</span><br><span class="line">cards[j].num = num,cards[j].color = (c == <span class="string">'b'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">nows[j - <span class="number">1</span>] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num&gt;&gt;c;</span><br><span class="line">card1[j].num = num,card1[j].color = (c == <span class="string">'b'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num&gt;&gt;c;</span><br><span class="line">card2[j].num = num,card2[j].color = (c == <span class="string">'b'</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfs(<span class="number">0</span>,<span class="number">1</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"You are MengNan!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Gan si 25zai!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="R-如果早知道wf题也会被ak"><a href="#R-如果早知道wf题也会被ak" class="headerlink" title="R - 如果早知道wf题也会被ak"></a>R - 如果早知道wf题也会被ak</h5><blockquote><p>R、给出一个长度为$n$的字符串，求其最长偶回文子串的长度</p></blockquote><p><code>Manacher</code><br>马拉车板题，在板子上面改一下就可以了。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">30000007</span>],s2[<span class="number">30000007</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">30000007</span>],id = <span class="number">1</span>,mx = <span class="number">1</span>,ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    s2[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        s2[j++] = s1[i];</span><br><span class="line">        s2[j++] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s2[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">    <span class="keyword">int</span> len = init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; mx) p[i] = min(p[<span class="number">2</span> * id - i],mx - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s2[i - p[i]] == s2[i + p[i]])&#123;</span><br><span class="line">            p[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2[i] == <span class="string">'#'</span>) ans = max(ans,p[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mx &lt; i + p[i])&#123;</span><br><span class="line">            id = i;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="S-如果早知道wf题也会被ak-DLC1"><a href="#S-如果早知道wf题也会被ak-DLC1" class="headerlink" title="S - 如果早知道wf题也会被ak - DLC1"></a>S - 如果早知道wf题也会被ak - DLC1</h5><blockquote><p>S、给出两个字符串，求这两个串的最长公共子串长度</p></blockquote><p><code>SA</code> <code>SAM</code> <code>Height数组</code><br>也是一个求LCP的板题，一开始交了写好的SA上去结果RE了（写糊了<br>然后心态崩了抄了一个SAM上去。。。这里还是放一下SA的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[MAX],s2[MAX];</span><br><span class="line"><span class="keyword">int</span> sa[MAX],h[MAX],x[MAX],y[MAX],r[MAX],rk[MAX],m,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1,len2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a+len] == r[b+len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">m = M;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=m;i++) r[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++) r[x[i] = s1[i]] ++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++) r[i] += r[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) sa[--r[x[i]]] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,p = <span class="number">1</span>;j&lt;=len1;j&lt;&lt;=<span class="number">1</span>,m = p)&#123;</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - j;i&lt;len1;i++) y[p++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++) <span class="keyword">if</span>(sa[i] &gt;= j) y[p++] = sa[i] - j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=m;i++) r[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++) r[x[i]] ++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=m;i++) r[i] += r[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) sa[--r[x[y[i]]]] = y[i];</span><br><span class="line">swap(x,y);</span><br><span class="line">    p = <span class="number">1</span>;</span><br><span class="line">    x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len1;i++) x[sa[i]] = cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> j,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;h[rk[i++]] = k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j = sa[rk[i] - <span class="number">1</span>];s1[i + k] == s1[j + k];k++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line">len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">s1[len1] = <span class="string">'$'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len2;i++) s1[i + len1 + <span class="number">1</span>] = s2[i];</span><br><span class="line">    <span class="keyword">int</span> tmp = len1;</span><br><span class="line">len1 = len1+len2+<span class="number">1</span>;</span><br><span class="line">    len2 = tmp;</span><br><span class="line">    SA();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(min(sa[i],sa[i<span class="number">-1</span>]) &lt; len2 &amp;&amp; max(sa[i<span class="number">-1</span>],sa[i]) &gt; len2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; h[i]) ans = h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;A-qh与复读机I&quot;&gt;&lt;a href=&quot;#A-qh与复读机I&quot; class=&quot;headerlink&quot; title=&quot;A - qh与复读机I&quot;&gt;&lt;/a&gt;A - qh与复读机I&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;A、每次按顺序给出$ n $个字符串，求出每个字符
      
    
    </summary>
    
      <category term="UESTC" scheme="http://decision01.cn/categories/UESTC/"/>
    
      <category term="ACM" scheme="http://decision01.cn/categories/UESTC/ACM/"/>
    
    
      <category term="字符串" scheme="http://decision01.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="ACM" scheme="http://decision01.cn/tags/ACM/"/>
    
      <category term="搜索" scheme="http://decision01.cn/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>UESTC暑假前集训—图论-解题报告</title>
    <link href="http://decision01.cn/2019/06/02/UESTC%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD-%E5%9B%BE%E8%AE%BA/"/>
    <id>http://decision01.cn/2019/06/02/UESTC暑期前集训-图论/</id>
    <published>2019-06-02T13:16:20.000Z</published>
    <updated>2019-06-08T04:25:06.764Z</updated>
    
    <content type="html"><![CDATA[<h5 id="A-迷宫"><a href="#A-迷宫" class="headerlink" title="A - 迷宫"></a>A - 迷宫</h5><blockquote><p>给出一个带权有向图，翻转一条边的代价是其权重，求出翻转边后图中无环的最小代价</p></blockquote><p><code>二分</code> <code>拓扑判环</code><br>一开始只能想到要让图中没有环，但是想不清楚怎么操作，于是等到题解emmmm<br>考虑对于要改变的边，相当于删去之后反向加回来，那么代价就是边里面权值最大的<br>二分权值，权值越大的可以改变的边越多，二分最少的代价使得不存在环即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line">ll w;</span><br><span class="line"><span class="keyword">int</span> top[maxn],in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll now)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) edges[i].clear();</span><br><span class="line">mst(in,<span class="number">0</span>);</span><br><span class="line">mst(top,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G1[i].dist &gt; now)&#123;</span><br><span class="line">edges[G1[i].from].push_back(G1[i].to);</span><br><span class="line">in[G1[i].to] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(in[i] == <span class="number">0</span>) q.push(i),top[i] = ++cnt;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> len = edges[u].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = edges[u][i];</span><br><span class="line">in[v] --;</span><br><span class="line"><span class="keyword">if</span>(!in[v]) q.push(v),top[v] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(in[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">G1.push_back(Edge(u,v,w));</span><br><span class="line">&#125;</span><br><span class="line">ll l = <span class="number">0</span>,r = <span class="number">2e9</span>,mid,ans;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">ans = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="B-oydy的征途I"><a href="#B-oydy的征途I" class="headerlink" title="B - oydy的征途I"></a>B - oydy的征途I</h5><blockquote><p>给定一个带权无向图，求出最小生成树但是其中某一条边可以0权值，已经可能的最小权值和的总数</p></blockquote><p><code>最小生成树</code><br>先求出最小生成树，把最大权的边删去之后，求剩下的边的连通性<br>时间复杂度$ O(mlogm) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> u,v,cnt,maxx = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">ll sum = <span class="number">0</span>,w;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tfind</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? x : fa[x] = tfind(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">G.push_back(Edge(u,v,w));</span><br><span class="line">&#125;</span><br><span class="line">sort(G.begin(),G.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">u = G[i].from,v = G[i].to;</span><br><span class="line">u = tfind(u),v = tfind(v);</span><br><span class="line"><span class="keyword">if</span>(u != v)&#123;</span><br><span class="line">fa[v] = u;</span><br><span class="line">cnt --;</span><br><span class="line">sum += G[i].dist;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line">sum -= G[i].dist;</span><br><span class="line">    maxx = G[i].dist;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i].dist &gt;= maxx) <span class="keyword">break</span>;</span><br><span class="line">u = G[i].from,v = G[i].to;</span><br><span class="line">u = tfind(u),v = tfind(v);</span><br><span class="line"><span class="keyword">if</span>(u != v)&#123;</span><br><span class="line">fa[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i].dist &lt; maxx) <span class="keyword">continue</span>;</span><br><span class="line">u = G[i].from,v = G[i].to;</span><br><span class="line">u = tfind(u),v = tfind(v);</span><br><span class="line"><span class="keyword">if</span>(u != v) ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">" "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="C-oydy的征途II"><a href="#C-oydy的征途II" class="headerlink" title="C - oydy的征途II"></a>C - oydy的征途II</h5><blockquote><p>给定一个有向图，如果存在欧拉路径的话就输出最小字典序的欧拉路径</p></blockquote><p><code>欧拉路径</code> <code>手写栈</code><br><del>WA8 WA15 TLE28 </del><br>我就是个弟弟<br>WA8是因为出入栈顺序的问题，WA15是因为地点直接设置成了1，TLE是因为遍历的是邻接表，所以如果存在2e6个1的自环的情况下时间复杂度会达到$ O(m ^ 2) $<br>改成用栈删边之后，时间复杂度降低到$ O(m) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G_;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> in[maxn],out[maxn],beg[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; all;</span><br><span class="line"><span class="keyword">int</span> n,m,s = <span class="number">0</span>,t = <span class="number">0</span>,flag = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">all.push(s);</span><br><span class="line">mst(beg,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!all.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now = all.top();</span><br><span class="line"><span class="keyword">if</span>(beg[now] == out[now])&#123;</span><br><span class="line">ans.push_back(now);</span><br><span class="line">all.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now][beg[now]]].to;</span><br><span class="line">beg[now] ++;</span><br><span class="line">all.push(v);</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">G_.push_back(Edge(u,v));</span><br><span class="line">&#125;</span><br><span class="line">sort(G_.begin(),G_.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">G.push_back(G_[i]);</span><br><span class="line">edges[G_[i].from].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">out[G_[i].from] ++;</span><br><span class="line">in[G_[i].to] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i] == out[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(out[i] - in[i] == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="number">0</span>) s = i;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(in[i] - out[i] == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="number">0</span>) t = i;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="number">0</span> &amp;&amp; t == <span class="number">0</span> &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(out[i] != <span class="number">0</span>)&#123;s = i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s != <span class="number">0</span> &amp;&amp; t != <span class="number">0</span> &amp;&amp; flag == <span class="number">0</span>) solve();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"What a shame!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt != m)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"What a shame!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = ans.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="D-oydy的征途III"><a href="#D-oydy的征途III" class="headerlink" title="D - oydy的征途III"></a>D - oydy的征途III</h5><blockquote><p>给定一个带权无向图，从第一个点开始，求出到一个序列的点的最短距离</p></blockquote><p><code>最短路</code> <code>树链剖分</code> `<br>除去树之后多出来的边比较少，所以先把树拿出来求树上距离，再跑出剩下30条边的端点到其他点的最短路<br>每次询问取经过剩下的边上的端点距离和树上距离<br>树上距离我直接扒了一棵生成树下来树剖<br>时间复杂度$ O(30(n + m)logn + nlogn) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll l,r;</span><br><span class="line">ll sum;</span><br><span class="line">&#125;tr[maxn * <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll u;</span><br><span class="line">ll d;</span><br><span class="line">node(ll uu,ll dd):u(uu),d(dd)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G1,G2,G;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; edges1[maxn],edges2[maxn];</span><br><span class="line">ll fa[maxn],siz[maxn],dep[maxn],minn[maxn],son[maxn],pos[maxn],top[maxn];</span><br><span class="line">ll dist[<span class="number">65</span>][maxn];</span><br><span class="line">ll mn[maxn],tid = <span class="number">0</span>,f[maxn];</span><br><span class="line"></span><br><span class="line">ll n,m,cnt = <span class="number">0</span>;</span><br><span class="line">ll from,to;</span><br><span class="line">ll dis;</span><br><span class="line">ll t,nxt,now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tfind</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == f[x] ? x : (f[x] = tfind(f[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll pre,ll deep)</span></span>&#123;</span><br><span class="line">fa[now] = pre;</span><br><span class="line">siz[now]++;</span><br><span class="line">dep[now] = deep;</span><br><span class="line">ll len = edges2[now].size();</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ll v = G2[edges2[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(v == pre) <span class="keyword">continue</span>;</span><br><span class="line">minn[v] = G2[edges2[now][i]].dist;</span><br><span class="line">dfs1(v,now,deep+<span class="number">1</span>);</span><br><span class="line">siz[now] += siz[v];</span><br><span class="line"><span class="keyword">if</span>(son[now] == <span class="number">-1</span> || siz[son[now]] &lt; siz[v]) son[now] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll chain)</span></span>&#123;</span><br><span class="line">pos[now] = tid++;</span><br><span class="line">top[now] = chain;</span><br><span class="line">mn[pos[now]] = minn[now];</span><br><span class="line">ll len = edges2[now].size();</span><br><span class="line"><span class="keyword">if</span>(son[now] == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">dfs2(son[now],chain); </span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ll v = G2[edges2[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(v != fa[now] &amp;&amp; v != son[now])&#123;</span><br><span class="line">dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line">tr[k].l = l;</span><br><span class="line">tr[k].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">tr[k].sum = mn[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">build(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">tr[k].sum = tr[k&lt;&lt;<span class="number">1</span>].sum+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll s,ll t,ll l,ll r,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == l&amp;&amp; t == r)&#123;</span><br><span class="line"><span class="keyword">return</span> tr[k].sum;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(t &lt;= mid) <span class="keyword">return</span> query(s,t,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s &gt; mid) <span class="keyword">return</span> query(s,t,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(s,mid,l,mid,k&lt;&lt;<span class="number">1</span>)+query(mid + <span class="number">1</span>,t,mid + <span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll s,ll t)</span></span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">ll chain1 = top[s],chain2 = top[t];</span><br><span class="line"><span class="keyword">while</span>(chain1 != chain2)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[chain1] &lt; dep[chain2]) swap(chain1,chain2),swap(s,t);</span><br><span class="line"><span class="keyword">if</span>(chain1 == <span class="number">1</span>) ans += query(pos[chain1] + <span class="number">1</span>,pos[s],<span class="number">1</span>,tid - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> ans += query(pos[chain1],pos[s],<span class="number">1</span>,tid<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">s = fa[chain1];</span><br><span class="line">chain1 = top[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == t) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">if</span>(dep[s] &gt; dep[t]) swap(s,t);</span><br><span class="line">ans += query(pos[son[s]],pos[t],<span class="number">1</span>,tid - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(ll s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++) dist[cnt][i] = INF;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    mst(vis,<span class="number">0</span>);</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(s,<span class="number">0</span>));</span><br><span class="line">    dist[cnt][s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    node now = q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    ll u = now.u;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    ll len = edges1[u].size();</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    ll v = G1[edges1[u][i]].to;</span><br><span class="line">    <span class="keyword">if</span>(dist[cnt][v] &gt; G1[edges1[u][i]].dist +  dist[cnt][u])&#123;</span><br><span class="line">    dist[cnt][v] = G1[edges1[u][i]].dist +  dist[cnt][u];</span><br><span class="line">    q.push(node(v,dist[cnt][v]));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++) f[i] = i;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;from&gt;&gt;to&gt;&gt;dis;</span><br><span class="line">ll a = tfind(from),b = tfind(to);</span><br><span class="line">G1.push_back(Edge(from,to,dis));</span><br><span class="line">G1.push_back(Edge(to,from,dis));</span><br><span class="line">edges1[from].push_back(G1.size() - <span class="number">2</span>);</span><br><span class="line">edges1[to].push_back(G1.size() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">    G2.push_back(Edge(from,to,dis));</span><br><span class="line">    G2.push_back(Edge(to,from,dis));</span><br><span class="line">    edges2[from].push_back(G2.size() - <span class="number">2</span>);</span><br><span class="line">    edges2[to].push_back(G2.size() - <span class="number">1</span>);</span><br><span class="line">    f[b] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">G.push_back(Edge(from,to,dis));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mst(son,<span class="number">-1</span>);</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,tid - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">ll l = G.size();</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">dij(G[i].from);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= t;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;nxt;</span><br><span class="line">ll tans = Query(now,nxt);</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">0</span>;j &lt; l;j++)  tans = min(tans,dist[j][now] + dist[j][nxt]);</span><br><span class="line">ans += tans;</span><br><span class="line">now = nxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="E-变色龙"><a href="#E-变色龙" class="headerlink" title="E - 变色龙"></a>E - 变色龙</h5><blockquote><p>给定$ n $个点，$ m $条边，每条边都有颜色，求出从1号点到$ n $号点所需要变换颜色最多的次数</p></blockquote><p><code>以边代点</code> <code>拆点</code><br>一开始能想到的只有将一条边经过一个点到另外一条边考虑成从一个点到另外一个点，如果颜色相同的两个点的权值就是0，反之为1<br>但是遇到菊花图的时候空间复杂度是$ O(m^2) $，如不存边的话时间复杂度又会变成$ O(m^2) $<br>于是看了题解知道要拆点QAQ，用<code>map</code>把空间复杂度降到$ O(m + n) $，跑一遍dijkstra求最短路再除2<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn*<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,w));</span><br><span class="line">G.push_back(Edge(v,u,w));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp1,tmp2;</span><br><span class="line">tmp1.first = u;</span><br><span class="line">tmp1.second = color;</span><br><span class="line">tmp2.first = v;</span><br><span class="line">tmp2.second = color;</span><br><span class="line"><span class="keyword">if</span>(node[tmp1] == <span class="number">0</span>) node[tmp1] = ++cnt;</span><br><span class="line"><span class="keyword">if</span>(node[tmp2] == <span class="number">0</span>) node[tmp2] = ++cnt;</span><br><span class="line">addedge(u,node[tmp1],<span class="number">1</span>);</span><br><span class="line">addedge(node[tmp1],node[tmp2],<span class="number">0</span>);</span><br><span class="line">addedge(node[tmp2],v,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[cnt + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dist[cnt + <span class="number">1</span>];</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) dist[i] = INF;</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q.push(Node(<span class="number">1</span>,dist[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node now = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> u = now.u;</span><br><span class="line"><span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> len = edges[u].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[u][i]].to;</span><br><span class="line"><span class="keyword">if</span>(dist[v] &gt; dist[u] + G[edges[u][i]].dist)&#123;</span><br><span class="line">dist[v] = dist[u] + G[edges[u][i]].dist;</span><br><span class="line">q.push(Node(v,dist[v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[n] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("std.in","r",stdin);</span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); </span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> u,v,color;</span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;color;</span><br><span class="line">add(u,v,color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dij()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="F-zh吃饭"><a href="#F-zh吃饭" class="headerlink" title="F -     zh吃饭"></a>F -     zh吃饭</h5><blockquote><p>给出一个有向图，求经过每个边权后到达某个点集内的点总的最大的边权和</p></blockquote><p><code>tarjan</code> <code>缩点</code><br>tarjan求强连通分量直接缩点重新建图跑最长路，找了以前写的缩点的代码直接粘上来<del>嘿嘿嘿</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,tmp,s,p;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,sum = <span class="number">0</span>,top = <span class="number">0</span>,dfn[maxn],low[maxn],instack[maxn],q[maxn],fa[maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G,G2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn],edges2[maxn],all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">G2.push_back(Edge(u,v));</span><br><span class="line">edges2[u].push_back(G2.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">top ++;</span><br><span class="line">dfn[x] = low[x] = cnt;</span><br><span class="line">q[top] = x;</span><br><span class="line">instack[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> len = edges[x].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[x][i]].to;</span><br><span class="line"><span class="keyword">if</span>(dfn[v] == <span class="number">0</span>)&#123;</span><br><span class="line">tarjan(v);</span><br><span class="line">low[x] = min(low[x],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) low[x] = min(low[x],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x])&#123;</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">while</span>(q[top + <span class="number">1</span>] != x)&#123;</span><br><span class="line"><span class="keyword">int</span> s = q[top];</span><br><span class="line">top--;</span><br><span class="line">instack[s] = <span class="number">0</span>;</span><br><span class="line">fa[s] = sum;</span><br><span class="line">dis[sum] += w[s];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(fa[s]);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">mst(dist,<span class="number">0</span>);</span><br><span class="line">dist[fa[s]] = dis[fa[s]];</span><br><span class="line">vis[fa[s]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now = q.front();</span><br><span class="line"><span class="keyword">int</span> len = edges2[now].size();</span><br><span class="line">q.pop();</span><br><span class="line">vis[now] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G2[edges2[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(dist[v] &lt; dist[now] + dis[v])&#123;</span><br><span class="line">dist[v] = dist[now] + dis[v];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">Addedge(u,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= p;i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">    all.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    u = G[i].from;</span><br><span class="line">    v = G[i].to;</span><br><span class="line">    <span class="keyword">if</span>(fa[u] != fa[v]) Addedge2(fa[u],fa[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p;i++) ans = max(ans,dist[fa[all[i]]]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="G-hqf吹泡泡"><a href="#G-hqf吹泡泡" class="headerlink" title="G - hqf吹泡泡"></a>G - hqf吹泡泡</h5><blockquote><p>给定$ n $个点，有$ m $ 种连接关系，表示$ u $、$ v $两个点连接所需要的代价是$ w $，要求最少的将所有点连接成$ k $块所需要的代价</p></blockquote><p><code>最小生成树</code><br>本来能1A的一个题结果手太抖了错失一血。。<br>直接用最小生成树的算法，每连接一次就减去当前块数的数量，然后减到k的时候结束输出答案<br>时间复杂度$ O(nlogn) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ll n,m,k,tt = <span class="number">0</span>;</span><br><span class="line">ll cnt;</span><br><span class="line"><span class="keyword">int</span> fa[maxn],siz[maxn],vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; all;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tfind</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? fa[x] : (fa[x] = tfind(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">cnt = n;</span><br><span class="line">mst(siz,<span class="number">0</span>);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">all.push_back(Edge(u,v,w));</span><br><span class="line">&#125;</span><br><span class="line">sort(all.begin(),all.end());</span><br><span class="line"><span class="keyword">int</span> len = all.size();</span><br><span class="line"><span class="keyword">while</span>(cnt != k &amp;&amp; tt &lt; len)&#123;</span><br><span class="line">Edge now = all[tt];</span><br><span class="line">tt++;</span><br><span class="line"><span class="keyword">int</span> a = tfind(now.from),b = tfind(now.to);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(siz[a] &gt;= siz[b])&#123;</span><br><span class="line">siz[a] += siz[b];</span><br><span class="line">ans += now.dist;</span><br><span class="line">fa[b] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">siz[b] += siz[a];</span><br><span class="line">ans += now.dist;</span><br><span class="line">fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line">cnt --;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="H-毁灭东湖计划"><a href="#H-毁灭东湖计划" class="headerlink" title="H - 毁灭东湖计划"></a>H - 毁灭东湖计划</h5><blockquote><p>给定一个有向图，求出从1到n的最大流量</p></blockquote><p><code>网络瘤</code><br>网络瘤板题，抄了紫书的EK板子(逃<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line">ll a[maxn],p[maxn],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll cap)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,cap,<span class="number">0</span>));</span><br><span class="line">G.push_back(Edge(v,u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">mst(a,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line">a[s] = INF;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">Edge&amp; e = G[edges[now][i]];</span><br><span class="line"><span class="keyword">if</span>(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123;</span><br><span class="line">p[e.to] = edges[now][i];</span><br><span class="line">a[e.to] = min(a[now], e.cap - e.flow);</span><br><span class="line">q.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[t]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!a[t]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = G[p[u]].from)&#123;</span><br><span class="line">G[p[u]].flow += a[t];</span><br><span class="line">G[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line">res += a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v,n,m;</span><br><span class="line">ll c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;c;</span><br><span class="line">Addedge(u,v,c);</span><br><span class="line">&#125;</span><br><span class="line">ans = Maxflow(<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="I-cxx仙女下凡"><a href="#I-cxx仙女下凡" class="headerlink" title="I -  cxx仙女下凡"></a>I -  cxx仙女下凡</h5><blockquote><p>给出一个有向图，求出其中从$ s $到$ t $第$ k $短的路径长度</p></blockquote><p><code>k短路</code> <code>A*</code><br>k短路模板题，先spfa求出其他点到t最短的路径长度，用A*的估价函数进行估值然后拓展，第k次经过的时候就是第k短路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> pos,d,f;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f == a.f) <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line"><span class="keyword">return</span> f &gt; a.f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,s,t;</span><br><span class="line">ll dist[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G,G2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn],edges2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,w));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">G2.push_back(Edge(v,u,w));</span><br><span class="line">edges2[v].push_back(G2.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">q.push(start);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">vis[start] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dist[i] = INF;</span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> now = q.front(),len = edges2[now].size();</span><br><span class="line">    q.pop();</span><br><span class="line">    vis[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> v = G2[edges2[now][i]].to;</span><br><span class="line">    <span class="keyword">if</span>(dist[v] &gt; dist[now] + G2[edges2[now][i]].dist)&#123;</span><br><span class="line">    dist[v] = dist[now] + G2[edges2[now][i]].dist;</span><br><span class="line">    <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">    vis[v] = <span class="number">1</span>;</span><br><span class="line">    q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Get_k</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[s] == INF) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node now,nxt;</span><br><span class="line">now.pos = s;</span><br><span class="line">now.d = <span class="number">0</span>;</span><br><span class="line">now.f = dist[s];</span><br><span class="line">q.push(now);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">now = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(now.pos == t) cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> now.d;</span><br><span class="line"><span class="keyword">int</span> len = edges[now.pos].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now.pos][i]].to;</span><br><span class="line">nxt.d = now.d + G[edges[now.pos][i]].dist;</span><br><span class="line">nxt.f = nxt.d + dist[v];</span><br><span class="line">nxt.pos = v;</span><br><span class="line">q.push(nxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line">ll d;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;d;</span><br><span class="line">AddEdge(u,v,d);</span><br><span class="line">&#125;</span><br><span class="line">spfa(t);</span><br><span class="line">ll ans = Get_k();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="J-cxx守株待兔"><a href="#J-cxx守株待兔" class="headerlink" title="J - cxx守株待兔"></a>J - cxx守株待兔</h5><blockquote><p>给出一个二分图，求最大匹配</p></blockquote><p><code>匈牙利</code> <code>网络瘤</code><br>把二分图的两边加一个超级源点和一个超级汇点，然后跑一下网络流（<br>一开始以为EK会被卡就套了Dinic的板子，结果试了一下EK也可以过。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> n,s,t,cap;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],cur[maxn];</span><br><span class="line">ll a[maxn],p[maxn],ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l,r,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll cap)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,cap,<span class="number">0</span>));</span><br><span class="line">G.push_back(Edge(v,u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line">vis[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">Edge &amp;e = G[edges[now][i]];</span><br><span class="line"><span class="keyword">if</span>(!vis[e.to]&amp;&amp;e.cap &gt; e.flow)&#123;</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">d[e.to] = d[now] + <span class="number">1</span>;</span><br><span class="line">q.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,ll a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">ll flow = <span class="number">0</span>,f;</span><br><span class="line"><span class="keyword">int</span> len = edges[x].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = cur[x];i &lt;len;i++)&#123;</span><br><span class="line">Edge &amp;e = G[edges[x][i]];</span><br><span class="line"><span class="keyword">if</span>(d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = dfs(e.to,min(a,e.cap - e.flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">e.flow += f;</span><br><span class="line">G[edges[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">flow += f;</span><br><span class="line">a -= f;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">mst(cur,<span class="number">0</span>);</span><br><span class="line">flow += dfs(s,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;m;</span><br><span class="line">s = <span class="number">0</span>,t = l + r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= l;i++) Addedge(s,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>;i &lt;= l + r;i++) Addedge(i,t,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">Addedge(u,v + l,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Maxflow()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="K-cxx承包鱼塘"><a href="#K-cxx承包鱼塘" class="headerlink" title="K - cxx承包鱼塘"></a>K - cxx承包鱼塘</h5><blockquote><p>给出一个带权无向图，求出最多免费k条边后$ s $到$ t $的最短距离</p></blockquote><p> <code>分层图</code> <code>DP</code><br> 在<code>dijkstra</code>里面加一个免费这条边的情况下的最短距离，然后类似于动态规划搞一下<br> 时间复杂度$ O((m + n)logn) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,k,s,t;</span><br><span class="line"><span class="keyword">int</span> from,to,dis;</span><br><span class="line">ll dist[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addegde</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,d));</span><br><span class="line">G.push_back(Edge(v,u,d));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(dist,<span class="number">0x3f3f3f</span>);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">dist[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.push(node(s,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">node now = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[now.u][now.t]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.u][now.t] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> len = edges[now.u].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now.u][i]].to;</span><br><span class="line"><span class="keyword">if</span>(dist[v][now.t] &gt; dist[now.u][now.t] + G[edges[now.u][i]].dist)&#123;</span><br><span class="line">dist[v][now.t] = dist[now.u][now.t] + G[edges[now.u][i]].dist;</span><br><span class="line">q.push(node(v,now.t,dist[v][now.t]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now.t + <span class="number">1</span> &lt;= k)&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[v][now.t + <span class="number">1</span>] &gt; dist[now.u][now.t])&#123;</span><br><span class="line">dist[v][now.t + <span class="number">1</span>] = dist[now.u][now.t];</span><br><span class="line">q.push(node(v,now.t + <span class="number">1</span>,dist[v][now.t + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;from&gt;&gt;to&gt;&gt;dis;</span><br><span class="line">Addegde(from,to,dis);</span><br><span class="line">&#125;</span><br><span class="line">dij();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dist[t][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="L-cxx的压岁钱"><a href="#L-cxx的压岁钱" class="headerlink" title="L - cxx的压岁钱"></a>L - cxx的压岁钱</h5><blockquote><p>给定n个电视所需要花费的代价，以及选取某几个电视就可以得到的利润，求出最大的利润</p></blockquote><p><code>最大权闭合子图</code> <code>网络流</code><br>抽象一下，就是选取某一个结点，那么它的后继也要被选取<br>看到题目的时候满脸网络流，但是不知道建模是怎么建的emmm<br>建模的就是将选取的后继的这一边的容量设为无穷大，源点连接的所需要选取的容量为对应利润，后面汇点连接的容量为对应的代价<br>跑出最大流，然后用$ \sum c$减去最大流<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,cap;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],cur[maxn];</span><br><span class="line">ll a[maxn],p[maxn],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll cap)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,cap,<span class="number">0</span>));</span><br><span class="line">G.push_back(Edge(v,u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line">vis[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">Edge &amp;e = G[edges[now][i]];</span><br><span class="line"><span class="keyword">if</span>(!vis[e.to]&amp;&amp;e.cap &gt; e.flow)&#123;</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">d[e.to] = d[now] + <span class="number">1</span>;</span><br><span class="line">q.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,ll a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">ll flow = <span class="number">0</span>,f;</span><br><span class="line"><span class="keyword">int</span> len = edges[x].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = cur[x];i &lt;len;i++)&#123;</span><br><span class="line">Edge &amp;e = G[edges[x][i]];</span><br><span class="line"><span class="keyword">if</span>(d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = dfs(e.to,min(a,e.cap - e.flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">e.flow += f;</span><br><span class="line">G[edges[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">flow += f;</span><br><span class="line">a -= f;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">mst(cur,<span class="number">0</span>);</span><br><span class="line">flow += dfs(s,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">t = m + n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;cap;</span><br><span class="line">Addedge(n + i,t,cap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a,k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;k;</span><br><span class="line">sum += a;</span><br><span class="line">Addedge(s,i,a);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;v;</span><br><span class="line">Addedge(i,v + n,INF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum - Maxflow()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="M-洁姐姐带我找工作"><a href="#M-洁姐姐带我找工作" class="headerlink" title="M - 洁姐姐带我找工作"></a>M - 洁姐姐带我找工作</h5><blockquote><p>给出每两个公司的给出的offer数量关系，求出最少的offer数</p></blockquote><p><code>dfs</code> <code>并查集</code> <code>拓扑排序</code></p><p>既然是图论，一开始想到的是建一个有向图表示大于小于关系，但是等于关系想不清楚<br>当时晚上放题的时候还想到了差分约束emmmm<br>然后想到用并查集将等于的点缩在一个点上，但是排序对应点的权值的处理有点问题<br>后来想到的是<code>并查集</code> + <code>拓扑排序</code>，但是拓扑排序排不出来（我是辣鸡<br>那么把大于的建图反向过来，这样方便从1开始处理权值，然后每次选取入度为0的点开始dfs<br>求出每个点对应的深度就是权值，然后每次递归到某一层如果权值已经不为0了就选择最大的一个深度作为权值<br>最后把权值全部加起来就是答案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[<span class="number">1007</span>],siz[<span class="number">1007</span>],in[<span class="number">1007</span>],vis[<span class="number">1007</span>],w[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,op,u,v,ans = <span class="number">0</span>,maxx = <span class="number">1</span>,flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G,G1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[<span class="number">1007</span>],all;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tfind</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? x : (fa[x] = tfind(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">G1.push_back(Edge(u,v));</span><br><span class="line">edges[u].push_back(G1.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = edges[x].size();</span><br><span class="line">w[x] = max(w[x],dep + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G1[edges[x][i]].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line">dfs(v,dep + <span class="number">1</span>);</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">mst(in,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i,siz[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>) G.push_back(Edge(u,v));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) G.push_back(Edge(v,u));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> a = tfind(u),b = tfind(v);</span><br><span class="line">fa[b] = a;</span><br><span class="line">siz[a] += siz[b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = G.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u = G[i].from,v = G[i].to;</span><br><span class="line">u = tfind(u),v = tfind(v);</span><br><span class="line"><span class="keyword">if</span>(u == v)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">in[u] ++;</span><br><span class="line">addedge(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(w[tfind(i)] == <span class="number">0</span> &amp;&amp; in[tfind(i)] == <span class="number">0</span>) dfs(tfind(i),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ans += w[tfind(i)];</span><br><span class="line"><span class="keyword">if</span>(w[tfind(i)] == <span class="number">0</span>) flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="N-洁姐姐带我上分"><a href="#N-洁姐姐带我上分" class="headerlink" title="N -     洁姐姐带我上分"></a>N -     洁姐姐带我上分</h5><blockquote><p>jjjj一次能带$ k $个人上段位，每次jjjj不在的情况下每队cp都不能在一起，jjjj可以随意地上段位或者下段位，求出最少的让所有人都到高段位的代价</p></blockquote><p><code>DAG</code> <code>DP</code> <code>状态压缩</code><br><del>这题也是康题解做的</del><br>用二进制整数表示当前某个段位的状态，然后筛出合法的数据，按照条件得到合法转移条件连边<br>最后跑一遍最短路。。</p><blockquote><p>合法状态：末位为0的同时不能有一对cp的位置同时为1<br>合法转移：1的个数少于等于$ k $ 、状态转移的变量末位是1、同时两个转移状态之间的最大值减去状态变化值是两个转移状态的最小值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,d;</span><br><span class="line">Node(<span class="keyword">int</span> uu,<span class="keyword">int</span> dd):u(uu),d(dd)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,maxx;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; all;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; statu;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dist)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(from,to,dist));</span><br><span class="line">G.push_back(Edge(to,from,dist));</span><br><span class="line">edges[from].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[to].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now_ = maxx - now,len = all.size();</span><br><span class="line"><span class="keyword">bool</span> flag1 = <span class="number">0</span>,flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((now &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((now &gt;&gt; all[i].x) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((now &gt;&gt; all[i].y) &amp; <span class="number">1</span> == <span class="number">1</span>)) flag1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((now_ &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((now_ &gt;&gt; all[i].x) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((now_ &gt;&gt; all[i].y) &amp; <span class="number">1</span>) == <span class="number">1</span>) flag2 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag1 == <span class="number">1</span> || flag2 == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(x &amp; <span class="number">1</span>) res ++;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dist[maxx];</span><br><span class="line"><span class="keyword">bool</span> vis[maxx];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= maxx;i++) dist[i] = INF;</span><br><span class="line">dist[maxx] = <span class="number">0</span>;</span><br><span class="line">    q.push(Node(maxx,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    Node now = q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">int</span> u = now.u;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = edges[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    Edge &amp;e = G[edges[u][i]];</span><br><span class="line">    <span class="keyword">if</span>(dist[e.to] &gt; dist[u] + e.dist)&#123;</span><br><span class="line">    dist[e.to] = dist[u] + e.dist;</span><br><span class="line">    q.push(Node(e.to,dist[e.to]));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tmp.x&gt;&gt;tmp.y;</span><br><span class="line">all.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line">maxx = (<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= maxx;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(check(i)) statu.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = statu.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> det = statu[i] ^ statu[j];</span><br><span class="line"><span class="keyword">int</span> cnt = get(det);</span><br><span class="line"><span class="keyword">if</span>(max(statu[i],statu[j]) - det == min(statu[i],statu[j]) &amp;&amp; cnt &lt;= k &amp;&amp; det &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">Addedge(statu[i],statu[j],cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = dij();</span><br><span class="line"><span class="keyword">if</span>(ans == INF) <span class="built_in">cout</span>&lt;&lt;<span class="string">"mole"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="O-洁姐姐带学画画"><a href="#O-洁姐姐带学画画" class="headerlink" title="O - 洁姐姐带学画画"></a>O - 洁姐姐带学画画</h5><blockquote><p>给出n个点，已经它们在三维空间中的坐标，求出生成树，并且每条线段的连接的两个点的高度差之和比上水平距离之和最小</p></blockquote><p><code>最小生成树</code> <code>prim</code> <code>牛顿迭代</code> <code>01分数规划</code><br>用一个表达式表示一个最小生成树，权值总和为</p><script type="math/tex; mode=display">x_1a_1 + x_2a_2 + ... +x_na_n</script><p>$x_i$表示选取或者不选取<br>令得到的答案为$ans$<br>那么有</p><script type="math/tex; mode=display">\frac {\sum x_ih_i}{\sum x_id_i} >= ans \\移项，有 \sum x_ih_i >= ans\sum x_id_i \\展开，x_1(h_1 - ans*d_1) + x_2(h_1 - ans * d_2) + ... + x_n(h_n - ans*d_n) >= 0</script><p>可以进行二分判断得到的ans是否使得最小生成树为0即可，<br>除了使用二分，还可以使用牛顿迭代法更新答案直到$x &gt;= xx$，也就对应二分上面式子为0的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node nodes[maxn];</span><br><span class="line"><span class="keyword">double</span> cost[maxn][maxn],len[maxn][maxn];</span><br><span class="line"><span class="keyword">double</span> M[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">cost[i][j] = cost[j][i] = <span class="built_in">fabs</span>(nodes[i].z - nodes[j].z);</span><br><span class="line">len[i][j] = len[j][i] = dis(nodes[i],nodes[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> low[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i++)&#123;</span><br><span class="line">vis[i] = <span class="number">0</span>;</span><br><span class="line">low[i] = M[<span class="number">0</span>][i];</span><br><span class="line">pre[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> sumcost = <span class="number">0</span>,sumlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> min = INF;</span><br><span class="line"><span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; min &gt; low[j])&#123;</span><br><span class="line">nxt = j;</span><br><span class="line">min = low[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[nxt] = <span class="number">1</span>;</span><br><span class="line">sumcost += cost[pre[nxt]][nxt];</span><br><span class="line">sumlen += len[pre[nxt]][nxt];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; low[j] &gt; M[nxt][j])&#123;</span><br><span class="line">low[j] = M[nxt][j];</span><br><span class="line">pre[j] = nxt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sumcost / sumlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mapp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">M[i][j] = M[j][i] = cost[i][j] - x * len[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;nodes[i].x&gt;&gt;nodes[i].y&gt;&gt;nodes[i].z;</span><br><span class="line">&#125;</span><br><span class="line">get();</span><br><span class="line"><span class="keyword">double</span> sumc = <span class="number">0</span>,suml = <span class="number">0</span>,xx;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) sumc += cost[<span class="number">0</span>][i],suml += len[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">double</span> x = sumc / suml;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    xx = x;</span><br><span class="line">    Mapp(xx);</span><br><span class="line">    x = prime();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(xx - x) &lt; eps) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;A-迷宫&quot;&gt;&lt;a href=&quot;#A-迷宫&quot; class=&quot;headerlink&quot; title=&quot;A - 迷宫&quot;&gt;&lt;/a&gt;A - 迷宫&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;给出一个带权有向图，翻转一条边的代价是其权重，求出翻转边后图中无环的最小代价&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="UESTC" scheme="http://decision01.cn/categories/UESTC/"/>
    
      <category term="ACM" scheme="http://decision01.cn/categories/UESTC/ACM/"/>
    
    
      <category term="ACM" scheme="http://decision01.cn/tags/ACM/"/>
    
      <category term="图论" scheme="http://decision01.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>UESTC暑假前集训-动态规划-解题报告</title>
    <link href="http://decision01.cn/2019/05/24/UESTC%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://decision01.cn/2019/05/24/UESTC暑期前集训-动态规划/</id>
    <published>2019-05-24T14:35:27.000Z</published>
    <updated>2019-06-02T13:17:55.355Z</updated>
    
    <content type="html"><![CDATA[<h5 id="A-oy环游世界"><a href="#A-oy环游世界" class="headerlink" title="A - oy环游世界"></a>A - oy环游世界</h5><blockquote><p>A、给定n个点，求出从起点开始遍历到最后一个点的最短曼哈顿距离</p></blockquote><p><code>状态压缩</code><br>n最多有17个点，可以考虑将17个点压缩到一个int里面，这个时候可以考虑一个状态$f _ {S,i}$，表示遍历了集合S后以i为终点的路径的最短的距离，状态转移方程为:</p><script type="math/tex; mode=display">f_{S,j} = min(f_{S,j},f_{S_j,j  + dist(j,k)})</script><p>$S_j$表示集合$S$除去点$j$后的集合<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">ll x,y;</span><br><span class="line"></span><br><span class="line">ll <span class="keyword">operator</span> - (<span class="keyword">const</span> Point&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(x - a.x) + <span class="built_in">abs</span>(y - a.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;all[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">ll n,s;</span><br><span class="line">ll f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">mst(f,<span class="number">0x3f3f3f</span>);</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span>&gt;&gt;all[i].x&gt;&gt;all[i].y;</span><br><span class="line"><span class="keyword">if</span>(s - <span class="number">1</span> != <span class="number">0</span>) swap(all[<span class="number">0</span>],all[s - <span class="number">1</span>]);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++) f[<span class="number">1</span> &lt;&lt; i | <span class="number">1</span>][i] = all[<span class="number">0</span>] - all[i];</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt; (<span class="number">1</span> &lt;&lt; n);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))&#123;</span><br><span class="line">                <span class="keyword">for</span>(ll k = <span class="number">1</span>;k &lt; n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; k))&#123;</span><br><span class="line">                        f[i][j] = min(f[i][j],f[i ^ (<span class="number">1</span> &lt;&lt; j)][k] + (all[j] - all[k]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++) ans = min(ans,f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="B-挖矿攻略"><a href="#B-挖矿攻略" class="headerlink" title="B - 挖矿攻略"></a>B - 挖矿攻略</h5><blockquote><p>B、给定zh的n<em>m的一片矿地，对应位置上有不同数量的黑矿和红矿，现在我作为一个<em>*搬砖工</em></em>要帮zh修传送带让zhdg的收益最多，zhdg在北边和西边建了矿场，传送带要求直接通向矿场</p></blockquote><p><code>二维动态规划</code><br>因为每块地的传送带只能直接通向矿场，那么如果当前的传送带向上的话那么它上面一个也是向上的，而左的话它左边一个也是向左的，那么考虑用每行每列的前缀和进行转移，时间复杂度$O(nm)$</p><script type="math/tex; mode=display">f_{i,j} = max(f_{i -1,j} + sum1[i][j],f_{i,j - 1} + sum2[i][j])</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">501</span>][<span class="number">501</span>],b[<span class="number">501</span>][<span class="number">501</span>],f[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    mst(a,<span class="number">0</span>);</span><br><span class="line">    mst(b,<span class="number">0</span>);</span><br><span class="line">    mst(f,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">             <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">             a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">             <span class="built_in">cin</span>&gt;&gt;b[i][j];</span><br><span class="line">             b[i][j] += b[i - <span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">             f[i][j] = max(f[i - <span class="number">1</span>][j] + a[i][j],f[i][j - <span class="number">1</span>] + b[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-手办"><a href="#C-手办" class="headerlink" title="C - 手办"></a>C - 手办</h5><blockquote><p>C、给出一个长度为$ n $的序列，每个元素$a_i \in [114514,114521]$，要求从里面取出k个然后放回去使得连通块的数量最少</p></blockquote><p><code>玄学动规</code><br>问题可以转化为拿走k个手办再放回去的混乱度<br>用一个状态$f[i][j][k][l]$表示当前到第$ i $个，前面拿走了$ j $个，当前所有的手办的种类集合$k$，最后一个手办种类为$ l $的时候的混乱度<br>拿走某个手办的时候，如果当前这个手办和最后一个一样，那么</p><script type="math/tex; mode=display">f[i][j + 1][k][l] = f[i - 1][j][k][l]</script><p>否则直接拿走就是</p><script type="math/tex; mode=display">f[i][j + 1][k][l] = f[i - 1][j][k][l] + 1</script><p>不拿走的话，转移就是：</p><script type="math/tex; mode=display">f[i][j][k | h[i]][h[i]] = f[i - 1][j][k][l] + 1</script><p>时间复杂度$O(7*2^7nk)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,kk,h[<span class="number">300</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">101</span>][<span class="number">1</span> &lt;&lt; <span class="number">10</span>][<span class="number">10</span>],vis[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> siz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">siz = <span class="number">0</span>;</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=kk;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;(<span class="number">1</span> &lt;&lt; <span class="number">10</span>);k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; <span class="number">10</span>;l++)&#123;</span><br><span class="line">f[i][j][k][l] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;kk)&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; kk == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">h[i] -= <span class="number">114513</span>;</span><br><span class="line">vis[h[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">num ++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(h[j] == i) h[j] = num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">siz = (<span class="number">1</span> &lt;&lt; num) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= kk;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= siz;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt;= num;l++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][j][k][l] != INF)&#123;</span><br><span class="line">f[i + <span class="number">1</span>][j + <span class="number">1</span>][k][l] = min(f[i + <span class="number">1</span>][j + <span class="number">1</span>][k][l],f[i][j][k][l]);</span><br><span class="line">f[i + <span class="number">1</span>][j][k|(<span class="number">1</span> &lt;&lt; (h[i + <span class="number">1</span>] - <span class="number">1</span>))][h[i + <span class="number">1</span>]] = min(f[i + <span class="number">1</span>][j][k|(<span class="number">1</span> &lt;&lt; h[i + <span class="number">1</span>] - <span class="number">1</span>)][h[i + <span class="number">1</span>]],f[i][j][k][l] + (h[i + <span class="number">1</span>] == l ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= kk;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= siz;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= num;k++)&#123;</span><br><span class="line"><span class="keyword">int</span> numm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; num;l++)&#123;</span><br><span class="line"><span class="keyword">if</span>((j &amp; (<span class="number">1</span> &lt;&lt; l)) == <span class="number">0</span>) numm ++;</span><br><span class="line">&#125;</span><br><span class="line">ans = min(ans,f[n][i][j][k] + numm);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;cnt&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="D-序列"><a href="#D-序列" class="headerlink" title="D - 序列"></a>D - 序列</h5><blockquote><p>D、给出一个序列，要求输出序列中一个对称的先严格递增然后严格递减的最长的序列的长度</p></blockquote><p><code>LIS</code></p><p>两次LIS，然后依次以某个元素为中点的最长的序列长度比较得出答案<br>时间复杂度$ O(2nlogn + n) $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,ans = <span class="number">-1</span>,top1 = <span class="number">1</span>,top2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">1000007</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000007</span>],b[<span class="number">1000007</span>];</span><br><span class="line"><span class="keyword">int</span> f1[<span class="number">1000007</span>],f2[<span class="number">1000007</span>];</span><br><span class="line"><span class="keyword">int</span> s1[<span class="number">1000007</span>],s2[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">        a[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(A + <span class="number">1</span>,A + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) a[i] = b[n - i + <span class="number">1</span>] = lower_bound(A + <span class="number">1</span>,A + n + <span class="number">1</span>,a[i]) - A;</span><br><span class="line">    f1[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">    s1[top1++] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; s1[top1 - <span class="number">1</span>])&#123;</span><br><span class="line">            f1[i] = top1;</span><br><span class="line">            s1[top1++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(s1 + <span class="number">1</span>,s1 + top1,a[i]) - s1;</span><br><span class="line">            s1[pos] = a[i];</span><br><span class="line">            f1[i] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f2[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">    s2[top2++] = b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; s2[top2 - <span class="number">1</span>])&#123;</span><br><span class="line">            f2[i] = top2;</span><br><span class="line">            s2[top2++] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(s2 + <span class="number">1</span>,s2 + top2,b[i]) - s2;</span><br><span class="line">            s2[pos] = b[i];</span><br><span class="line">            f2[i] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans = max(ans,min(f1[i],f2[n - i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span> * ans - <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-神"><a href="#E-神" class="headerlink" title="E - 神"></a>E - 神</h5><blockquote><p>E、给定一个字符串$s$，要求将其分为长度为$k$的，$|s| / k$块后，对每块进行排序，然后输出最小的连通块的数量</p></blockquote><p><code>分块动规？</code><br>一开始以为和C题差不多，后来想了一下其实不一样。。<br>先预处理一下，将每块左边连$ i $,右边连$ j $的时候的最小的块数求出来，然后用$f_{i,j,k}$表示到第$ i $块，以字母$ j $开头，字母$ k $结尾的最小连通块数，那么可以得到转移方程</p><script type="math/tex; mode=display">f_{i,j,k} = min\{f_{i - 1,j,m} + cnt_{i - 1,m,k} - 1\}</script><p>这里$i,j,k,m$对应字母在字母表中的顺序<br>时间复杂度$O(26^3len + 26^2len/k)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T,k;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1007</span>][<span class="number">26</span>][<span class="number">26</span>],cnt[<span class="number">1007</span>][<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1007</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(f,<span class="number">0</span>);</span><br><span class="line">mst(cnt,<span class="number">0</span>);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(s) / k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l = i * k,r = (i + <span class="number">1</span>) * k;</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ccnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l;j &lt; r;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i + <span class="number">1</span>][s[j] - <span class="string">'a'</span>])&#123;</span><br><span class="line">ccnt++;</span><br><span class="line">vis[i + <span class="number">1</span>][s[j] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; <span class="number">26</span>;l++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j == l &amp;&amp; ccnt == <span class="number">1</span> &amp;&amp; vis[i + <span class="number">1</span>][j]) cnt[i + <span class="number">1</span>][j][l] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[i + <span class="number">1</span>][j] &amp;&amp; vis[i + <span class="number">1</span>][l] &amp;&amp; j != l) cnt[i + <span class="number">1</span>][j][l] = ccnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!vis[i + <span class="number">1</span>][j] &amp;&amp; !vis[i + <span class="number">1</span>][l]) cnt[i + <span class="number">1</span>][j][l] = ccnt + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> cnt[i + <span class="number">1</span>][j][l] = ccnt + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> cas = <span class="number">1</span>;cas &lt;= T;cas++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line">f[<span class="number">1</span>][i][j] = cnt[<span class="number">1</span>][i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; <span class="number">26</span>;l++)&#123;</span><br><span class="line">f[i][j][l] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m &lt; <span class="number">26</span>;m++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i - <span class="number">1</span>][j][m] + cnt[i][m][l] - <span class="number">1</span>&lt; f[i][j][l])&#123;</span><br><span class="line">f[i][j][l] = f[i - <span class="number">1</span>][j][m] + cnt[i][m][l] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line">ans = min(f[len][i][j],ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="F-苇名欧一郎"><a href="#F-苇名欧一郎" class="headerlink" title="F - 苇名欧一郎"></a>F - 苇名欧一郎</h5><blockquote><p>F、给出T组数据，每组数据给出一个数$n$，以及$n - 1$个01串，第一个01串表示在没有任何武器的情况下可以击杀的敌人，后面的$n$个01串表示击杀某个敌人后得到武器后可以击杀的敌人</p></blockquote><p><code>状态压缩</code><br>考虑将击杀了的人表示在一个集合里面，那么当前可以击杀的人就是将对应的01串用或运算放进来，查询后面某个没有击杀的敌人能不能被击杀，之后再向后面进行转移<br>异或运算的地方可以用$O(2^n - 1)$的时间进行预处理，放到集合里面会炸时间复杂度<br>用$f_S$表示击杀了$S$中的敌人的方案数，转移方程：</p><script type="math/tex; mode=display">f_S = \{f_S + f_{S_j},j\in S_1\}</script><p>$S_1$表示当前可以击杀的敌人的集合<br>时间复杂度$O( 2^n(n + 1))$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">ll T,n;</span><br><span class="line">ll f[<span class="number">1</span> &lt;&lt; <span class="number">17</span>],could[<span class="number">1</span> &lt;&lt; <span class="number">17</span>];</span><br><span class="line">ll pre = <span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ctoint</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">ll len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(ll i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) res = res * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> res *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inttoch</span><span class="params">(ll num)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">16</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll num)</span></span>&#123;</span><br><span class="line">ll res = pre;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(num &amp; (<span class="number">1</span> &lt;&lt; i))&#123;</span><br><span class="line">res |= a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(ll cas = <span class="number">1</span>;cas &lt;= T;cas ++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ss;</span><br><span class="line">pre = ctoint(ss);</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ss;</span><br><span class="line">a[i] = ctoint(ss);</span><br><span class="line">&#125;</span><br><span class="line">mst(f,<span class="number">0</span>);</span><br><span class="line">mst(could,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;i++) could[i] = get(i);</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(pre &amp; (<span class="number">1</span> &lt;&lt; i)) f[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))&#123;</span><br><span class="line">ll co = could[i ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line"><span class="keyword">if</span>(co &amp; (<span class="number">1</span> &lt;&lt; j)) f[i] += f[i ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;cas&lt;&lt;<span class="string">": "</span>&lt;&lt;f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="G-子串"><a href="#G-子串" class="headerlink" title="G - 子串"></a>G - 子串</h5><blockquote><p>G、给出长度为nn的数字串，请求出其中能被$k$整除的子串个数</p></blockquote><p><code>字符串动态规划</code><br>考虑用$f_{i,j}$表示前面i个数字所表示的数$mod \ k = j$的个数，转移方程：</p><script type="math/tex; mode=display">f_{i + 1,10j + a[i + 1] mod \ k} = f_{i + 1,10j + a[i + 1] mod \ k} + f_{i,j}</script><p>注意到第$i + 1$次的状态只需要第$i$次的状态进行转移，那么用一个二维的滚动数组就可以降低空间复杂度到$O(2k + n)$<br>时间复杂度$O(nk)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn],n,k;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    ll f[<span class="number">3</span>][k + <span class="number">1</span>];</span><br><span class="line">    mst(f,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)  a[i + <span class="number">1</span>] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">    f[<span class="number">1</span>][a[<span class="number">1</span>] % k]++;</span><br><span class="line">    ans += f[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        f[<span class="number">2</span>][a[i+<span class="number">1</span>]%k]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++)&#123;</span><br><span class="line">            f[<span class="number">2</span>][(j*<span class="number">10</span> + a[i + <span class="number">1</span>])%k] += f[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += f[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;k;j++) f[<span class="number">1</span>][j] = f[<span class="number">2</span>][j],f[<span class="number">2</span>][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="H-van游戏"><a href="#H-van游戏" class="headerlink" title="H - van游戏"></a>H - van游戏</h5><blockquote><p>H、给出一棵有向树，树的每个结点有一定的权值，两个人依次取权值，当前的人只能取上一个人取的结点的儿子的权值，eom希望游戏结束时自己权值大的情况下moe的权值小，moe则希望eom权值小的前提下自己权值大，两人都按照最优策略取，输出出游戏结束时两人所得权值是多少</p></blockquote><p><code>暴力</code> <code>dfs</code> <code>树上dp</code><br>用两个dfs进行求解，到每个人求解的时候先获取子树上的信息再进行决策，最后统计答案即可<br><del>辣鸡数据耗我罚时</del><br>时间复杂度$O(y),y = n$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,root,cnt[<span class="number">1000007</span>];</span><br><span class="line">ll f[<span class="number">1000007</span>][<span class="number">2</span>],w[<span class="number">1000007</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[<span class="number">1000006</span>];</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    G.push_back(Edge(u,v));</span><br><span class="line">    edges[u].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">    ll maxx = <span class="number">0</span>;</span><br><span class="line">    ll minn = INF;</span><br><span class="line">    <span class="keyword">int</span> len = edges[now].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[edges[now][i]].to;</span><br><span class="line">        dfs2(v);</span><br><span class="line">        <span class="keyword">if</span>(f[v][<span class="number">0</span>] &gt; maxx || (f[v][<span class="number">0</span>] == maxx &amp;&amp; f[v][<span class="number">1</span>] &lt; minn)) nxt = v,maxx = f[v][<span class="number">0</span>],minn = f[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[now][<span class="number">0</span>] = f[nxt][<span class="number">0</span>];</span><br><span class="line">    f[now][<span class="number">1</span>] = f[nxt][<span class="number">1</span>] + w[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">    ll minn = INF;</span><br><span class="line">    ll maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = edges[now].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[edges[now][i]].to;</span><br><span class="line">        dfs1(v);</span><br><span class="line">        <span class="keyword">if</span>(f[v][<span class="number">0</span>] &lt; minn || (f[v][<span class="number">0</span>] == minn &amp;&amp; f[v][<span class="number">1</span>] &gt; maxx)) nxt = v,minn = f[v][<span class="number">0</span>],maxx = f[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[now][<span class="number">0</span>] = f[nxt][<span class="number">0</span>] + w[now];</span><br><span class="line">    f[now][<span class="number">1</span>] = f[nxt][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    mst(f,<span class="number">0</span>);</span><br><span class="line">    mst(cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;name;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u,v,x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        addedge(u,v);</span><br><span class="line">        cnt[v] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">"eom"</span>) dfs2(root);</span><br><span class="line">    <span class="keyword">else</span> dfs1(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[root][<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;f[root][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="I-攻略妹纸"><a href="#I-攻略妹纸" class="headerlink" title="I - 攻略妹纸"></a>I - 攻略妹纸</h5><blockquote><p>I、给出oydy想攻略的$n$个妹子，oydy对每个妹子有一定的好感度$a_i$并且有自己的魅力值$k$，而每个妹子也对oydy有一定的初始好感度$ b_i $，要攻略一个妹子要求妹子对oydy的好感度到达一定的值$ c_i $并且oydy的魅力值达到$d_i$，现在oydy手里有$ m $单位的钱，求最大的能获得的愉悦值</p></blockquote><p><code>01背包</code><br>看了题解之后才写的。。对题目抽象后等价于有$ n $个物体，体积为$ w = (c - b)y $，价值为$ a_i $，选取前提是$ k &gt;= h = (d - k)x $，那么排序瞎搞一下。。<br>时间复杂度$ O(nw + nlogn) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ll n,m,k,x,y;</span><br><span class="line">ll a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oy</span> &#123;</span></span><br><span class="line">ll val,w,h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> oy&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h == a.h) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w == a.w) <span class="keyword">return</span> val &lt; a.val;</span><br><span class="line">            <span class="keyword">return</span> w &lt; a.w;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;all[maxn];</span><br><span class="line"></span><br><span class="line">ll f[maxn][maxn],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(f,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">all[i].val = a;</span><br><span class="line">all[i].w = (c - b) * y;</span><br><span class="line">all[i].h = (d - k) * x;</span><br><span class="line">    <span class="keyword">if</span>(all[i].w &lt; <span class="number">0</span>) all[i].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(all[i].h &lt; <span class="number">0</span>) all[i].h = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(all + <span class="number">1</span>,all + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">ll tm = m - all[i].h;</span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">0</span>;j &lt;= tm;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j &lt; all[i].w)  f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span> f[i][j] = max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - all[i].w] + all[i].val); </span><br><span class="line">ans = max(ans,f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="J-扫广场"><a href="#J-扫广场" class="headerlink" title="J - 扫广场"></a>J - 扫广场</h5><blockquote><p>J、给出一个01矩阵，要求使用最少的将1变成0的操作使得所有的0连通</p></blockquote><p><code>连通性dp</code><br>（写不来，待填坑）<br>放一个写得跟屎一样的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> up,low,len,las;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; statu;</span><br><span class="line"><span class="keyword">char</span> zh[<span class="number">250</span>][<span class="number">250</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100</span>][<span class="number">1000</span>],oy[<span class="number">250</span>];</span><br><span class="line"><span class="keyword">int</span> dirx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> diry[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>,t = a;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res *= t;</span><br><span class="line">t *= t;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">10</span>],vis[<span class="number">10</span>],tmp = <span class="number">0</span>;</span><br><span class="line">mst(s,<span class="number">0</span>);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;x;i++)&#123;</span><br><span class="line">s[i] = x % <span class="number">5</span>;</span><br><span class="line">x /= <span class="number">5</span>;</span><br><span class="line">l = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[s[i]])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = s[i] + <span class="number">1</span>;j &lt; <span class="number">5</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[s[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[i - <span class="number">1</span>] &gt; <span class="number">0</span>  &amp;&amp; i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">tmp = max(tmp,s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tmp;i++) <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; low;i++) s[i] = x % k,x /= k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low <span class="number">-1</span> ;i &gt;= <span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextStatu</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,count = <span class="number">0</span>,tmp = <span class="number">0</span>,t1 = v,t2 = u;</span><br><span class="line"><span class="keyword">int</span> s1[<span class="number">8</span>],s2[<span class="number">8</span>],link[<span class="number">8</span>],vis[<span class="number">8</span>],link2[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">mst(s1,<span class="number">0</span>);</span><br><span class="line">mst(s2,<span class="number">0</span>);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">mst(link,<span class="number">0</span>);</span><br><span class="line">mst(link2,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; low;i++)&#123;</span><br><span class="line">s1[i] = u % <span class="number">5</span>;</span><br><span class="line">s2[i] = v % <span class="number">2</span>;</span><br><span class="line">u /= <span class="number">5</span>;</span><br><span class="line">v /= <span class="number">2</span>;</span><br><span class="line">tmp = max(tmp,s1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(s2[i] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag) flag = <span class="number">1</span>,count++,s2[i] = count;</span><br><span class="line"><span class="keyword">else</span> s2[i] = count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) flag = <span class="number">0</span>;</span><br><span class="line">s2[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i] == <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">if</span>(link[s1[i]] == <span class="number">0</span>) link[s1[i]] = s2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tmp;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(link[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tmp &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s2[i] == <span class="number">0</span>) link2[s2[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(link2[s2[i]] == <span class="number">0</span> || (link2[s2[i]] &gt; s1[i] &amp;&amp; s1[i] != <span class="number">0</span>)) link2[s2[i]] = s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s2[i] == <span class="number">0</span> || vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(link2[s2[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = low - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) <span class="keyword">if</span>(!vis[j] &amp;&amp; link2[s2[j]] == <span class="number">0</span> &amp;&amp; s2[j] == s2[i]) s2[j] = count,vis[j] = <span class="number">1</span>;</span><br><span class="line">    count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(link2[s2[i]] != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = low - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) <span class="keyword">if</span>(!vis[j] &amp;&amp; link2[s2[j]] == link2[s2[i]]) s2[j] = count,vis[j] = <span class="number">1</span>;</span><br><span class="line">    count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) res = res*<span class="number">5</span> + s2[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">up = max(m,n),low = min(m,n);</span><br><span class="line">mst(f,<span class="number">0x3f3f</span>);</span><br><span class="line"><span class="keyword">int</span> pownum = quickpow(<span class="number">5</span>,low);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pownum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(check1(i)) statu.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;zh[i];</span><br><span class="line">&#125;</span><br><span class="line">mst(oy,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(n &gt;= m)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">oy[i] = oy[i] * <span class="number">2</span> + zh[i][j] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(zh[i][j] == <span class="string">'0'</span> &amp;&amp; i &gt; las) las = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">oy[j + <span class="number">1</span>] = oy[j + <span class="number">1</span>] * <span class="number">2</span> + zh[i][j] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(zh[i][j] == <span class="string">'0'</span> &amp;&amp; j + <span class="number">1</span> &gt; las) las = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1,tmp2,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">tmp1 = u % <span class="number">2</span>;</span><br><span class="line">tmp2 = v % <span class="number">2</span>;</span><br><span class="line">u /= <span class="number">2</span>;</span><br><span class="line">v /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(tmp1 == tmp2) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp1 == <span class="number">1</span> &amp;&amp; tmp2 == <span class="number">0</span>) res++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp1 == <span class="number">0</span> &amp;&amp; tmp2 == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(zh[i][j] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_flood</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">zh[x][y] = <span class="string">'2'</span>;</span><br><span class="line"><span class="keyword">int</span> nx,ny;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">nx = x + dirx[i];</span><br><span class="line">ny = y + diry[i];</span><br><span class="line"><span class="keyword">if</span>(nx &gt; n || nx &lt; <span class="number">1</span> || ny &gt;= m || ny &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(zh[nx][ny] == <span class="string">'0'</span>) dfs_flood(nx,ny);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("std.out","w",stdout);</span></span><br><span class="line">init();</span><br><span class="line">len = statu.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span> &lt;&lt; low);i++)&#123;</span><br><span class="line"><span class="keyword">int</span> nxt = get(oy[<span class="number">1</span>],i),now = NextStatu(<span class="number">0</span>,i);</span><br><span class="line"><span class="keyword">if</span>(nxt == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(statu.begin(), statu.end(),now) - statu.begin();</span><br><span class="line">        <span class="keyword">if</span>(statu[pos] != now) <span class="keyword">continue</span>;</span><br><span class="line">    f[<span class="number">1</span>][pos] = nxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= las;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; (<span class="number">1</span> &lt;&lt; low);k++)&#123;</span><br><span class="line"><span class="keyword">int</span> now = NextStatu(statu[j],k);</span><br><span class="line"><span class="keyword">if</span>(now != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> nxt = get(oy[i],k);</span><br><span class="line"><span class="keyword">if</span>(nxt == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(statu.begin(), statu.end(),now) - statu.begin();</span><br><span class="line"><span class="keyword">if</span>(statu[pos] != now) <span class="keyword">continue</span>;</span><br><span class="line">f[i][pos] = min(f[i][pos],f[i - <span class="number">1</span>][j] + nxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = statu[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; low;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(tmp % <span class="number">5</span> &gt; <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">tmp /= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">continue</span>; </span><br><span class="line">ans = min(ans,f[las][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(zh[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">dfs_flood(i,j);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(check_dfs()) ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="K-抽卡"><a href="#K-抽卡" class="headerlink" title="K - 抽卡"></a>K - 抽卡</h5><blockquote><p>K、给出n、m，以及直接抽中的概率x，和抽中一个特定碎片的概率y，抽取n次，输出在n次内可以抽中或者集齐碎片的概率</p></blockquote><p><code>矩阵快速幂</code></p><p><del>题面害人</del><br>好吧是我没认真读题，对于每次抽奖，直接抽中的概率是$ x $，而抽中某一个<strong>特定</strong>碎片的概率是$ y $，那么抽不中碎片也不能一发入魂的概率就是$z = 1 - x - m * y$<br>那么分两种情况考虑</p><blockquote><ul><li>不管碎片，直接抽中的概率</li><li>通过碎片抽齐的概率</li></ul></blockquote><p>首先看直接抽中的概率，因为用碎片凑齐的情况下一次抽中都算抽中，那么这个可以直接计算<br>假设到第$ i -  1$次一次抽中的概率为$ p $，那么显然第$ i $次一次抽中的概率就是$(1 - p) * x$,假设第$ i $次直接抽中的概率是$ f_ i$，那么有下面的关系</p><script type="math/tex; mode=display">f_i = x*(1 - f_{i - 1}) \\f_{i - 1} = x*(1 - f_{i - 2})</script><p>整理一下可以得到</p><script type="math/tex; mode=display">\left[\begin{matrix}f_n \\ f_{n - 1}\end{matrix}\right] = \left[\begin{matrix}2 - x & x - 1 \\ 1 & 0\end{matrix}\right] ^ {n -1}\left[\begin{matrix}f_{1} \\ f_{2}\end{matrix}\right]</script><p>然后是考虑通过凑齐碎片得到的概率，考虑前面$ i $次获得了$ j $块碎片，也就是令$f_{i,j}$表示前面$ i $次获得了$ j $块碎片，那么这个状态由前面$ i - 1 $次获得了$ j - 1 $块碎片和前面$ i - 1 $次获得了$ j $块碎片转移过来，对于前一次只获得$j$块不同碎片的情况下乘$ z + j <em> y$，表示这一次一块都没抽到以及抽到的是已经有的，而对于前一次获得了$ j  - 1 $块不同的碎片的情况下，要从剩下的里面选一块出来，那么就是要乘$ (m - j + 1) </em> y$，所以得到下面的关系</p><script type="math/tex; mode=display">f_{i,j} = f_{i - 1,j - 1} * (m - j + 1) * y + f_{i - 1,j} * (z + j * y)</script><p>于是可以得到转移矩阵</p><script type="math/tex; mode=display">\left[\begin{matrix}f_{n,0} \\ f_{n,1} \\ f_{n,2} \\ ... \\ f_{n,m} \end{matrix}\right] = \left[\begin{matrix}z &0  & 0 & 0 & 0 &  ... & 0 \\ 0 & my  & y + z & 0 & 0 & ... & 0 \\0 & 0 & (m - 1)y  & 2y+z & 0 & ...  & 0\\...& ...\ & ... & ... & ... & ...  & ...\\0 & 0& 0  & 0 & 0 & ...  & my + z\\\end{matrix}\right] ^ n\left[\begin{matrix}f_{0,0} \\ f_{0,1} \\ f_{0,2} \\ ... \\ f_{0,m}\end{matrix}\right]</script><p>然后使用写一个矩阵的struct再套上快速幂的板子，取$f_{n,m} + f_n$相加就是答案<br>时间复杂度$ O (m^3logn)$<br>需要特判一下n = 0的情况，不然会TLE<del>毒瘤出题人出来挨打</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">ll num[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> w,h;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">matrix res;</span><br><span class="line">mst(res.num,<span class="number">0</span>);</span><br><span class="line">res.h = h;</span><br><span class="line">res.w = a.w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= h;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= a.w;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= w;k++)&#123;</span><br><span class="line">res.num[i][j] = (res.num[i][j] + num[i][k] * a.num[k][j] + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> hh,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">h = hh;</span><br><span class="line">w = ww;</span><br><span class="line">mst(num,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= h;i++) num[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">MatrixQuickMod</span><span class="params">(matrix a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">matrix t = a,res;</span><br><span class="line">res.init(a.h,a.w);</span><br><span class="line"><span class="keyword">if</span>(b &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * t;</span><br><span class="line">t = t * t;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line"><span class="keyword">double</span> tmpx,tmpy;</span><br><span class="line">ll x,y,z,Ans;</span><br><span class="line">matrix ans,res,dp,f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">x = <span class="number">1000</span> * (tmpx + <span class="number">1e-6</span>);</span><br><span class="line">y = <span class="number">1000</span> * (tmpy + <span class="number">1e-6</span>);</span><br><span class="line">z = <span class="number">1000</span> - x - m * y;</span><br><span class="line">ans.init(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">res.init(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">dp.init(m + <span class="number">1</span>,m + <span class="number">1</span>);</span><br><span class="line">f.init(m + <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">ans.num[<span class="number">1</span>][<span class="number">1</span>] = (ll)(<span class="number">1000.00</span> * tmpx);</span><br><span class="line">ans.num[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">res.num[<span class="number">1</span>][<span class="number">1</span>] = (ll)(<span class="number">1000.00</span> * (<span class="number">2.00</span> - tmpx + <span class="number">1e-6</span>));</span><br><span class="line">res.num[<span class="number">1</span>][<span class="number">2</span>] = (ll)(<span class="number">-1000.00</span> * (<span class="number">1.00</span> - tmpx+ <span class="number">1e-6</span>));</span><br><span class="line">res.num[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1000</span>;</span><br><span class="line">res.num[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">res = MatrixQuickMod(res,n - <span class="number">1</span>);</span><br><span class="line">dp.num[<span class="number">1</span>][<span class="number">1</span>] = z;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m + <span class="number">1</span>;i++)&#123;</span><br><span class="line">dp.num[i][i - <span class="number">1</span>] = (m - i + <span class="number">2</span>) * y;</span><br><span class="line">dp.num[i][i] = ((i - <span class="number">1</span>) * y + z);</span><br><span class="line">&#125;</span><br><span class="line">dp = MatrixQuickMod(dp,n);</span><br><span class="line">f.num[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">f = dp * f;</span><br><span class="line">ans = res * ans; </span><br><span class="line">Ans = (ans.num[<span class="number">1</span>][<span class="number">1</span>] + f.num[m + <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("std.in","r",stdin);</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;tmpx&gt;&gt;tmpy;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; m == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(ll)(tmpx * <span class="number">1000</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//std::cout&lt;&lt;(double)clock() / CLOCKS_PER_SEC &lt;&lt;"s"&lt;&lt;std::endl;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="L-zh的奖杯"><a href="#L-zh的奖杯" class="headerlink" title="L - zh的奖杯"></a>L - zh的奖杯</h5><blockquote><p>L、给出zhh的$n$个🏆，但是<strong>zhh大爷</strong>太忙了，让我帮他把🏆用一堆箱子装起来，每两个🏆之间要放入单位体积的棉花，而且<strong>家里有矿</strong>的zhh大爷要箱子花费的代价最小，每个箱子的代价为$(x - l)^2$，$l$是一个常数，$x$是装入某个箱子的🏆总体积</p></blockquote><p><code>斜率优化</code><br><del>一开始我以为是个贪心</del><br>首先得到状态转移方程为:</p><script type="math/tex; mode=display">f_i = min\{ f_j +( \sum_{k = j + 1} ^ i v_k + i - j - 1 - l) ^ 2 \}</script><p>表示的是装前面 i 件的最小花费 ，这里可以令：</p><script type="math/tex; mode=display">g(x) = sum(x) + x \\f_i = min\{f_j + (g(i) - g(j) - 1 - l)^2\}</script><p>假设$ 1 &lt;= j_1 &lt; j_2 &lt; i $，并且$ j _2$ 的决策更优，就得到:</p><script type="math/tex; mode=display">f_{j_1} + (g(i) - g(j_1) - 1 - l)^2 >= f_{j_2} + (g(i) - g(j_2) - 1 - l)^2</script><p>化简有：</p><script type="math/tex; mode=display">2g(i) >= \frac {f_{j_2} + (g(j_2) + l + 1) ^2 - (f_{j_1} + (g(j_1) + l + 1) ^2) }{g(j_2) - g(j_1)}\\令h(x) = (g(j_1) + l + 1) ^2 \\得2g(i) >= \frac {f_{j_2} + h(j_2) - (f_{j_1} + h(j1)) }{g(j_2) - g(j_1)}</script><p>那么对于两个决策$j_1、j_2$，满足上面的式子的时候$j_2$是最优的，而$g(i)$是单调递增的，要保证斜率也是单调递增的<br>使用单调队列进行维护，时间复杂度$O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ll n,L;</span><br><span class="line">ull f[<span class="number">500007</span>];</span><br><span class="line">ll x[<span class="number">500007</span>],y[<span class="number">500007</span>],q[<span class="number">500007</span>],sum[<span class="number">500007</span>],v[<span class="number">500007</span>];</span><br><span class="line">ll l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">x2</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * ((f[i] + x2(y[i])) - (f[j] + x2(y[j]))) / (y[i] - y[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;L;</span><br><span class="line">    x[<span class="number">0</span>] = <span class="number">0</span>,y[<span class="number">0</span>] = L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + v[i];</span><br><span class="line">        x[i] = sum[i] + i;</span><br><span class="line">        y[i] = sum[i] + i + L + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = q[++r] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; slope(q[l],q[l + <span class="number">1</span>]) &lt;= <span class="number">2</span> * x[i]) l++;</span><br><span class="line"></span><br><span class="line">        f[i] = f[q[l]] + x2(x[i] - y[q[l]]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;f[q[l]]&lt;&lt;<span class="string">" "</span>&lt;&lt;x2(x[i] - y[q[l]])&lt;&lt;<span class="string">" "</span>&lt;&lt;f[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; slope(q[r - <span class="number">1</span>],q[r]) &gt;= slope(q[r],i)) r--;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="M-崭新龙狙，制霸全区"><a href="#M-崭新龙狙，制霸全区" class="headerlink" title="M - 崭新龙狙，制霸全区"></a>M - 崭新龙狙，制霸全区</h5><blockquote><p>M、求给出的两个数$L、R$之间的数中出现的连续4750的个数之和</p></blockquote><p><code>数位dp</code><br>看到数据范围一眼数位dp，但是我想出来状态QAQ<br>后面写的时候函数里直接把string传了进去导致lutece爆空间，我是辣鸡<br><del>我写了，一发mle了，有什么好说的</del><br><del>连xyy都看不下去了</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> num1,num2;</span><br><span class="line"><span class="keyword">char</span> tmp[maxn];</span><br><span class="line"><span class="keyword">int</span> pp[] = &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len1,len2;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">6</span>],pre[maxn],PRE[maxn];</span><br><span class="line"><span class="keyword">int</span> ans1,ans2,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickmod</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>,t = a;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (res * t) % zh;</span><br><span class="line">t = (t * t) % zh;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num1&gt;&gt;num2;</span><br><span class="line"><span class="keyword">int</span> len = num1.length();</span><br><span class="line">reverse(num1.begin(),num1.end());</span><br><span class="line">num1[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; num1[<span class="number">0</span>] == <span class="string">'0'</span> - <span class="number">1</span>) num1[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len ;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1[i] - <span class="string">'0'</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    num1[i] += <span class="number">10</span>;</span><br><span class="line">    num1[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     reverse(num1.begin(),num1.end());</span><br><span class="line">&#125;</span><br><span class="line">len1 = num1.length();</span><br><span class="line">len2 = num2.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">charinit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line">pre[len] = <span class="number">1</span>;</span><br><span class="line">PRE[len - <span class="number">1</span>] = s[len - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">pre[i] = (pre[i + <span class="number">1</span>] * <span class="number">10</span>) % zh;</span><br><span class="line">PRE[i - <span class="number">1</span>] = (PRE[i] + (s[i - <span class="number">1</span>] - <span class="string">'0'</span>) * quickmod(<span class="number">10</span>,len - i)) % zh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) PRE[i]++,PRE[i] %= zh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> lim,<span class="keyword">int</span> l,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u &gt;= l)  <span class="keyword">return</span> v == <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(!lim &amp;&amp; f[u][v] != <span class="number">-1</span>) <span class="keyword">return</span> f[u][v];</span><br><span class="line"><span class="keyword">int</span> res = v == <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> V = v;</span><br><span class="line">v = v == <span class="number">4</span> ? <span class="number">0</span> : v;</span><br><span class="line"><span class="keyword">if</span>(!lim) res = (res * pre[u]) % zh;</span><br><span class="line"><span class="keyword">else</span> res = (res * PRE[u]) % zh;</span><br><span class="line"><span class="keyword">int</span> upp = lim ? s[u] - <span class="string">'0'</span> : <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= upp;i++)&#123;</span><br><span class="line">tmp[u] = <span class="string">'0'</span> + i;</span><br><span class="line"><span class="keyword">if</span>(pp[v + <span class="number">1</span>] == i)&#123;</span><br><span class="line">res = (res + dfs(u + <span class="number">1</span>,v + <span class="number">1</span>,i == upp &amp;&amp; lim,l,s)) % zh;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">4</span>) res = (res + dfs(u + <span class="number">1</span>,<span class="number">1</span>,i == upp &amp;&amp; lim,l,s)) % zh;</span><br><span class="line"><span class="keyword">else</span> res = (res + dfs(u + <span class="number">1</span>,<span class="number">0</span>,i == upp &amp;&amp; lim,l,s)) % zh;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!lim) f[u][V] = res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line">charinit(num1);</span><br><span class="line">mst(f,<span class="number">-1</span>);</span><br><span class="line">ans1 = dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,len1,num1);</span><br><span class="line">charinit(num2);</span><br><span class="line">mst(f,<span class="number">-1</span>);</span><br><span class="line">ans2 = dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,len2,num2);</span><br><span class="line">ans = (ans2 - ans1 + zh) % zh;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;A-oy环游世界&quot;&gt;&lt;a href=&quot;#A-oy环游世界&quot; class=&quot;headerlink&quot; title=&quot;A - oy环游世界&quot;&gt;&lt;/a&gt;A - oy环游世界&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;A、给定n个点，求出从起点开始遍历到最后一个点的最短曼哈顿
      
    
    </summary>
    
      <category term="UESTC" scheme="http://decision01.cn/categories/UESTC/"/>
    
      <category term="ACM" scheme="http://decision01.cn/categories/UESTC/ACM/"/>
    
    
      <category term="ACM" scheme="http://decision01.cn/tags/ACM/"/>
    
      <category term="动态规划" scheme="http://decision01.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>UESTC暑假前集训-数据结构-解题报告</title>
    <link href="http://decision01.cn/2019/05/13/UESTC%E6%9A%91%E5%81%87%E5%89%8D%E9%9B%86%E8%AE%AD-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://decision01.cn/2019/05/13/UESTC暑假前集训-数据结构/</id>
    <published>2019-05-13T13:06:22.000Z</published>
    <updated>2019-06-02T13:18:05.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A、对一个有n个数的区间进行四种操作，该区间内每个数的初始值为$ a_i $，在输入的第二行进行输入</p><blockquote><p>op = 1时，输入三个数$ L、R、k $,表示对区间$ [L,R] $的数全部加上$ k $<br>op = 2时，输入三个数$ L、R、k $,表示对区间$ [L,R] $的数全部乘上$ k $<br>op = 3时，输入三个数$ L、R、k $,表示对区间$ [L,R] $的数全部变成$ k $<br>op = 4时，输入两个数$ L、R $,要求输出区间方差乘上样本数的平方后的结果</p></blockquote></blockquote><p><code>线段树</code> <code>lazy标记</code></p><p>答案最后要求输出的是$ n^2S^2 $</p><p>那么把方差的公式展开：</p><script type="math/tex; mode=display">\begin{align*}n^2S^2&= n \sum ^ {n} _ {i = 1}(X_i -  \bar X)^2 \\&=n\sum ^ {n} _ {i = 1} (X_i ^ 2 - 2 X_i \bar X + \bar X^2) \\&=n\sum ^ {n} _ {i = 1} X _ i ^2 - 2n\bar X \sum ^ {n} _ {i = 1}X_i + n\sum ^ {n} _ {i = 1} \bar X^2 \\&= n\sum ^ {n} _ {i = 1} X _ i ^2 - 2(\sum ^ {n} _ {i = 1}X_i)^2 + n ^ 2\bar X^2 \\& = n\sum ^ {n} _ {i = 1} X _ i ^2 - (\sum ^ {n} _ {i = 1}X_i)^2\end{align*}</script><p>那么最后就可以考虑用线段树维护<strong>区间元素的和以及区间元素平方的和</strong>，线段树我每个结点在维护左右区间端点的同时维护区间和以及区间平方和，同时加上两个lazy标记进行加操作和乘的操作，对于第三个操作直接对区间乘0然后加上k就可以了，考虑到lazy标记的先后性，对于区间的操作先乘后加以保证pushdown的方便；<br>建树时时间复杂度为$ O(n) $,查询以及修改时最深可以到$ logn $的深度(<del>我瞎b分析的别打我</del>),那么操作时的复杂度为$O(logn)$,一共q次操作，总的时间复杂度是$ O(n + qlogn) $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ll sum;</span><br><span class="line">ll sum2;</span><br><span class="line">ll l,r;</span><br><span class="line">ll add,mul;</span><br><span class="line">Node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *rt = <span class="keyword">new</span> Node;</span><br><span class="line">ll ssum2,ssum;</span><br><span class="line">ll n,q,o,L,R,k;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">root -&gt; sum = (root -&gt; lchild -&gt; sum + root -&gt; rchild -&gt; sum) % mod;</span><br><span class="line">root -&gt; sum2 = (root -&gt; lchild -&gt; sum2 + root -&gt; rchild -&gt; sum2) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(Node *root,ll l,ll r)</span></span>&#123;</span><br><span class="line">root -&gt; l = l;</span><br><span class="line">root -&gt; r = r;</span><br><span class="line">root -&gt; add = <span class="number">0</span>;</span><br><span class="line">root -&gt; mul = <span class="number">1</span>;</span><br><span class="line">root -&gt; sum = <span class="number">0</span>;</span><br><span class="line">root -&gt; sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">root -&gt; sum = tmp % mod;</span><br><span class="line">root -&gt; sum2 = ((tmp % mod) * (tmp % mod)) % mod;</span><br><span class="line">root -&gt; lchild = root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">root -&gt; lchild = <span class="keyword">new</span> Node;</span><br><span class="line">root -&gt; rchild = <span class="keyword">new</span> Node;</span><br><span class="line">build(root -&gt; lchild,l,mid);</span><br><span class="line">build(root -&gt; rchild,mid + <span class="number">1</span>,r);</span><br><span class="line">    pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">ll add = root -&gt; add % mod;</span><br><span class="line">ll mul = root -&gt; mul % mod;</span><br><span class="line">root -&gt; lchild -&gt; add = (root -&gt; lchild -&gt; add * mul % mod + add) % mod;</span><br><span class="line">root -&gt; rchild -&gt; add = (root -&gt; rchild -&gt; add * mul % mod + add) % mod;</span><br><span class="line">root -&gt; lchild -&gt; mul = root -&gt; lchild -&gt; mul * mul % mod;</span><br><span class="line">root -&gt; rchild -&gt; mul = root -&gt; rchild -&gt; mul * mul % mod;</span><br><span class="line">root -&gt; lchild -&gt; sum2 = ((root -&gt; lchild -&gt; sum2 * mul % mod) * mul % mod + ((<span class="number">2</span> * (add * mul % mod) % mod) * root -&gt; lchild -&gt; sum) % mod + ((root -&gt; lchild -&gt; r - root -&gt; lchild -&gt; l + <span class="number">1</span>) * add % mod) *add % mod);</span><br><span class="line">root -&gt; rchild -&gt; sum2 = ((root -&gt; rchild -&gt; sum2 * mul % mod) * mul % mod + ((<span class="number">2</span> * (add * mul % mod) % mod) * root -&gt; rchild -&gt; sum) % mod + ((root -&gt; rchild -&gt; r - root -&gt; rchild -&gt; l + <span class="number">1</span>) * add % mod) *add % mod);</span><br><span class="line">root -&gt; lchild -&gt; sum = (root -&gt; lchild -&gt; sum * mul % mod + (root -&gt; lchild -&gt; r - root -&gt; lchild -&gt; l + <span class="number">1</span>) * add % mod) % mod;</span><br><span class="line">root -&gt; rchild -&gt; sum = (root -&gt; rchild -&gt; sum * mul % mod + (root -&gt; rchild -&gt; r - root -&gt; rchild -&gt; l + <span class="number">1</span>) * add % mod) % mod;</span><br><span class="line">root -&gt; add = <span class="number">0</span>;</span><br><span class="line">root -&gt; mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Node *root,ll l,ll r,ll a)</span></span>&#123;</span><br><span class="line">ll nl = root -&gt; l,nr = root -&gt; r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= nl &amp;&amp; nr &lt;= r)&#123;</span><br><span class="line">root -&gt; add = (root -&gt; add + a) % mod;</span><br><span class="line">root -&gt; sum2 = (root -&gt; sum2 + (root -&gt; sum * <span class="number">2</span> * a) % mod +((nr - nl + <span class="number">1</span>) * a % mod ) * a % mod) % mod; </span><br><span class="line">root -&gt; sum = (root -&gt; sum + (nr - nl + <span class="number">1</span>) * a % mod) % mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line">ll mid = (root -&gt; l + root -&gt; r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) add(root -&gt; lchild,l,r,a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) add(root -&gt; rchild,l,r,a);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">add(root -&gt; lchild,l,mid,a);</span><br><span class="line">add(root -&gt; rchild,mid + <span class="number">1</span>,r,a);</span><br><span class="line">&#125;</span><br><span class="line">pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(Node *root,ll l,ll r,ll m)</span></span>&#123;</span><br><span class="line">ll nl = root -&gt; l,nr = root -&gt; r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= nl &amp;&amp; nr &lt;= r)&#123;</span><br><span class="line">root -&gt; mul = (root -&gt; mul * m) % mod;</span><br><span class="line">root -&gt; sum2 = (root -&gt; sum2 * m % mod) * m % mod;</span><br><span class="line">root -&gt; sum = root -&gt; sum * m % mod;</span><br><span class="line">root -&gt; add = root -&gt; add * m % mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line">ll mid = (root -&gt; l + root -&gt; r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) mul(root -&gt; lchild,l,r,m);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) mul(root -&gt; rchild,l,r,m);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">mul(root -&gt; lchild,l,mid,m);</span><br><span class="line">mul(root -&gt; rchild,mid + <span class="number">1</span>,r,m);</span><br><span class="line">&#125;</span><br><span class="line">pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(Node *root,ll l,ll r)</span></span>&#123;</span><br><span class="line">ll nl = root -&gt; l,nr = root -&gt; r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= nl &amp;&amp; nr &lt;= r)&#123;</span><br><span class="line">ssum2 = (ssum2 + root -&gt; sum2) % mod;</span><br><span class="line">ssum = (ssum + root -&gt; sum) % mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line">ll mid = (root -&gt; l + root -&gt; r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) query(root -&gt; lchild,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) query(root -&gt; rchild,l,r);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">query(root -&gt; lchild,l,mid);</span><br><span class="line">query(root -&gt; rchild,mid + <span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">build(rt,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;o;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R;</span><br><span class="line">ll N = R - L + <span class="number">1</span>;</span><br><span class="line">ssum = ssum2 = ans = <span class="number">0</span>;</span><br><span class="line">query(rt,L,R);</span><br><span class="line">ans = ((N * ssum2) % mod - (ssum * ssum) % mod + mod) % mod;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">1</span>) add(rt,L,R,k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o == <span class="number">2</span>) mul(rt,L,R,k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o == <span class="number">3</span>)&#123;</span><br><span class="line">mul(rt,L,R,<span class="number">0</span>);</span><br><span class="line">add(rt,L,R,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>B、给出一棵树，每条边都有一定的权值$w_i$，每次询问给出两个点$u、v$，要求输出从$u$到$v$的最短路径上的最小权值</p></blockquote><p><code>树链剖分</code></p><p>看到的第一眼觉得是个树剖（虽然那个时候我已经忘了树剖怎么写），然后康到有人说lct，但是lct我写不来就先学树剖了，但是后面M题还是逃不过lct。。<br>先dfs一遍分出轻链和重链，第二次dfs给访问的链编号并且把链连接起来，然后放入线段树里进行查询维护<br>查询两个点的时候把它们两个一直往上提到同一条链上，查询对应区间上的最小值<br><del>因为query少写了个min一直没过去，感谢xyy帮我康了一下</del><br>查询的时间复杂度是$O (logn*logn) $<del>(我证明不了（逃）)&lt;\del&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> minn;</span><br><span class="line">&#125;tr[maxn * <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,u,v,w;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn],siz[maxn],dep[maxn],minn[maxn],son[maxn],pos[maxn],top[maxn];</span><br><span class="line"><span class="keyword">int</span> mn[maxn],tid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v,d));</span><br><span class="line">G.push_back(Edge(v,u,d));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> pre,<span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">fa[now] = pre;</span><br><span class="line">siz[now]++;</span><br><span class="line">dep[now] = deep;</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(v == pre) <span class="keyword">continue</span>;</span><br><span class="line">minn[v] = G[edges[now][i]].dist;</span><br><span class="line">dfs1(v,now,deep+<span class="number">1</span>);</span><br><span class="line">siz[now] += siz[v];</span><br><span class="line"><span class="keyword">if</span>(son[now] == <span class="number">-1</span> || siz[son[now]] &lt; siz[v]) son[now] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> chain)</span></span>&#123;</span><br><span class="line">pos[now] = tid++;</span><br><span class="line">top[now] = chain;</span><br><span class="line">mn[pos[now]] = minn[now];</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">if</span>(son[now] == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">dfs2(son[now],chain); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(v != fa[now] &amp;&amp; v != son[now])&#123;</span><br><span class="line">dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">tr[k].l = l;</span><br><span class="line">tr[k].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">tr[k].minn = mn[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">build(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">tr[k].minn = min(tr[k&lt;&lt;<span class="number">1</span>].minn,tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == l&amp;&amp; t == r)&#123;</span><br><span class="line"><span class="keyword">return</span> tr[k].minn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(t &lt;= mid) <span class="keyword">return</span> query(s,t,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s &gt; mid) <span class="keyword">return</span> query(s,t,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> min(query(s,mid,l,mid,k&lt;&lt;<span class="number">1</span>),query(mid + <span class="number">1</span>,t,mid + <span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> chain1 = top[s],chain2 = top[t];</span><br><span class="line"><span class="keyword">while</span>(chain1 != chain2)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[chain1] &lt; dep[chain2]) swap(chain1,chain2),swap(s,t);</span><br><span class="line"><span class="keyword">if</span>(chain1 == <span class="number">1</span>) ans = min(ans,query(pos[chain1] + <span class="number">1</span>,pos[s],<span class="number">1</span>,tid - <span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> ans = min(ans,query(pos[chain1],pos[s],<span class="number">1</span>,tid<span class="number">-1</span>,<span class="number">1</span>));</span><br><span class="line">s = fa[chain1];</span><br><span class="line">chain1 = top[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == t) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">if</span>(dep[s] &gt; dep[t]) swap(s,t);</span><br><span class="line">ans = min(ans,query(pos[son[s]],pos[t],<span class="number">1</span>,tid - <span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(son,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">Addedge(u,v,w);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,tid - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Query(u,v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></del></p><blockquote><p>C、给出n个区间，对于每次给出的区间在覆盖之前的区间之后，输出连通区间数量</p></blockquote><p><code>set</code> <code>暴力求解</code></p><p>一开始我想的是利用并查集维护每个区间的连通性，然后用集合合并插入集合的左右区间，结果越写越复杂<br>突然想起来操作的方式可以直接单独使用set进行操作，对于每次插入的区间，先放到集合里面，然后再取出来，向左右两边合并之后放回集合，那么集合的大小就是连通区间的数量<br>合并的时候要向左合并到最左边的一个区间的右端点不再当前区间内部，向右边合并的时候到最右边的区间的左端点不在当前区间的内部<br>对于一个集合，其本质是红黑树，那么插入操作是$ O(logn) $的，查询操作也是$ O(logn) $的，而在合并操作的时候向左右合并的<strong>最坏情况</strong>是插入的时候之前都没有区间可以合并并且当前区间可以覆盖其他区间，那么最坏的情况下，总体的时间复杂度应该是$ O(nlogn) $<del>其实我并不会分析时间复杂度&lt;\del&gt;</del></p><blockquote><ul><li>对于区间按照其左右端点作为两个权值进行排序</li><li>每次插入区间之后取出来进行合并</li><li>左右区间合并要注意条件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; lr;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> -&gt; lr &lt; b.lr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; all;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; query;</span><br><span class="line">node tmp;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tmp.lr.first&gt;&gt;tmp.lr.second;</span><br><span class="line">        tmp.pos = i;</span><br><span class="line">        query.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    all.insert(query[<span class="number">0</span>]);</span><br><span class="line">    ans ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        all.insert(query[i]);</span><br><span class="line">        <span class="built_in">set</span>&lt;node&gt;::iterator now;</span><br><span class="line">        now = all.find(query[i]);</span><br><span class="line">        <span class="built_in">set</span>&lt;node&gt;::iterator nxt;</span><br><span class="line">        <span class="keyword">while</span>(now != all.begin())&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;node&gt;::iterator pre = now;</span><br><span class="line">        pre --;</span><br><span class="line">        node x = *pre,y = *now;</span><br><span class="line">        <span class="keyword">if</span>(x.lr.second &lt; y.lr.first) <span class="keyword">break</span>;</span><br><span class="line">        all.erase(x);</span><br><span class="line">        <span class="keyword">if</span>(x.lr.second &gt;= y.lr.first)&#123;</span><br><span class="line">        x.lr.first = min(x.lr.first,y.lr.first);</span><br><span class="line">        x.lr.second = max(x.lr.second,y.lr.second);</span><br><span class="line">        all.erase(y);</span><br><span class="line">        all.insert(x);</span><br><span class="line">        now = all.find(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        nxt = now;</span><br><span class="line">        nxt ++;</span><br><span class="line">        <span class="keyword">while</span>(nxt != all.end())&#123;</span><br><span class="line">        node x = *nxt,y = *now;</span><br><span class="line">        <span class="keyword">if</span>(x.lr.first &gt; y.lr.second) <span class="keyword">break</span>;</span><br><span class="line">        all.erase(x);</span><br><span class="line">        <span class="keyword">if</span>(x.lr.first &lt;= y.lr.second)&#123;</span><br><span class="line">        x.lr.first = min(x.lr.first,y.lr.first);</span><br><span class="line">        x.lr.second = max(x.lr.second,y.lr.second);</span><br><span class="line">        all.erase(y);</span><br><span class="line">        all.insert(x);</span><br><span class="line">        now = all.find(x);</span><br><span class="line">        nxt = now;</span><br><span class="line">        nxt ++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        ans = all.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>D、给出一个n位的16进制数，输出取$k$位相对位置不变的最大的16进制数</p></blockquote><p><code>贪心</code> <code>stack</code></p><p>换一个思路，删除$ n - k $位数字，使得剩下的k位数的数值最大。那么就需要保证在前面的数字要尽量大，其实这里是和十进制下的删数问题是一个道理，只是用16进制进行表示而已。<br>考虑使用一个栈，当栈为空或者栈顶元素比要插入的元素小的时候，栈顶弹出，直到栈顶比要插入的数大的时候为止，然后插入这个元素，直到删去了$n - k $位之后，剩下的数全部进栈，那么就算一个最优解,显然时间复杂度可以做到$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; all;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="number">0</span>) <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> c-<span class="string">'a'</span>+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getc</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num &lt;= <span class="number">9</span> &amp;&amp; num &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'0'</span>+num;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'a'</span>+num<span class="number">-10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">k = n - k;</span><br><span class="line"><span class="keyword">while</span>(!all.empty()) all.pop();</span><br><span class="line">ans.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">    <span class="keyword">int</span> tmp = getnum(c);</span><br><span class="line">    <span class="keyword">while</span>(!all.empty() &amp;&amp; all.top() &lt; tmp &amp;&amp; k &gt; <span class="number">0</span>) all.pop(),k--;</span><br><span class="line">    all.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k) all.pop(),k--;</span><br><span class="line">    <span class="keyword">int</span> len = all.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">    ans.push_back(all.top());</span><br><span class="line">    all.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;getc(ans[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>E、给出一个序列，每个数值为$v_i$，然后每次询问为$L、R$，第一次询问时令$ans = 0$，然后后面的询问区间是令$l = (L + ans - 1) % n + 1$、$r = (R + ans - 1) % n + 1$，$l &gt; r$的时候，交换，然后正确的询问区间是$[l,r]$</p></blockquote><p><code>分块</code> <code>在线</code> <code>区间众数</code><br>这题我一开始看的时候以为是要查找LIS的个数，但是后面发现和顺序无关，然后找到了一个洛谷上面的原题，那个题我一直TLE但是交过来就A了我也很懵<del>潇神不要锤我</del>，因为代码逻辑和正解的差不多，但是我的代码就会T，感觉自己撞了鬼emm<br>主要是分块，先选取一个块大小，将整个区间分开，然后依次处理一个块到另外一个块的众数的个数。<br>开一个vector存数字在序列中的位置，同时离散化的时候把位置存进去，那么在后面查询的时候，对于不在上面区间中的数字，依次处理，处理左边的时候，查询当前数的位置加上当前解的和对应在vector中的位置小于查询右边界的话答案加1，右边也类似。<br>时间复杂度是$ O((n + m) \sqrt n) $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,l,r,anss = <span class="number">0</span>,siz = <span class="number">150</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn],a[maxn],block[maxn],cnt[maxn],pos[maxn];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">1000</span>],R[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; all[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">mst(cnt,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> mmax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = L[now];i &lt;= n;i++)&#123;</span><br><span class="line">cnt[a[i]] ++;</span><br><span class="line">mmax = max(mmax,cnt[a[i]]);</span><br><span class="line"><span class="keyword">if</span>(i == R[block[i]])&#123;</span><br><span class="line">f[now][block[i]] = mmax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> nowl,<span class="keyword">int</span> nowr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(block[nowl] == block[nowr])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nowl;i &lt;= nowr;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> len = all[a[i]].size();</span><br><span class="line"><span class="keyword">while</span>(pos[i] + res &lt; len &amp;&amp; all[a[i]][pos[i] + res] &lt;= nowr) res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(block[nowl] + <span class="number">1</span> &lt; block[nowr]) res = f[block[nowl] + <span class="number">1</span>][block[nowr] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nowl;i &lt;= R[block[nowl]];i++)&#123;</span><br><span class="line"><span class="keyword">int</span> len = all[a[i]].size();</span><br><span class="line"><span class="keyword">while</span>(pos[i] + res &lt; len &amp;&amp; all[a[i]][pos[i] + res] &lt;= nowr) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = L[block[nowr]];i &lt;= nowr;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(pos[i] &gt;= res &amp;&amp; all[a[i]][pos[i] - res] &gt;= nowl) res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">a[i] = A[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(A + <span class="number">1</span>,A + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">a[i] = lower_bound(A + <span class="number">1</span>,A + n + <span class="number">1</span>,a[i]) - A;</span><br><span class="line">all[a[i]].push_back(i);</span><br><span class="line">pos[i] = all[a[i]].size() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) block[i] = i / siz + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= block[n];i++) L[i] = (i - <span class="number">1</span>) * siz + <span class="number">1</span>,R[i] = i * siz;</span><br><span class="line">L[<span class="number">1</span>] = <span class="number">1</span>;R[block[n]] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= block[n];i++) init(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">l = (l + anss - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">r = (r + anss - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l,r);</span><br><span class="line">anss = Query(l,r);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;anss&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>F、与E题一样，给出一个序列，每个数值为$v_i$，然后每次询问为$L、R$，但是查询区间就是$[L,R]$，不需要在线查询</p></blockquote><p><code>分块</code> <code>莫队</code> <code>区间众数</code></p><p>复习了一遍莫队算法。<br>将查询区间进行排序，然后用两个指针处理区间，开两个数组，一个维护某个数的出现次数，另外一个维护出现次数为某个值的数的个数的数组。然后对查询区间进行排序，用两个指针在数组上移动到查询区间，如果当前的众数个数变成0了的话答案减一，如果当前加进来的数大于答案的话答案更新。<br>时间复杂度$O(n \sqrt n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,block;</span><br><span class="line"><span class="keyword">int</span> A[maxn],a[maxn],cnt[maxn],anss[maxn],sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> query&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (l / block == a.l / block) ? (r &lt; a.r):(l / block &lt; a.l / block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(sum,<span class="number">0</span>);</span><br><span class="line">mst(anss,<span class="number">0</span>);</span><br><span class="line">mst(cnt,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">a[i] = A[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(A + <span class="number">1</span>,A + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = lower_bound(A + <span class="number">1</span>,A + n + <span class="number">1</span>,a[i]) - A;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q[i].l&gt;&gt;q[i].r;</span><br><span class="line">q[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(q + <span class="number">1</span>,q + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l)&#123;</span><br><span class="line">sum[cnt[a[l]]]--;</span><br><span class="line"><span class="keyword">if</span>(cnt[a[l]] == ans &amp;&amp; !sum[cnt[a[l]]]) ans--;</span><br><span class="line">sum[--cnt[a[l]]]++;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r)&#123;</span><br><span class="line">sum[cnt[a[r]]]--;</span><br><span class="line"><span class="keyword">if</span>(cnt[a[r]] == ans &amp;&amp; !sum[cnt[a[r]]]) ans--;</span><br><span class="line">sum[--cnt[a[r]]]++;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l)&#123;</span><br><span class="line">l--;</span><br><span class="line">sum[cnt[a[l]]] --;</span><br><span class="line">sum[++cnt[a[l]]] ++;</span><br><span class="line">ans = max(ans,cnt[a[l]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r)&#123;</span><br><span class="line">r++;</span><br><span class="line">sum[cnt[a[r]]] --;</span><br><span class="line">sum[++cnt[a[r]]] ++;</span><br><span class="line">ans = max(ans,cnt[a[r]]);</span><br><span class="line">&#125;</span><br><span class="line">anss[q[i].id] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;anss[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>G、长度为n的数组和一个长度为n-1的数组，有两个操作，增大某个元素并对后续元素进行处理，查询求区间和</p></blockquote><p><code>线段树</code> <code>差分序列</code></p><p><del>这题得感谢hrdg提醒了差分</del><br>首先可以知道差分是类似这样:$d<em>i = a_i - a</em>{i - 1}$<br>那么要求一个区间的区间和，根据差分的定义，可以知道在一个差分数组中:</p><script type="math/tex; mode=display">a_x = \sum _ {i = 1} ^ xd_i</script><p>那么要求取一个区间和，可以考虑先求出前缀和</p><script type="math/tex; mode=display">\begin{align*}\sum _ {i = 1} ^ x a_i& =\sum _{i = 1} ^ x \sum _ {j = 1} ^ i d_j \\& = \sum _ {i = 1} ^ x (x - i + 1) * d_i \\& = (x + 1)\sum _ {i = 1} ^ xd_i+ \sum _ {i = 1} ^ x d_i * i\end{align*}</script><p>那么只需要维护差分数组的区间和以及$i * d<em>i$的区间和就可以了<br>这样的话开一个差分数组，对数的差分进行记录，然后再用线段树来维护区间和<br>每次对差分数组进行操作的时候，当修改这个值增大的时候，其后面的差分会减小，那么需要把后面的差分改成$b_i$，依次向后进行，直到某个位置差分大于等于$b </em> i$的时候停止<br>然后对线段树进行修改，使得区间元素和差分数组对应区间相同，每次查询的时候查询左端点和右端点的前缀和相减一下即可<br>每次修改的复杂度是$O(nlogn)$，查询的复杂度是$O(logn)$<br>如果数据改得强的话我能被卡到$O(n^2logn)$，就是每次都是修改并且修改能从头改到位的情况。。<br>看了std，我的这是个假算法，还被xyy叫上去讲了一下，丢人QAQ<br>然而看了std现在我也不想改了。。就直接交这一个了。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">ll l,r;</span><br><span class="line">ll sum1,sum2;</span><br><span class="line">Node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ll n,q,a[maxn],b[maxn],L,R,p,x,op;</span><br><span class="line">ll delta[maxn],ssum1,ssum2,ans;</span><br><span class="line"></span><br><span class="line">Node *root = new Node;</span><br><span class="line"></span><br><span class="line">void build(Node*root,ll l,ll r)&#123;</span><br><span class="line">root -&gt; l = l;</span><br><span class="line">root -&gt; r = r;</span><br><span class="line">if(l == r)&#123;</span><br><span class="line">root -&gt; sum1 = delta[l];</span><br><span class="line">root -&gt; sum2 = delta[l] * l;</span><br><span class="line">root -&gt; lchild = root -&gt;rchild = NULL;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">root -&gt; lchild = new Node;</span><br><span class="line">root -&gt; rchild = new Node;</span><br><span class="line">ll mid = (l + r) / 2;</span><br><span class="line">build(root -&gt; lchild,l,mid);</span><br><span class="line">build(root -&gt; rchild,mid + 1,r);</span><br><span class="line">root -&gt; sum1 = root -&gt; lchild -&gt; sum1 + root -&gt; rchild -&gt; sum1;</span><br><span class="line">root -&gt; sum2 = root -&gt; lchild -&gt; sum2 + root -&gt; rchild -&gt; sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void modify(Node *root,ll l,ll r)&#123;</span><br><span class="line">if(root -&gt; l == root -&gt; r)&#123;</span><br><span class="line">root -&gt; sum1 = delta[l];</span><br><span class="line">root -&gt; sum2 = delta[l] * l;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (root -&gt; l + root -&gt; r) / 2;</span><br><span class="line">if(r &lt;= mid) modify(root -&gt; lchild,l,r);</span><br><span class="line">else if(l &gt; mid) modify(root -&gt; rchild,l,r);</span><br><span class="line">else&#123;</span><br><span class="line">modify(root -&gt; lchild,l,mid);</span><br><span class="line">modify(root -&gt; rchild,mid+1,r);</span><br><span class="line">&#125;</span><br><span class="line">root -&gt; sum1 = root -&gt; lchild -&gt; sum1 + root -&gt; rchild -&gt; sum1;</span><br><span class="line">    root -&gt; sum2 = root -&gt; lchild -&gt; sum2 + root -&gt; rchild -&gt; sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void query(Node *root,ll l,ll r)&#123;</span><br><span class="line">if(l &lt;= root -&gt; l &amp;&amp; root -&gt; r &lt;= r)&#123;</span><br><span class="line">ssum1 += root -&gt; sum1;</span><br><span class="line">ssum2 += root -&gt; sum2;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (root -&gt; l + root -&gt; r) / 2;</span><br><span class="line">if(r &lt;= mid) query(root -&gt; lchild,l,r);</span><br><span class="line">else if(l &gt; mid) query(root -&gt; rchild,l,r);</span><br><span class="line">else &#123;</span><br><span class="line">query(root -&gt; lchild,l,mid);</span><br><span class="line">query(root -&gt; rchild,mid+1,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll getsum(ll x)&#123;</span><br><span class="line">if(x == 0) return 0;</span><br><span class="line">ll num;</span><br><span class="line">ssum1 = ssum2 = 0;</span><br><span class="line">query(root,1,x);</span><br><span class="line">num = (x + 1)*ssum1 - ssum2;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">delta[i] = a[i] - a[i -1];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 2;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line">build(root,1,n);</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line">for(ll i = 1;i&lt;=q;i++)&#123;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line">if(op == 1)&#123;</span><br><span class="line">cin&gt;&gt;p&gt;&gt;x;</span><br><span class="line">delta[p] += x;</span><br><span class="line">delta[p + 1] -= x;</span><br><span class="line">ll rr = p;</span><br><span class="line">for(ll j = p + 1;j &lt;= n;j++)&#123;</span><br><span class="line">if(delta[j] &lt; b[j])&#123;</span><br><span class="line">ll de = b[j] - delta[j];</span><br><span class="line">ll mul = de / b[j] + (de % b[j] != 0);</span><br><span class="line">ll add = mul * b[j];</span><br><span class="line">delta[j] += add;</span><br><span class="line">delta[j + 1] -= add;</span><br><span class="line">rr = j + 1;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">modify(root,p,rr);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">ll sum1,sum2;</span><br><span class="line">sum1 = getsum(L - 1);</span><br><span class="line">sum2 = getsum(R);</span><br><span class="line">ans = sum2 - sum1;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>H、给定一个长为n的序列，要求输出长度不超过m的子序列的最大值</p></blockquote><p><code>单调队列</code></p><p>将问题转化为求一个单调上升的前缀和问题，因为要求子序列和最大值，那么只要前缀和在增加的话对应区间中的和就是在上升的。那么维护一个单调队列，每次在长度大于m的时候前面的出队列，后面的入队列的元素中有递减的就出队列，保证队列的单调性<br>时间复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q[<span class="number">100007</span>];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sum[i];</span><br><span class="line">sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">q[r++] = <span class="number">0</span>;</span><br><span class="line">ans = sum[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r &amp;&amp; i - q[l] &gt; m)&#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,sum[i] - sum[q[l]]);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r &amp;&amp; sum[q[r - <span class="number">1</span>]] &gt;= sum[i])&#123;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">q[r++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>I、每次给出一个队伍的过题罚时，然后对过题数以及罚时进行排名，要求输出一号队伍每次的排名</p></blockquote><p><code>Treap</code> <code>平衡树</code></p><p>这题。。作死敲了一整天的splay心态爆炸最后写了个treap<br>把每个题当作一个二元组进行处理，重载一个比较符号，然后放到treap里面维护就行了<br>其他的操作和treap一样。。<br>查询，插入，删除操作的操作时间复杂度是$O(logn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id,pass,time;</span><br><span class="line"><span class="keyword">int</span> siz;</span><br><span class="line">Node *ch[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Node a)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> -&gt; time == a.time &amp;&amp; <span class="keyword">this</span> -&gt; pass == a.pass) <span class="keyword">return</span> <span class="keyword">this</span> -&gt; id &gt; a.id;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span> -&gt; pass == a.pass) <span class="keyword">return</span> <span class="keyword">this</span> -&gt; time &gt; a.time;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span> -&gt; pass &lt; a.pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pa,<span class="keyword">int</span> ti)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pa == pass &amp;&amp; ti == time &amp;&amp; x == id) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa == pass &amp;&amp; ti == time) <span class="keyword">return</span> id &gt; x ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa == pass) <span class="keyword">return</span> time &gt; ti ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> pass &lt; pa ? <span class="number">0</span> : <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">siz = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] != <span class="literal">NULL</span>) siz += ch[<span class="number">0</span>]-&gt;siz;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">1</span>] != <span class="literal">NULL</span>) siz += ch[<span class="number">1</span>]-&gt;siz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,m,n;</span><br><span class="line"><span class="keyword">int</span> pas[<span class="number">100007</span>],tim[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Node *node,<span class="keyword">int</span> x,<span class="keyword">int</span> pa,<span class="keyword">int</span> ti)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pa == node -&gt; pass &amp;&amp; ti == node -&gt; time &amp;&amp; x == node -&gt; id) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa == node -&gt; pass &amp;&amp; ti == node -&gt; time) <span class="keyword">return</span> node -&gt; id &gt; x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pa == node -&gt; pass) <span class="keyword">return</span> node -&gt; time &gt; ti;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> node -&gt; pass &lt; pa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node* &amp;o, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    Node* k = o-&gt;ch[d^<span class="number">1</span>]; o-&gt;ch[d^<span class="number">1</span>] = k-&gt;ch[d]; k-&gt;ch[d] = o;</span><br><span class="line">    o-&gt;maintain(); k-&gt;maintain(); o = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;o,<span class="keyword">int</span> x,<span class="keyword">int</span> pa,<span class="keyword">int</span> ti)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o==<span class="literal">NULL</span>)&#123;</span><br><span class="line">o=<span class="keyword">new</span> Node();</span><br><span class="line">o -&gt; ch[<span class="number">0</span>]=o-&gt;ch[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">o -&gt; id=x;</span><br><span class="line">o -&gt; pass = pa;</span><br><span class="line">o -&gt; time = ti;</span><br><span class="line">o -&gt; siz = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = o-&gt;cmp(x,pa,ti);</span><br><span class="line">insert(o-&gt;ch[d],x,pa,ti);</span><br><span class="line"><span class="keyword">if</span>(o-&gt;ch[d] &gt; o);</span><br><span class="line">rotate(o,d^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">o-&gt;maintain();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tfind</span><span class="params">(Node *o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(o != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> d = o -&gt; cmp(x,pas[x],tim[x]);</span><br><span class="line"><span class="keyword">if</span>(d == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> o = o -&gt; ch[d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *o,<span class="keyword">int</span> x,<span class="keyword">int</span> pa,<span class="keyword">int</span> ti)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res=o-&gt;ch[<span class="number">0</span>]-&gt;siz;</span><br><span class="line">    <span class="keyword">if</span>(o -&gt; id == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(comp(o,x,pa,ti)) <span class="keyword">return</span>  query(o-&gt;ch[<span class="number">0</span>],x,pa,ti);</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span> + query(o-&gt;ch[<span class="number">1</span>],x,pa,ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node* &amp;o,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = o-&gt;cmp(x,pas[x],tim[x]);</span><br><span class="line">    Node* u = o;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != <span class="literal">NULL</span> &amp;&amp; o-&gt;ch[<span class="number">1</span>] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d2 = o-&gt;ch[<span class="number">0</span>] &gt; o-&gt;ch[<span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            rotate(o,d2);</span><br><span class="line">            remove(o-&gt;ch[d2],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] == <span class="literal">NULL</span>) o = o-&gt;ch[<span class="number">1</span>]; <span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">delete</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> remove(o-&gt;ch[d],x);</span><br><span class="line">    <span class="keyword">if</span>(o != <span class="literal">NULL</span>) o-&gt;maintain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *root = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">insert(root,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(tfind(root,a)) remove(root,a);</span><br><span class="line">pas[a] += <span class="number">1</span>;</span><br><span class="line">tim[a] += b;</span><br><span class="line">insert(root,a,pas[a],tim[a]);</span><br><span class="line">ans = query(root,<span class="number">1</span>,pas[<span class="number">1</span>],tim[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>J、给出一个环形的序列，从1到n进行编号，选择m个不相邻的区域使得序列和最大</p></blockquote><p><code>priority_queue</code> <code>贪心</code></p><p>一开始能想到的算法是直接放到优先队列里面贪心，但是这样不能保证每次选取的是不相邻的，而且就算保证了不相邻也会使得出现这样一种情况，选取1 4的位置，这样的话中间空出两个位置不能选，这样会导致有解的情况出现无解。<br>然后我第二次修改了一下，每次插入的时候如果这个编号的位置边上被选择了就看被选择的这个区域它边上两个加起来是不是最优，如果是的话就把原来选择了的替换成它边上的两个，但是现在这样的话也不能保证区域不相邻。。<br>那么就考虑每次选择的时候把选择的区域和边上的三个区域缩成一个区域，然后再放入优先队列中，当然每次修改的时候要对原来的Node数组中的数据进行修改，后面操作的时候操作的只是优先队列中对应的编号。<br>时间复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">int</span> id,pre,nxt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> -&gt; value &lt; a.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;all[<span class="number">200007</span>];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,maxx;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>,ans = -INF,max_cnt = <span class="number">0</span>,vis[<span class="number">200007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("std.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("std1.out","w",stdout);</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;all[i].value;</span><br><span class="line">all[i].id = i;</span><br><span class="line">all[i].pre = (i + n - <span class="number">1</span>) % n;</span><br><span class="line">all[i].nxt = (i + <span class="number">1</span>) % n;</span><br><span class="line">q.push(all[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n / <span class="number">2</span> &lt; m)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value_sum = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(!q.empty() &amp;&amp; cnt != m)&#123;</span><br><span class="line">Node Now = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[Now.id]) <span class="keyword">continue</span>;</span><br><span class="line">now = Now.id;</span><br><span class="line">value_sum += Now.value;</span><br><span class="line"><span class="keyword">int</span> pre = all[now].pre,nxt = all[now].nxt;</span><br><span class="line">vis[pre] = vis[nxt] = <span class="number">1</span>;</span><br><span class="line">all[now].value = all[pre].value + all[nxt].value - all[now].value;</span><br><span class="line">all[now].nxt = all[nxt].nxt;</span><br><span class="line">all[all[nxt].nxt].pre = now;</span><br><span class="line">all[now].pre = all[pre].pre;</span><br><span class="line">all[all[pre].pre].nxt = now;</span><br><span class="line">q.push(all[Now.id]);</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">max_cnt = cnt;</span><br><span class="line">ans = value_sum;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K、每次给出一个区间，表示这个区间的和是奇数或者是偶数，然后要求输出第一个不满足之前条件的询问的</p></blockquote><p><code>区间并查集</code></p><p>用并查集，表示这个数到它父节点的和为奇数还是偶数，也就是模是0还是1，每次压缩路径的时候沿着父节点向上加和取模。<br>检查的时候对于相同的区间直接大减小然后取模运算验证，不同区间就进行合并<br>时间复杂度在多次操作之后压缩路径接近于线性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1000007</span>],val[<span class="number">1000007</span>];</span><br><span class="line"><span class="keyword">int</span> a,b,v,n,q;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tfind</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != fa[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[x];</span><br><span class="line">        fa[x] = tfind(fa[x]);</span><br><span class="line">        val[x] = (val[x] + val[f]) % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        val[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"odd"</span>) v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ta = tfind(a - <span class="number">1</span>), tb = tfind(b);</span><br><span class="line">        <span class="keyword">if</span> ( ta == tb)&#123;</span><br><span class="line">            <span class="keyword">if</span>((val[a - <span class="number">1</span>] + v) % <span class="number">2</span> == val[b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i - <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[tb] = ta;</span><br><span class="line">            val[tb] = (val[a - <span class="number">1</span>] + v - val[b] + <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"ORZQHQH"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>L、给定一个长度为$n$的数列，初始值都是0，有两种操作</p><blockquote><p>op = 1、输入$ L、P、a、k、p $，表示给$ [L,p] $区间上依次加上一个首项为$ a $，公差为$k$的等差数列，然后给$ (p,R] $区间上依次加上一个以前一个加上数列的末项减去k为首项，$ -k $作为公差的等差数列<br>op = 2、输入$ L、R $，输出这个区间中最长的等差数列的长度</p></blockquote></blockquote><p>把数列直接加上去太麻烦了，那么考虑维护一棵差分线段树，令公差$d<em>i = a</em>{i} - a_{i - 1}$，存到线段树中。<br>线段树维护当前区间左边的值$ lval $，右边的值$ rval $，从左边开始最长的相等差分$ llen $,从右边开始的最长的相等差分$ rlen $，中间的最长的相等差分$ mlen $，区间长度$ size $，区间最长的相等差分长度$ maxlen $。<br>那么每次向上合并操作的时候，先看一下左右子树中间那个位置的树是不是相同的，如果是的话中间位置的长度就是左子树的右边长度加上右子树的左边长度，否则取两颗子树中间最长的长度<br>而对于左长度和右长度，先看左子树的左长度是不是等于区间长度，并且中间值是否相等，是的话就是左子树的左长度加上右子树的右长度，否则就直接是左子树的左长度，右长度同理<br>而左右的值直接pushup就行了。<br>pushdown是修改操作的时候的add操作，add操作后可以pushup维护长度，所以直接pushdown就可以。<br>修改的操作，把第一个直接加上首项$a$,然后区间内部直接$ +k $或者$ -k $就可以，注意对最后一个位置的操作是如果$R &lt; n$的话就对$R + 1$的位置减去$a + k <em>(2 </em>p - L - R)$<br>查询的时候考虑到最长的差分可能在查询区间的第一个位置开始，那么在查询左右端点不相等的时候直接把左端点挪一个位置，然后结果加上一就是最后的答案<br>线段树维护，每次查询和修改时间复杂度$O (logn) $，m次操作，总时间复杂度应该是 $O(mlogn) $？<del>（瞎分析的）</del><br><code>差分序列</code> <code>线段树</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,op,L,R,a,k,p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,siz;</span><br><span class="line"><span class="keyword">int</span> add;</span><br><span class="line"><span class="keyword">int</span> lval,rval;</span><br><span class="line"><span class="keyword">int</span> llen,rlen,mlen,maxlen;</span><br><span class="line">Node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *rt = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">root -&gt; siz = root -&gt; r - root -&gt; l + <span class="number">1</span>;</span><br><span class="line">root -&gt; lval = root -&gt; lchild -&gt; lval;</span><br><span class="line">root -&gt; rval = root -&gt; rchild -&gt; rval;</span><br><span class="line">root -&gt; maxlen = max(root -&gt; lchild -&gt; maxlen,root -&gt; rchild -&gt; maxlen);</span><br><span class="line">root -&gt; siz = root -&gt; r - root -&gt; l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(root -&gt; lchild -&gt;rval == root -&gt; rchild -&gt; lval) root -&gt; mlen = root -&gt; lchild -&gt; rlen + root -&gt; rchild -&gt; llen;</span><br><span class="line"><span class="keyword">else</span> root -&gt; mlen = max(root -&gt; lchild -&gt; rlen,root -&gt; rchild -&gt; llen);</span><br><span class="line"><span class="keyword">if</span>(root -&gt; lchild -&gt; llen == root -&gt; lchild -&gt; siz)&#123;</span><br><span class="line"><span class="keyword">if</span>(root -&gt; lchild -&gt;rval == root -&gt; rchild -&gt; lval) root -&gt; llen = root -&gt; lchild -&gt; llen + root -&gt; rchild -&gt; llen;</span><br><span class="line"><span class="keyword">else</span> root -&gt;llen = root -&gt; lchild -&gt;llen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> root -&gt; llen = root -&gt; lchild -&gt; llen;</span><br><span class="line"><span class="keyword">if</span>(root -&gt; rchild -&gt; llen == root -&gt; rchild -&gt; siz)&#123;</span><br><span class="line"><span class="keyword">if</span>(root -&gt; lchild -&gt;rval == root -&gt; rchild -&gt; lval) root -&gt; rlen = root -&gt; rchild -&gt; rlen + root -&gt; lchild -&gt; rlen;</span><br><span class="line"><span class="keyword">else</span> root -&gt; rlen = root -&gt; rchild -&gt; rlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> root -&gt; rlen = root -&gt; rchild -&gt; rlen;</span><br><span class="line">root -&gt; maxlen = max(root -&gt; maxlen,root -&gt; llen);</span><br><span class="line">root -&gt; maxlen = max(root -&gt; maxlen,root -&gt; rlen);</span><br><span class="line">root -&gt; maxlen = max(root -&gt; maxlen,root -&gt; mlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">root -&gt; lchild -&gt; add += root -&gt; add;</span><br><span class="line">root -&gt; rchild -&gt; add += root -&gt; add;</span><br><span class="line">root -&gt; lchild -&gt; lval += root -&gt; add;</span><br><span class="line">root -&gt; lchild -&gt; rval += root -&gt; add;</span><br><span class="line">root -&gt; rchild -&gt; lval += root -&gt; add;</span><br><span class="line">root -&gt; rchild -&gt; rval += root -&gt; add;</span><br><span class="line">root -&gt; add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(Node *root,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">root -&gt; l = l;</span><br><span class="line">root -&gt; r = r;</span><br><span class="line">root -&gt; add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">root -&gt; siz = <span class="number">1</span>;</span><br><span class="line">root -&gt; lval = root -&gt; rval = root -&gt; add=  <span class="number">0</span>;</span><br><span class="line">root -&gt; llen = root -&gt; rlen = root -&gt; mlen = root -&gt;maxlen  = <span class="number">1</span>;</span><br><span class="line">root -&gt; lchild = root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">root -&gt; lchild = <span class="keyword">new</span> Node;</span><br><span class="line">root -&gt; rchild = <span class="keyword">new</span> Node;</span><br><span class="line">build(root -&gt; lchild,l,mid);</span><br><span class="line">build(root -&gt; rchild,mid + <span class="number">1</span>,r);</span><br><span class="line">pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">get</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">Node res;</span><br><span class="line">res.l = root -&gt; l;</span><br><span class="line">res.r = root -&gt; r;</span><br><span class="line">res.siz = root -&gt; siz;</span><br><span class="line">res.lval = root -&gt; lval;</span><br><span class="line">res.rval = root -&gt; rval;</span><br><span class="line">res.llen = root -&gt; llen;</span><br><span class="line">res.rlen = root -&gt; rlen;</span><br><span class="line">res.mlen = root -&gt; mlen;</span><br><span class="line">res.maxlen = root -&gt; maxlen;</span><br><span class="line">res.lchild = res.rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">cal</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">Node res;</span><br><span class="line">res.l = a.l;</span><br><span class="line">res.r = b.r;</span><br><span class="line">res.lval = a.lval;</span><br><span class="line">res.rval = b.rval;</span><br><span class="line">res.siz = a.siz + b.siz;</span><br><span class="line">res.maxlen = max(a.maxlen,b.maxlen);</span><br><span class="line"><span class="keyword">if</span>(a.rval == b.lval)&#123;</span><br><span class="line">res.mlen = a.rlen + b.llen;</span><br><span class="line"><span class="keyword">if</span>(a.llen == a.siz) res.llen = a.llen + b.llen;</span><br><span class="line"><span class="keyword">else</span> res.llen = a.llen;</span><br><span class="line"><span class="keyword">if</span>(b.rlen == b.siz) res.rlen = a.rlen + b.rlen;</span><br><span class="line"><span class="keyword">else</span> res.rlen = b.rlen; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res.mlen = max(a.rlen,b.llen);</span><br><span class="line">res.llen = a.llen;</span><br><span class="line">res.rlen = b.rlen;</span><br><span class="line">&#125;</span><br><span class="line">res.maxlen = max(res.maxlen,res.llen);</span><br><span class="line">res.maxlen = max(res.maxlen,res.rlen);</span><br><span class="line">res.maxlen = max(res.maxlen,res.mlen);</span><br><span class="line">res.lchild = res.rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(Node *root,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= root -&gt; l &amp;&amp; root -&gt; r &lt;= r)&#123;</span><br><span class="line"><span class="keyword">return</span> get(root);</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line"><span class="keyword">int</span> mid = (root -&gt; l + root -&gt; r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> query(root -&gt; lchild,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> query(root -&gt; rchild,l,r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Node left = query(root -&gt; lchild,l,mid);</span><br><span class="line">Node right = query(root -&gt; rchild,mid + <span class="number">1</span>,r);</span><br><span class="line">Node res = cal(left,right);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tag)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= root -&gt; l &amp;&amp; root -&gt; r &lt;= r)&#123;</span><br><span class="line">root -&gt; lval += tag;</span><br><span class="line">root -&gt; rval += tag;</span><br><span class="line">root -&gt; add += tag;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line"><span class="keyword">int</span> mid = (root -&gt; l + root -&gt; r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) modify(root -&gt; lchild,l,r,tag);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) modify(root -&gt; rchild,l,r,tag);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">modify(root -&gt; lchild,l,mid,tag);</span><br><span class="line">modify(root -&gt; rchild,mid + <span class="number">1</span>,r,tag);</span><br><span class="line">&#125;</span><br><span class="line">pushup(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">Node ans;</span><br><span class="line">build(rt,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R&gt;&gt;a&gt;&gt;k&gt;&gt;p;</span><br><span class="line">    modify(rt,L,L,a);</span><br><span class="line">    <span class="keyword">int</span> lat = a + k *(<span class="number">2</span> *p - L - R);</span><br><span class="line">    <span class="keyword">if</span>(R &lt; n) modify(rt,R + <span class="number">1</span>,R + <span class="number">1</span>,-lat);</span><br><span class="line">    <span class="keyword">if</span>(L &lt; n) modify(rt,L + <span class="number">1</span>,p,k);</span><br><span class="line">    <span class="keyword">if</span>(p &lt; n)modify(rt,p + <span class="number">1</span>,R,-k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line">L++;</span><br><span class="line">    ans = query(rt,L,R);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.maxlen + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>M、给出一棵树，对树进行两个操作，一个是将某个点涂红，然后另外一个是查询一个点到最近的红点的距离</p></blockquote><p><code>点分治</code><br>学会了点分治的骚操作（<br>在树上查找整棵树的中心，将重心作为树根将树转成有根树<br>但是这个题需要对点进行修改那么就把重心连起来变成点分树来搞<br><del>std的分块学不来</del><br>一开始想复杂了把对最近的红点的维护用优先队列来搞，后面想了想其实可以直接存储距离重心最近的距离<br>那么每次修改的时候就可以直接从这个点开始跳到父亲节点上进行更新，查询的时候依次查询更新即可（<br>分治树的深度不超过$ logn $，那么每次修改时间复杂度最多是$ O(logn) $,查询操作也是$ O(logn) $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,u,v,op,x;</span><br><span class="line"><span class="keyword">int</span> root,sum;</span><br><span class="line"><span class="keyword">int</span> vis[maxn],sz[maxn],f[maxn],dep[maxn],color[maxn],nxt[maxn];</span><br><span class="line"><span class="keyword">int</span> mn[<span class="number">20</span>][<span class="number">200007</span>],pos[maxn],dfn = <span class="number">0</span>,bin[<span class="number">20</span>],lo[<span class="number">200007</span>],q[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">G.push_back(Edge(u,v));</span><br><span class="line">G.push_back(Edge(v,u));</span><br><span class="line">edges[u].push_back(G.size() - <span class="number">2</span>);</span><br><span class="line">edges[v].push_back(G.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">mn[<span class="number">0</span>][++dfn] = dep[now];</span><br><span class="line">pos[now] = dfn;</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">dep[v] = dep[now] + <span class="number">1</span>;</span><br><span class="line">dfs(v,now);</span><br><span class="line">mn[<span class="number">0</span>][++dfn] = dep[now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">u = pos[u];</span><br><span class="line">v = pos[v];</span><br><span class="line"><span class="keyword">if</span>(v &lt; u) swap(u,v);</span><br><span class="line"><span class="keyword">int</span> t = lo[v - u + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(mn[t][u],mn[t][v - bin[t] + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * RMQ(u,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>;f[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = edges[u].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v =G[edges[u][i]].to;</span><br><span class="line"><span class="keyword">if</span>(v == fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">getroot(v,u);</span><br><span class="line">sz[u] += sz[v];</span><br><span class="line">f[u] = max(f[u],sz[v]);</span><br><span class="line">&#125;</span><br><span class="line">f[u] = max(f[u],sum - sz[u]);</span><br><span class="line"><span class="keyword">if</span>(!root || f[u] &lt; f[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">nxt[now] = fa;vis[now] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> len = edges[now].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[edges[now][i]].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">sum = sz[v];</span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line">getroot(v,now);</span><br><span class="line">divide(root,now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">mst(sz,<span class="number">0</span>);</span><br><span class="line">mst(f,<span class="number">0</span>);</span><br><span class="line">mst(vis,<span class="number">0</span>);</span><br><span class="line">mst(color,<span class="number">0</span>);</span><br><span class="line">mst(q,<span class="number">-1</span>);</span><br><span class="line">G.clear();</span><br><span class="line">bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">lo[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">20</span>;i++) bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">200000</span>;i++) lo[i] = lo[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= lo[dfn];i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= dfn;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j + bin[i] - <span class="number">1</span> &lt;= dfn)&#123;</span><br><span class="line">    mn[i][j] = min(mn[i - <span class="number">1</span>][j],mn[i - <span class="number">1</span>][j + bin[i - <span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = <span class="number">0</span>;f[<span class="number">0</span>] = INF;sum = n;</span><br><span class="line">    getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    divide(root,<span class="number">0</span>);</span><br><span class="line">    color[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(now != <span class="number">0</span>)&#123;</span><br><span class="line">q[now].push(dist(now,<span class="number">1</span>));</span><br><span class="line">now = nxt[now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_dis</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q[now] != <span class="number">-1</span>) <span class="keyword">return</span> q[now].top();</span><br><span class="line"><span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">Addedge(u,v);</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(color[x]) <span class="keyword">continue</span>;</span><br><span class="line">color[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now = x;</span><br><span class="line"><span class="keyword">while</span>(now != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> dis = dist(now,x);</span><br><span class="line"><span class="keyword">if</span>(q[now] == <span class="number">-1</span> || q[now] &gt; dis)&#123;</span><br><span class="line">q[now] = dis;</span><br><span class="line">&#125;</span><br><span class="line">now = nxt[now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(color[x]) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">int</span> now = x;</span><br><span class="line"><span class="keyword">while</span>(now != <span class="number">0</span>)&#123;</span><br><span class="line">ans = min(ans,dist(now,x) + min_dis(now));</span><br><span class="line">now = nxt[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>N、对于区间进行操作，给出三种操作</p><blockquote><p>op = 1，对给定区间内的数加上k<br>op = 2，输出给定区间的区间和<br>op = 3，输出给定区间的极差</p></blockquote></blockquote><p><code>线段树</code> <code>lazy标记</code><br>lazy标记以前没学，所以第一发爆了一个裸的上去，果然3s都不够我跑<br>每次加的操作的时候，如果当前操作区间以及被要修改的区间覆盖的话那就直接对当前线段树节点维护信息操作就可以了，而要询问的时候再把标记下次传。。<br>查询修改复杂度$ O(logn) $<br><del>xyy良心题！</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> add;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> minn,maxx;</span><br><span class="line">Node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,q,o,l,r;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ssum,maxx,minn;</span><br><span class="line">Node *rt = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(Node *root,<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r)</span></span>&#123;</span><br><span class="line">root -&gt; l = l;</span><br><span class="line">root -&gt; r = r;</span><br><span class="line">root -&gt; sum = root -&gt; add = root -&gt; minn = root -&gt; maxx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">root -&gt; lchild = root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">root -&gt; lchild = <span class="keyword">new</span> Node;</span><br><span class="line">root -&gt; rchild = <span class="keyword">new</span> Node;</span><br><span class="line">build(root-&gt;lchild,l,mid);</span><br><span class="line">build(root-&gt;rchild,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">root -&gt; sum = root -&gt; lchild -&gt; sum + root -&gt; rchild -&gt; sum;</span><br><span class="line">root -&gt; minn = min(root -&gt; lchild -&gt; minn,root -&gt; rchild -&gt; minn);</span><br><span class="line">root -&gt; maxx = max(root -&gt; lchild -&gt; maxx,root -&gt; rchild -&gt; maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = root -&gt; add;</span><br><span class="line">root -&gt; lchild -&gt; add += a;</span><br><span class="line">root -&gt; rchild -&gt; add += a;</span><br><span class="line">root -&gt; lchild -&gt; sum += a * (root -&gt; lchild -&gt; r - root -&gt; lchild -&gt;l + <span class="number">1</span>);</span><br><span class="line">root -&gt; rchild -&gt; sum += a * (root -&gt; rchild -&gt; r - root -&gt; rchild -&gt;l + <span class="number">1</span>);</span><br><span class="line">root -&gt; lchild -&gt; minn += a;</span><br><span class="line">root -&gt; rchild -&gt; minn += a;</span><br><span class="line">root -&gt; lchild -&gt; maxx += a;</span><br><span class="line">root -&gt; rchild -&gt; maxx += a;</span><br><span class="line">root -&gt; add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Node *root,<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r,<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nl = root-&gt;l,nr = root-&gt;r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= nl &amp;&amp; nr &lt;= r)&#123;</span><br><span class="line">root-&gt;add += a;</span><br><span class="line">root-&gt;sum += a*(nr - nl + <span class="number">1</span>);</span><br><span class="line">root-&gt;minn += a;</span><br><span class="line">root-&gt;maxx += a;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (nl+nr)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) add(root-&gt;lchild,l,r,a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) add(root-&gt;rchild,l,r,a);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">add(root-&gt;lchild,l,mid,a);</span><br><span class="line">add(root-&gt;rchild,mid+<span class="number">1</span>,r,a);</span><br><span class="line">&#125;</span><br><span class="line">pushup(root); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(Node* root,<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nl = root-&gt;l,nr = root-&gt;r;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= nl &amp;&amp; nr &lt;= r)&#123;</span><br><span class="line">ssum += root-&gt;sum;</span><br><span class="line">minn = min(minn,root-&gt;minn);</span><br><span class="line">maxx = max(maxx,root-&gt;maxx);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(root);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (nl + nr)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=mid) query(root-&gt;lchild,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) query(root-&gt;rchild,l,r);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">query(root-&gt;lchild,l,mid);</span><br><span class="line">query(root-&gt;rchild,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("std.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("std2.out","w",stdout);</span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">build(rt,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;o;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">add(rt,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">ssum = <span class="number">0</span>;</span><br><span class="line">minn = INF;</span><br><span class="line">maxx = -INF;</span><br><span class="line">query(rt,l,r);</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;ssum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;maxx - minn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>O、给定三种操作，主要对一个集合进行操作</p><blockquote><p>o = 1、把整数x加入到集合中<br>o = 2、把整数x从集合移出<br>o = 3、输出集合中与x异或后最大的结果及最小的结果</p></blockquote></blockquote><p><code>Trie树</code> <code>位运算</code><br>用Trie树维护每个插入的数，查询的时候按照位运算进行，查最小值就顺着与当前位相同的边走，查最大值就顺着不同的走，建树要从高位开始。。一开始我从低位开始导致会到一个局部最优解（甚至错解）<br>每次操作时间复杂度最大$ O(32) $，总时间复杂度$ O(32n) $<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">bool</span> value;</span><br><span class="line">Node *next[<span class="number">2</span>]; <span class="comment">// lchild 0 rchild 1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *rt = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">Node *Now = root;</span><br><span class="line"><span class="keyword">int</span> tmp = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> x = (u &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; next[x] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">Node *newnode = <span class="keyword">new</span> Node;</span><br><span class="line">newnode -&gt; cnt = <span class="number">0</span>;</span><br><span class="line">newnode -&gt; value = x;</span><br><span class="line">newnode -&gt; next[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">newnode -&gt; next[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">Now -&gt; next[x] = newnode;</span><br><span class="line">&#125;</span><br><span class="line">Now = Now -&gt; next[x];</span><br><span class="line">Now -&gt; cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Node *root,<span class="keyword">int</span> u,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">root -&gt; cnt --;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = (u &gt;&gt; pos) &amp; <span class="number">1</span>;</span><br><span class="line">Delete(root -&gt; next[x],u,pos<span class="number">-1</span>);</span><br><span class="line">root -&gt; cnt--;</span><br><span class="line"><span class="keyword">if</span>(root -&gt; next[x] -&gt; cnt == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> root -&gt; next[x];</span><br><span class="line">root -&gt; next[x] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search1</span><span class="params">(Node *root,<span class="keyword">int</span> v)</span>     <span class="comment">//异或后最小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">Node *Now = root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> x = (v &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; next[x] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">Now = Now -&gt; next[x];</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; value &gt; <span class="number">0</span>) res += <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Now = Now -&gt; next[!x];</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; value &gt; <span class="number">0</span>) res += <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search2</span><span class="params">(Node *root,<span class="keyword">int</span> v)</span>     <span class="comment">//异或后最大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">Node *Now = root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> x = (v &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">x = !x;</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; next[x] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">Now = Now -&gt; next[x];</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; value &gt; <span class="number">0</span>) res += <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Now = Now -&gt; next[!x];</span><br><span class="line"><span class="keyword">if</span>(Now -&gt; value &gt; <span class="number">0</span>) res += <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">rt -&gt; next[<span class="number">0</span>] = rt -&gt; next[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">rt -&gt; cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> o,v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;o&gt;&gt;v;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">1</span>) insert(rt,v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o == <span class="number">2</span>) Delete(rt,v,<span class="number">31</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> ans1 = Search1(rt,v) ^ v,ans2 = Search2(rt,v) ^ v;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans1&lt;&lt;<span class="string">" "</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A、对一个有n个数的区间进行四种操作，该区间内每个数的初始值为$ a_i $，在输入的第二行进行输入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;op = 1时，输入三个数$ L、R、k $,表示对区间$ [L,R] $的数全部加上$ k $&lt;br&gt;o
      
    
    </summary>
    
      <category term="UESTC" scheme="http://decision01.cn/categories/UESTC/"/>
    
      <category term="ACM" scheme="http://decision01.cn/categories/UESTC/ACM/"/>
    
    
      <category term="ACM" scheme="http://decision01.cn/tags/ACM/"/>
    
      <category term="数据结构" scheme="http://decision01.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft大型地图规划记录</title>
    <link href="http://decision01.cn/2019/04/02/Minecraft%E5%A4%A7%E5%9E%8B%E5%9C%B0%E5%9B%BE%E8%A7%84%E5%88%92%E8%AE%B0%E5%BD%95/"/>
    <id>http://decision01.cn/2019/04/02/Minecraft大型地图规划记录/</id>
    <published>2019-04-02T13:34:24.000Z</published>
    <updated>2019-04-02T13:45:07.005Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初始实地规划"><a href="#初始实地规划" class="headerlink" title="初始实地规划"></a>初始实地规划</h4><p>UL:  27°20’6.05”北  105°15’18.66”东<br>DR: 27°16’29.70”北  105°20’6.26”东<br>实地面积：$6635.27 <em> 7914.32 m^2$<br>Minecraft内部方块：$12700</em>160000$<br>分块：$12<em>16$<br>分块面积：1058</em>1600<br>视角海拔高度：11.84公里<br>影像时间：$2018/12/3$<br><img src="./QQ截图20190329132606.jpg" alt="Alt text"></p><h4 id="区块一的建设"><a href="#区块一的建设" class="headerlink" title="区块一的建设"></a>区块一的建设</h4><p>选定区块(8000<em>8000 ~ 9000</em>9000)进行建设<br>首先在google earth上定位出重要点对应的位置，比例为1米对应2个方块<br><img src="./QQ截图20190402213157.jpg" alt="Alt text"></p><h5 id="河道的建设"><a href="#河道的建设" class="headerlink" title="河道的建设"></a>河道的建设</h5><p>之前我没有发现worldedit中的远程魔杖<code>/farwand</code>和选区移动<code>//shift &lt;数量&gt; [方向]</code>以及拓展选区<code>//expand &lt;数量&gt; [方向]</code>收缩选区<code>//contract &lt;数量&gt; [方向]</code>的指令，导致不规则选区的操作十分繁杂<br>那么现在只需要在<code>poly</code>模式下进行对应处理即可<br><img src="./2019-04-02_21.25.34.png" alt="Alt text"><br><img src="./2019-04-02_21.25.12.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;初始实地规划&quot;&gt;&lt;a href=&quot;#初始实地规划&quot; class=&quot;headerlink&quot; title=&quot;初始实地规划&quot;&gt;&lt;/a&gt;初始实地规划&lt;/h4&gt;&lt;p&gt;UL:  27°20’6.05”北  105°15’18.66”东&lt;br&gt;DR: 27°16’29.70”北
      
    
    </summary>
    
      <category term="Minecraft" scheme="http://decision01.cn/categories/Minecraft/"/>
    
    
      <category term="Minecraft" scheme="http://decision01.cn/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>字符串学习笔记</title>
    <link href="http://decision01.cn/2019/03/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://decision01.cn/2019/03/21/字符串学习笔记/</id>
    <published>2019-03-21T14:32:41.000Z</published>
    <updated>2019-03-26T14:39:45.313Z</updated>
    
    <content type="html"><![CDATA[<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><blockquote><p>对于字符串$ S $,其前缀为$ pre(s,r) = s[0…r] $,后缀为$ suf(s,r) = s[|s| - r - 1 …..|s|] $，其中$ 0 &lt; r &lt; |s| $<br>如果对于字符串有$ pre(s,r) = suf(s,r) $，则称$ pre(s,r) $是该字符串的$ border $,此时可以得到字符串的一个周期为$ |s| - r $</p></blockquote><h4 id="相关算法及数据结构"><a href="#相关算法及数据结构" class="headerlink" title="相关算法及数据结构"></a>相关算法及数据结构</h4><h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><blockquote><p>对于模式串和匹配串<br>在一个字符串中匹配另外一个字符串的时候，如果一位一位的匹配，在发现某个字符不一样的时候将匹配串进行右移进行匹配，算法的效率是十分低下的，这个时候可以考虑在匹配失败的时候直接移动到匹配失败的位置<br>那么就需要求一个$ next $数组，即字符串在该位置已匹配的字符数量‘<br>$ next $数组是当前位置之前的字符串字串前缀与后缀的最大长度</p></blockquote><p>求一个字符串的next数组，需要将其本身作为匹配串，从第2位开始匹配，这里令$ nest[0] = 0 $，然后依次匹配求出该数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char s[len];</span><br><span class="line">int next[len];</span><br><span class="line">void GetNext()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0,j = 1;</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    while(i &lt; strlen(s))&#123;</span><br><span class="line">        if(j == -1||s[i] = s[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        else j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="后缀数组及Height数组"><a href="#后缀数组及Height数组" class="headerlink" title="后缀数组及Height数组"></a>后缀数组及Height数组</h5><blockquote><p>先存个代码。。理解了再写（<br>后缀数组（SA），表示一个字符串中，后缀排第几名（rank）的后缀$ (suf(s,i)) $在第几个位置</p></blockquote><p>后缀数组的倍增+基数排序求法，时间复杂度$ O(nlogn) $<br>暂时当个板子用（实在无法理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">char s[N];</span><br><span class="line"></span><br><span class="line">int r[N],sa[N],x[N],y[N],p,m = 150;</span><br><span class="line"></span><br><span class="line">bool cmp(int *r,int x,int y,int l)&#123;return r[x] == r[y] &amp;&amp; r[x + l] == r[y + l]; &#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">for(int i = 0;i&lt;m;i++) r[i] = 0;</span><br><span class="line">for(int i = 0;i&lt;len;i++) r[x[i] = s[i]] ++;</span><br><span class="line">for(int i = 0;i&lt;m;i++) r[i] += r[i-1];</span><br><span class="line">for(int i = len - 1;i&gt;=0;i--) sa[--r[x[i]]] = i;</span><br><span class="line">for(int j = 1,p = 1;j&lt;=len;j&lt;&lt;=1,m = p)&#123;</span><br><span class="line">p = 0;</span><br><span class="line">for(int i = len - j;i&lt;len;i++) y[p++] = i;</span><br><span class="line">for(int i = 0;i&lt;len;i++) if(sa[i] &gt;= j) y[p++] = sa[i] - j;</span><br><span class="line">for(int i = 0;i&lt;=m;i++) r[i] = 0;</span><br><span class="line">for(int i = 0;i&lt;len;i++) r[x[i]] ++;</span><br><span class="line">for(int i = 0;i&lt;=m;i++) r[i] += r[i-1];</span><br><span class="line">for(int i = len - 1;i&gt;=0;i--) sa[--r[x[y[i]]]] = y[i];</span><br><span class="line">swap(x,y);</span><br><span class="line">    p = 1;</span><br><span class="line">    x[sa[0]] = 0;</span><br><span class="line">    for(int i = 1;i&lt;len;i++) x[sa[i]] = cmp(y,sa[i - 1],sa[i],j)?p-1:p++;</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>利用后缀数组求Height数组<br>$ Height[i] $表示的是后缀$ sa[i - 1] $与后缀$ sa[i] $的最长公共前缀的长度<br>Height数组表征的是后缀的公共前缀的长度，那么由sa数组的性质可以知道:</p><p><center>$ Height[i] >= Height[i-1] - 1 $</center><br>利用该性质可以从前往后求出Height数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void GetHeight(char *s,int *sa,int *h)&#123;</span><br><span class="line">    int rank[N];</span><br><span class="line">    int j,k = 0;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++) rank[sa[i]] = i;    //后缀数组与名次数组的逆运算性质</span><br><span class="line">    for(int i = 0;i&lt;n;i++,h[rank[i++]] = k)</span><br><span class="line">    for(k?k--:0,j = sa[rank[i] - 1];s[i+k] == s[j+k];k++);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h5><p>(待填坑….)</p><h5 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h5><blockquote><p>Trie树又被称为字典树<br>因为在Trie树上查询字符串类似于查询字典的操作<br>在每个结点储存一个字符，然后构造树可以用于删除，查询，插入等操作</p></blockquote><p>用结构体定义一个Trie树结点，一个结点包含一个布尔类型和接下去的结点的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">    bool isStr;</span><br><span class="line">    Node* Next[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里仅仅给出插入操作的方法，其他具体操作可见我原来CSDN博客里面的<a href="https://blog.csdn.net/decision2016/article/details/54646396" target="_blank" rel="noopener">Trie树模板</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void insert(Node* root,const char* word)&#123;</span><br><span class="line">    Node* now = root;</span><br><span class="line">    while(*word)&#123;</span><br><span class="line">        if(now-&gt;Next[word - &apos;a&apos;] == NULL)&#123;</span><br><span class="line">            Node *newnode = new Node();</span><br><span class="line">            newnode-&gt;isStr = false;</span><br><span class="line">            memset(newnode-&gt;Next,NULL,memset(newnode-&gt;Next));</span><br><span class="line">            now -&gt; Next[word - &apos;a&apos;] = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        now = *newnode;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">    now -&gt; isStr = ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h5><p><del>目前我只能记得的是KMP+Trie树(待填坑….)</del><br>AC自动机（Aho-Corasick automaton）是利用Trie树的结构，KMP的思修构造的有限状态自动机</p><blockquote><p>有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。有限状态自动机可以表示为一个有向图。</p></blockquote><p>所以对于AC自动机的构建，在于fail指针的构造，其结点与Trie树相比多保存了fail指针，指向失配后跳转的位置<br>其实其失配指针指向的位置表示的是在树的其他某个结点开始的前缀与当前匹配了的位置，然后继续匹配<br>所以利用循环的方式在构造的时候只要没查询到fail指向root<br>那么就继续查询fail指针指向的fail指针的位置，直到最后查询的fail指针的子节点存在与当前失配的位置所对应的字符</p><p>在构造trie树之后，bfs遍历构造fail指针：</p><blockquote><p>1、对于当前的结点，先检查一下结点下面的某个字符是否存在<br>2、如果存在的话，就获取当前结点的fail指针<br>3、然后查询该fail指针下面的对应字符是否存在</p><blockquote><p>不存在，继续查询fail指针<br>存在，将子字符的fail指向当前结点的fail指针的对应字符的位置</p></blockquote><p>直到找到这个fail指针下面的字符或者fail指针是指向根节点为止</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">struct acnode&#123;</span><br><span class="line">acnode *child[26];</span><br><span class="line">int sum;</span><br><span class="line">acnode *fail;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init(acnode *root)&#123;</span><br><span class="line">for(int i = 0;i&lt;26;i++) root-&gt;child[i] = NULL;</span><br><span class="line">root-&gt;sum = 0;</span><br><span class="line">root-&gt;fail = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(acnode *root,char *s)&#123;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">acnode *t = root;</span><br><span class="line">for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">int pos = s[i] - &apos;a&apos;;</span><br><span class="line">if(t-&gt;child[pos] == NULL)&#123;</span><br><span class="line">acnode *newnode = new acnode;</span><br><span class="line">init(newnode);</span><br><span class="line">t-&gt;child[pos] = newnode;</span><br><span class="line">t = t-&gt;child[pos];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">t = t-&gt;child[pos];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t-&gt;sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getfail(acnode *root)&#123;</span><br><span class="line">queue&lt;acnode*&gt; q;</span><br><span class="line">for(int i = 0;i&lt;26;i++)&#123;</span><br><span class="line">if(root-&gt;child[i] != NULL)&#123;</span><br><span class="line">root-&gt;child[i]-&gt;fail = root;</span><br><span class="line">q.push(root-&gt;child[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">acnode *now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i = 0;i&lt;26;i++)&#123;</span><br><span class="line">if(now-&gt;child[i] != NULL)&#123;</span><br><span class="line">acnode *p;</span><br><span class="line">if(now == root)&#123;</span><br><span class="line">now-&gt;child[i]-&gt;fail = root;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">p = now-&gt;fail;</span><br><span class="line">    while(p != NULL)&#123;</span><br><span class="line">    if(p-&gt;child[i] != NULL)&#123;</span><br><span class="line">    now-&gt;child[i]-&gt;fail = p-&gt;child[i];</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;fail;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p == NULL) now-&gt;child[i]-&gt;fail = root;</span><br><span class="line">    q.push(now-&gt;child[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(acnode *root,char *s)&#123;</span><br><span class="line">int cnt = 0;</span><br><span class="line">acnode *p = root;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">int pos = s[i] - &apos;a&apos;;</span><br><span class="line">while(p-&gt;child[pos] == NULL &amp;&amp; p!= root) p = p-&gt;fail;</span><br><span class="line">p = p-&gt;child[pos];</span><br><span class="line">if(!p) p = root;</span><br><span class="line">acnode *now = p;</span><br><span class="line">while(now != root)&#123;</span><br><span class="line">if(now-&gt;sum &gt;= 0)&#123;</span><br><span class="line">cnt += now-&gt;sum;</span><br><span class="line">now-&gt;sum = -1;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">now = now-&gt;fail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Manachar"><a href="#Manachar" class="headerlink" title="Manachar"></a>Manachar</h5><p>Manachar算法又称为马拉车算法，是处理最长回文子串的一种算法<br>其复杂度最差为$O(n)$，如果是朴素算法，算法复杂度最大会是$O(n^2)$<br>该算法的主要思想是利用前面已经计算了的最长回文子串来对算法进行优化<br>对字符串进行预处理，依次插入字符串中没有出现过的字符<br>在处理每一个回文中心的时候，算出当前最大的回文半径右边的位置，然后在计算下一个回文半径的时候可以知道该回文中心相对于上一个回文中心的对称位置也应该是对称的，那么由此可以利用已经处理的回文半径来进行优化</p><blockquote><p>假设最大的回文半径中心位置为mid<br>那么当当前处理的回文中心位置为i的时候，i在最大回文半径之内<br>根据回文串的性质可以知道以i为回文中心的回文串在相对mid对称的位置j，两个回文中心的回文串应该是一样的<br>所以可以得出当i小于最大回文半径位置的时候，有</p><p><center> $min(p[2*mid - 1],mx - i)$</center><br>p为当前下标对应位置的最大回文半径<br>然后为了保证在最大回文半径位置以外依然存在回文串，进行检测，然后更新最大回文半径</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">char s1[20000007],s2[20000007];</span><br><span class="line">int p[20000007],id = 1,mx = 1,ans = -1;</span><br><span class="line"></span><br><span class="line">int init()&#123;</span><br><span class="line">s2[0] = &apos;$&apos;;</span><br><span class="line">s2[1] = &apos;#&apos;;</span><br><span class="line">int j = 2;</span><br><span class="line">int len = strlen(s1);</span><br><span class="line">for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">s2[j++] = s1[i];</span><br><span class="line">s2[j++] = &apos;#&apos;;</span><br><span class="line">&#125;</span><br><span class="line">s2[j] = &apos;\0&apos;;</span><br><span class="line">return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">memset(p,0,sizeof(p));</span><br><span class="line">cin&gt;&gt;s1;</span><br><span class="line">int len = init();</span><br><span class="line">for(int i = 1;i&lt;len;i++)&#123;</span><br><span class="line">if(i &lt; mx) p[i] = min(p[2 * id - 1],mx - i);</span><br><span class="line">else p[i] = 1;</span><br><span class="line">while(s2[i - p[i]] == s2[i + p[i]])&#123;</span><br><span class="line">p[i] ++;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,p[i] - 1);</span><br><span class="line">if(mx &lt; i + p[i])&#123;</span><br><span class="line">id = i;</span><br><span class="line">mx = i + p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;对于字符串$ S $,其前缀为$ pre(s,r) = s[0…r] $,后缀为$ suf(s,r
      
    
    </summary>
    
      <category term="ICPC" scheme="http://decision01.cn/categories/ICPC/"/>
    
    
      <category term="C/C++" scheme="http://decision01.cn/tags/C-C/"/>
    
      <category term="ICPC" scheme="http://decision01.cn/tags/ICPC/"/>
    
      <category term="字符串" scheme="http://decision01.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>CodeforcesRound541Div2解题记录</title>
    <link href="http://decision01.cn/2019/03/13/CodeforcesRound541Div2%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://decision01.cn/2019/03/13/CodeforcesRound541Div2解题记录/</id>
    <published>2019-03-13T09:22:15.000Z</published>
    <updated>2019-05-13T13:14:21.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A. Sea Battle<br>给出四个整数w1,h1,w2,h2 计算在方格上围出w1<em>h1与w2</em>h2的方形所需要的方块的数量</p></blockquote><p><code>数学</code><br>显然ans = (max(w1,w2)+h1+h2+2) * 2，凹入的部分可以换到方形凸出的地方，使得两个方形被围住</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int w1,h1,w2,h2,ans;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;w1&gt;&gt;h1&gt;&gt;w2&gt;&gt;h2;</span><br><span class="line">ans = (max(w1,w2)+h1+h2+2) * 2;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>B. Draw!<br>给出n个数对，对应某个时刻的比分，输出最大的平局的次数6</p></blockquote><p>对于数对(a,b)和数对(c,d)，要平局次数最大，则中间可能出现(x,x)是最好的，而x小于c,d中最小的，大于a,b中最大的，所以取平均值，如果a，b不相等，则可能出现x = min(a,b)的情况，有1的贡献，所以每次输入的时候，ans = ans + max(0,min(c,d) - max(a,b) + (a!=b))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int n,a[10007],b[10007],ans = 1;</span><br><span class="line">int tmp1,tmp2;</span><br><span class="line">int main()&#123;</span><br><span class="line">mst(a,0);</span><br><span class="line">mst(b,0);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i =  1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">tmp1 = max(a[i-1],b[i-1]);</span><br><span class="line">tmp2 = min(a[i],b[i]);</span><br><span class="line">ans+= max(0,tmp2-tmp1+(a[i-1]!=b[i-1]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C. Birthday<br>Vlad过生日有n个朋友，要让这n个朋友围成一圈使得他每个人与相邻两个人之间的高度差距最小<br>输入n与他们的高度，输出最优的序列</p></blockquote><p><code>贪心</code><br>要让高度差距最小，可以把高的尽量凑在一起，然后向两边递减即可<br>排序一次，分为两个数组，依次输出即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int n,a[200];</span><br><span class="line">vector&lt;int&gt; t1,t2;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">for(int i = 0;i&lt;n;i+=2)&#123;</span><br><span class="line">t1.push_back(a[i]);</span><br><span class="line">if(i+1 &gt;= n) break;</span><br><span class="line">t2.push_back(a[i+1]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0;i&lt;t1.size();i++)&#123;</span><br><span class="line">if(i==0) cout&lt;&lt;t1[i];</span><br><span class="line">else cout&lt;&lt;&quot; &quot;&lt;&lt;t1[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = t2.size() -1 ;i&gt;=0;i--) cout&lt;&lt;&quot; &quot;&lt;&lt;t2[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>D. Gourmet choice<br>第一天有n个菜，第二天有m个菜，給一个n*m矩阵，含有“&gt;”、“=”、“&lt;”，a（i，j）指的是：第一天的第i件菜的美味度&gt;=&lt;第二天的第j件菜的美味度。求出满足这个矩阵的n+m件菜的各自的美味度，要求使用的最大数字尽量小。</p></blockquote><p><code>并查集 + 拓扑排序</code><br>将相等的视为同一元素放入并查集，按照对应关系进行建图，然后拓扑排序，数字依照bfs的顺序依次递增</p><p>拓扑排序：<br><a href="https://www.cnblogs.com/en-heng/p/5085690.html" target="_blank" rel="noopener">https://www.cnblogs.com/en-heng/p/5085690.html</a><br><a href="https://blog.csdn.net/qq_41713256/article/details/80805338" target="_blank" rel="noopener">https://blog.csdn.net/qq_41713256/article/details/80805338</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">int fa[3000],n,m,in[3000],ans[3000];</span><br><span class="line">char str[1007][1007];</span><br><span class="line">vector&lt;int&gt; G[3007];</span><br><span class="line"></span><br><span class="line">int tfind(int x)&#123;</span><br><span class="line">return x == fa[x]?x:fa[x] = tfind(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool toposort()&#123;</span><br><span class="line">mst(ans,0);</span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line">for(int i = 1;i&lt;=n+m;i++) if(tfind(i) == i &amp;&amp; in[tfind(i)] == 0) Q.push(tfind(i)),ans[tfind(i)] = 1;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">int u = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">for(int i = 0;i&lt;G[u].size();i++)&#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">in[v]--;</span><br><span class="line">if(in[v] == 0) Q.push(v),ans[v] = ans[u] + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i&lt;=n+m;i++) if(!ans[tfind(i)]) return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Addedge(int u,int v)&#123;</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">in[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i = 1;i&lt;=n+m;i++) fa[i] = i;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;str[i];</span><br><span class="line">for(int j = 0;j&lt;m;j++)&#123;</span><br><span class="line">if(str[i][j] == &apos;=&apos;)&#123;</span><br><span class="line">int x = tfind(i),y = tfind(n+j+1);</span><br><span class="line">fa[x] = y; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j = 0;j&lt;m;j++)&#123;</span><br><span class="line">if(str[i][j] == &apos;&lt;&apos;) Addedge(tfind(i),tfind(n+j+1));</span><br><span class="line">else if(str[i][j] == &apos;&gt;&apos;) Addedge(tfind(n+j+1),tfind(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(!toposort())&#123;</span><br><span class="line">cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">for(int i = 1;i&lt;=n;i++) cout&lt;&lt;ans[tfind(i)]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">for(int i = n+1;i&lt;=n+m;i++) cout&lt;&lt;ans[tfind(i)]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>E. String Multiplication<br>定义字符串s与字符串t的乘法操作，s·t所得字符串为将s的每个字符分开，然后t插入到空隙中<br>现在要输入n个字符串，输出这n个字符串相乘后得到的字符串中最大连续的字符有多少个</p></blockquote><p><code>贪心</code><br>可以从第一个字符串开始推导，在字符串相乘的过程中，主要检查后面相乘的字符串的前缀与后缀，然后进行转移，相当于将前面的字符串拆开然后逐个放入，主要查询字母中答案最大的即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int n,f[100007][26],pre[26],suf[26],ans = 0;</span><br><span class="line">char s[100007];</span><br><span class="line"></span><br><span class="line">void Solve(int *f)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int l = strlen(s);</span><br><span class="line">int mx = 0,cnt = 0;</span><br><span class="line">for(int i = 0;i&lt;26;i++)&#123;</span><br><span class="line">mx = cnt = 0;</span><br><span class="line">for(int j = 0;j&lt;l;j++)&#123;</span><br><span class="line">if(s[j] == i + &apos;a&apos;) mx = max(mx,++cnt);</span><br><span class="line">else cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">f[i] = mx,pre[i] = suf[i] = 0;</span><br><span class="line">for(int j = 0;j&lt;l;j++)&#123;</span><br><span class="line">if(s[j] == i + &apos;a&apos;) pre[i]++;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = l-1;j&gt;=0;j--)&#123;</span><br><span class="line">if(s[j] == i + &apos;a&apos;) suf[i]++;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">mst(f,0);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">Solve(f[1]);</span><br><span class="line">for(int i = 2;i&lt;=n;i++)&#123;</span><br><span class="line">Solve(f[i]);</span><br><span class="line">int l = strlen(s);</span><br><span class="line">for(int j = 0;j&lt;26;j++)&#123;</span><br><span class="line">if(f[i - 1][j])&#123;</span><br><span class="line">if(pre[j]!=l) f[i][j] = max(f[i][j],pre[j]+suf[j]+1);</span><br><span class="line">else f[i][j] = max(f[i][j],l*(f[i-1][j]+1)+ f[i-1][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0;i&lt;26;i++) ans = max(ans,f[n][i]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>F. Asya And Kittens<br>Asya有n只猫，要把它们关在n个笼子里，在第i天第a<sub>i</sub>和第b<sub>i</sub>两只小猫想要玩耍，Asya就要把它们之间的挡板拆掉<br>但是现在Asya忘了一开始每只小猫是在哪个笼子里面了，但是她记得每天的a<sub>i</sub>、b<sub>i</sub>，所以请输出可能的笼子的安排</p></blockquote><p><code>并查集</code><br>每次合并的猫并不是一定相邻，而是在合并之前在不同的笼子里面相邻，即不同的连通块中，所以考虑用并查集而不是对连通图的重建，n-1条边的连通图重建不能保证每个点都只有两个出点，所以用并查集进行模拟合并<br>为了输出对应的顺序，用r数组和son数组进行操作，相当于按照合并顺序将每个数字串起来，最后依次输出son数组即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int fa[150007],son[150007],r[150007],n,a,b;</span><br><span class="line"></span><br><span class="line">int tfind(int x)&#123;</span><br><span class="line">return x==fa[x]?x:(fa[x] = tfind(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i = 1;i&lt;=n;i++) fa[i] = r[i] = i;</span><br><span class="line">for(int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a = tfind(a);</span><br><span class="line">b = tfind(b);</span><br><span class="line">son[r[a]] = b;</span><br><span class="line">r[a] = r[b];</span><br><span class="line">fa[b] = a;</span><br><span class="line">&#125;</span><br><span class="line">int tmp = tfind(1);</span><br><span class="line">cout&lt;&lt;tmp;</span><br><span class="line">for(int i = son[tmp];i;i = son[i]) cout&lt;&lt;&quot; &quot;&lt;&lt;i;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>G. Most Dangerous Shark<br>从左到右依次有n个Domino骨牌，手动推倒第i个骨牌的花费为c<sub>i</sub>，每个骨牌之间的距离为1，第i个骨牌的高度为h<sub>i</sub>，可以选择向右或向左推到这个骨牌，它将会压倒该方向上距离它小于h<sub>i</sub>的所有骨牌，求推倒所有骨牌的最小消费</p></blockquote><p><code>copy</code><br><code>单调栈</code>  <code>DP</code><br><a href="https://www.cnblogs.com/TinyWong/p/10427161.html" target="_blank" rel="noopener">https://www.cnblogs.com/TinyWong/p/10427161.html</a><br>令L[i],R[i]分别表示第i个骨牌向左（右）推倒后，会将(L[i],i]（[i,R[i])）区间内的骨牌推倒。这个可以用单调栈在O(n)时间内解决。<br>令f[i]表示（只通过推倒前i个骨牌来）推倒前i个骨牌的最小花费，则对1≤i≤n，<br>$f[i]=min(f[L[i]]+ci,minj&lt;i&lt;R[j]{f[j−1]+cj})$<br>这个动态规划也能用单调栈在O(n)时间内解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A. Sea Battle&lt;br&gt;给出四个整数w1,h1,w2,h2 计算在方格上围出w1&lt;em&gt;h1与w2&lt;/em&gt;h2的方形所需要的方块的数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;数学&lt;/code&gt;&lt;br&gt;显然ans = (m
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://decision01.cn/categories/Codeforces/"/>
    
    
      <category term="C/C++" scheme="http://decision01.cn/tags/C-C/"/>
    
      <category term="Codeforces" scheme="http://decision01.cn/tags/Codeforces/"/>
    
      <category term="ICPC" scheme="http://decision01.cn/tags/ICPC/"/>
    
  </entry>
  
</feed>
