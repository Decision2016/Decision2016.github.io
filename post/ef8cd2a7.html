<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UESTC暑假前集训—图论-解题报告 | Decision`s blog</title><meta name="author" content="Solan"><meta name="copyright" content="Solan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="A - 迷宫 给出一个带权有向图，翻转一条边的代价是其权重，求出翻转边后图中无环的最小代价  二分 拓扑判环一开始只能想到要让图中没有环，但是想不清楚怎么操作，于是等到题解emmmm考虑对于要改变的边，相当于删去之后反向加回来，那么代价就是边里面权值最大的二分权值，权值越大的可以改变的边越多，二分最少的代价使得不存在环即可 1234567891011121314151617181920212223">
<meta property="og:type" content="article">
<meta property="og:title" content="UESTC暑假前集训—图论-解题报告">
<meta property="og:url" content="https://decision01.com/post/ef8cd2a7.html">
<meta property="og:site_name" content="Decision&#96;s blog">
<meta property="og:description" content="A - 迷宫 给出一个带权有向图，翻转一条边的代价是其权重，求出翻转边后图中无环的最小代价  二分 拓扑判环一开始只能想到要让图中没有环，但是想不清楚怎么操作，于是等到题解emmmm考虑对于要改变的边，相当于删去之后反向加回来，那么代价就是边里面权值最大的二分权值，权值越大的可以改变的边越多，二分最少的代价使得不存在环即可 1234567891011121314151617181920212223">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picsum.photos/seed/graph/700/400">
<meta property="article:published_time" content="2019-06-02T13:16:20.000Z">
<meta property="article:modified_time" content="2024-12-24T15:03:44.719Z">
<meta property="article:author" content="Solan">
<meta property="article:tag" content="图论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picsum.photos/seed/graph/700/400"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UESTC暑假前集训—图论-解题报告",
  "url": "https://decision01.com/post/ef8cd2a7.html",
  "image": "https://picsum.photos/seed/graph/700/400",
  "datePublished": "2019-06-02T13:16:20.000Z",
  "dateModified": "2024-12-24T15:03:44.719Z",
  "author": [
    {
      "@type": "Person",
      "name": "Solan",
      "url": "https://decision01.com"
    }
  ]
}</script><link rel="shortcut icon" href="/../images/favicon.png"><link rel="canonical" href="https://decision01.com/post/ef8cd2a7.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XW1NY371N2"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XW1NY371N2')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XW1NY371N2', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UESTC暑假前集训—图论-解题报告',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Decision`s blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://s.gravatar.com/avatar/d3c332e47b56134bab228c086c6578d5?s=250" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://gallery.decision01.com/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://en.decision01.com"><i class="fa-fw fas fa-language"></i><span> English</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://picsum.photos/seed/graph/700/400);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Decision`s blog</span></a><a class="nav-page-title" href="/"><span class="site-name">UESTC暑假前集训—图论-解题报告</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://gallery.decision01.com/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://en.decision01.com"><i class="fa-fw fas fa-language"></i><span> English</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">UESTC暑假前集训—图论-解题报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-06-02T13:16:20.000Z" title="发表于 2019-06-02 21:16:20">2019-06-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T15:03:44.719Z" title="更新于 2024-12-24 23:03:44">2024-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/ef8cd2a7.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/ef8cd2a7.html" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:100,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2024-12-24 23:03:44&quot;}" hidden></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h5 id="A-迷宫"><a href="#A-迷宫" class="headerlink" title="A - 迷宫"></a>A - 迷宫</h5><blockquote>
<p>给出一个带权有向图，翻转一条边的代价是其权重，求出翻转边后图中无环的最小代价</p>
</blockquote>
<p><code>二分</code> <code>拓扑判环</code><br>一开始只能想到要让图中没有环，但是想不清楚怎么操作，于是等到题解emmmm<br>考虑对于要改变的边，相当于删去之后反向加回来，那么代价就是边里面权值最大的<br>二分权值，权值越大的可以改变的边越多，二分最少的代价使得不存在环即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line">ll w;</span><br><span class="line"><span class="type">int</span> top[maxn],in[maxn];</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll now)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) edges[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">mst</span>(in,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mst</span>(top,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G1[i].dist &gt; now)&#123;</span><br><span class="line">			edges[G1[i].from].<span class="built_in">push_back</span>(G1[i].to);</span><br><span class="line">			in[G1[i].to] ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(in[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i),top[i] = ++cnt;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> len = edges[u].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> v = edges[u][i];</span><br><span class="line">			in[v] --;</span><br><span class="line">			<span class="keyword">if</span>(!in[v]) q.<span class="built_in">push</span>(v),top[v] = ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(in[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		G1.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">	&#125;</span><br><span class="line">	ll l = <span class="number">0</span>,r = <span class="number">2e9</span>,mid,ans;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">			r = mid - <span class="number">1</span>;</span><br><span class="line">			ans = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="B-oydy的征途I"><a href="#B-oydy的征途I" class="headerlink" title="B - oydy的征途I"></a>B - oydy的征途I</h5><blockquote>
<p>给定一个带权无向图，求出最小生成树但是其中某一条边可以0权值，已经可能的最小权值和的总数</p>
</blockquote>
<p><code>最小生成树</code><br>先求出最小生成树，把最大权的边删去之后，求剩下的边的连通性<br>时间复杂度$ O(mlogm) $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> u,v,cnt,maxx = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">ll sum = <span class="number">0</span>,w;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">tfind</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">	cnt = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(G.<span class="built_in">begin</span>(),G.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		u = G[i].from,v = G[i].to;</span><br><span class="line">		u = <span class="built_in">tfind</span>(u),v = <span class="built_in">tfind</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(u != v)&#123;</span><br><span class="line">			fa[v] = u;</span><br><span class="line">			cnt --;</span><br><span class="line">			sum += G[i].dist;</span><br><span class="line">			<span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line">				sum -= G[i].dist;</span><br><span class="line">			    maxx = G[i].dist;</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G[i].dist &gt;= maxx) <span class="keyword">break</span>;</span><br><span class="line">		u = G[i].from,v = G[i].to;</span><br><span class="line">		u = <span class="built_in">tfind</span>(u),v = <span class="built_in">tfind</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(u != v)&#123;</span><br><span class="line">			fa[v] = u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G[i].dist &lt; maxx) <span class="keyword">continue</span>;</span><br><span class="line">		u = G[i].from,v = G[i].to;</span><br><span class="line">		u = <span class="built_in">tfind</span>(u),v = <span class="built_in">tfind</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(u != v) ans ++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="C-oydy的征途II"><a href="#C-oydy的征途II" class="headerlink" title="C - oydy的征途II"></a>C - oydy的征途II</h5><blockquote>
<p>给定一个有向图，如果存在欧拉路径的话就输出最小字典序的欧拉路径</p>
</blockquote>
<p><code>欧拉路径</code> <code>手写栈</code><br><del>WA8 WA15 TLE28 </del><br>我就是个弟弟<br>WA8是因为出入栈顺序的问题，WA15是因为地点直接设置成了1，TLE是因为遍历的是邻接表，所以如果存在2e6个1的自环的情况下时间复杂度会达到$ O(m ^ 2) $<br>改成用栈删边之后，时间复杂度降低到$ O(m) $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;Edge&gt; G_;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> in[maxn],out[maxn],beg[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; all;</span><br><span class="line"><span class="type">int</span> n,m,s = <span class="number">0</span>,t = <span class="number">0</span>,flag = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	all.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="built_in">mst</span>(beg,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(!all.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> now = all.<span class="built_in">top</span>();</span><br><span class="line">		<span class="keyword">if</span>(beg[now] == out[now])&#123;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(now);</span><br><span class="line">			all.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> v = G[edges[now][beg[now]]].to;</span><br><span class="line">			beg[now] ++;</span><br><span class="line">			all.<span class="built_in">push</span>(v);</span><br><span class="line">			cnt ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		G_.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(G_.<span class="built_in">begin</span>(),G_.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		G.<span class="built_in">push_back</span>(G_[i]);</span><br><span class="line">		edges[G_[i].from].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		out[G_[i].from] ++;</span><br><span class="line">		in[G_[i].to] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i] == out[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(out[i] - in[i] == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s == <span class="number">0</span>) s = i;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(in[i] - out[i] == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t == <span class="number">0</span>) t = i;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="number">0</span> &amp;&amp; t == <span class="number">0</span> &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(out[i] != <span class="number">0</span>)&#123;s = i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(s != <span class="number">0</span> &amp;&amp; t != <span class="number">0</span> &amp;&amp; flag == <span class="number">0</span>) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;What a shame!&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt != m)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;What a shame!&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = ans.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="D-oydy的征途III"><a href="#D-oydy的征途III" class="headerlink" title="D - oydy的征途III"></a>D - oydy的征途III</h5><blockquote>
<p>给定一个带权无向图，从第一个点开始，求出到一个序列的点的最短距离</p>
</blockquote>
<p><code>最短路</code> <code>树链剖分</code> `<br>除去树之后多出来的边比较少，所以先把树拿出来求树上距离，再跑出剩下30条边的端点到其他点的最短路<br>每次询问取经过剩下的边上的端点距离和树上距离<br>树上距离我直接扒了一棵生成树下来树剖<br>时间复杂度$ O(30(n + m)logn + nlogn) $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	ll l,r;</span><br><span class="line">	ll sum;</span><br><span class="line">&#125;tr[maxn * <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll u;</span><br><span class="line">	ll d;</span><br><span class="line">	<span class="built_in">node</span>(ll uu,ll dd):<span class="built_in">u</span>(uu),<span class="built_in">d</span>(dd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G1,G2,G;</span><br><span class="line">vector&lt;ll&gt; edges1[maxn],edges2[maxn];</span><br><span class="line">ll fa[maxn],siz[maxn],dep[maxn],minn[maxn],son[maxn],pos[maxn],top[maxn];</span><br><span class="line">ll dist[<span class="number">65</span>][maxn];</span><br><span class="line">ll mn[maxn],tid = <span class="number">0</span>,f[maxn];</span><br><span class="line"></span><br><span class="line">ll n,m,cnt = <span class="number">0</span>;</span><br><span class="line">ll from,to;</span><br><span class="line">ll dis;</span><br><span class="line">ll t,nxt,now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tfind</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == f[x] ? x : (f[x] = <span class="built_in">tfind</span>(f[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll pre,ll deep)</span></span>&#123;</span><br><span class="line">	fa[now] = pre;</span><br><span class="line">	siz[now]++;</span><br><span class="line">	dep[now] = deep;</span><br><span class="line">	ll len = edges2[now].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		ll v = G2[edges2[now][i]].to;</span><br><span class="line">		<span class="keyword">if</span>(v == pre) <span class="keyword">continue</span>;</span><br><span class="line">		minn[v] = G2[edges2[now][i]].dist;</span><br><span class="line">		<span class="built_in">dfs1</span>(v,now,deep+<span class="number">1</span>);</span><br><span class="line">		siz[now] += siz[v];</span><br><span class="line">		<span class="keyword">if</span>(son[now] == <span class="number">-1</span> || siz[son[now]] &lt; siz[v]) son[now] = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll chain)</span></span>&#123;</span><br><span class="line">	pos[now] = tid++;</span><br><span class="line">	top[now] = chain;</span><br><span class="line">	mn[pos[now]] = minn[now];</span><br><span class="line">	ll len = edges2[now].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(son[now] == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[now],chain); </span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		ll v = G2[edges2[now][i]].to;</span><br><span class="line">		<span class="keyword">if</span>(v != fa[now] &amp;&amp; v != son[now])&#123;</span><br><span class="line">			<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line">	tr[k].l = l;</span><br><span class="line">	tr[k].r = r;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		tr[k].sum = mn[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">	tr[k].sum = tr[k&lt;&lt;<span class="number">1</span>].sum+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll s,ll t,ll l,ll r,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == l&amp;&amp; t == r)&#123;</span><br><span class="line">		<span class="keyword">return</span> tr[k].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(t &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(s,t,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(s,t,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(s,mid,l,mid,k&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(mid + <span class="number">1</span>,t,mid + <span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll s,ll t)</span></span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	ll chain1 = top[s],chain2 = top[t];</span><br><span class="line">	<span class="keyword">while</span>(chain1 != chain2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[chain1] &lt; dep[chain2]) <span class="built_in">swap</span>(chain1,chain2),<span class="built_in">swap</span>(s,t);</span><br><span class="line">		<span class="keyword">if</span>(chain1 == <span class="number">1</span>) ans += <span class="built_in">query</span>(pos[chain1] + <span class="number">1</span>,pos[s],<span class="number">1</span>,tid - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> ans += <span class="built_in">query</span>(pos[chain1],pos[s],<span class="number">1</span>,tid<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">		s = fa[chain1];</span><br><span class="line">		chain1 = top[s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s == t) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">if</span>(dep[s] &gt; dep[t]) <span class="built_in">swap</span>(s,t);</span><br><span class="line">	ans += <span class="built_in">query</span>(pos[son[s]],pos[t],<span class="number">1</span>,tid - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(ll s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++) dist[cnt][i] = INF;</span><br><span class="line">	<span class="type">bool</span> vis[maxn];</span><br><span class="line">    <span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(s,<span class="number">0</span>));</span><br><span class="line">    dist[cnt][s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    	node now = q.<span class="built_in">top</span>();</span><br><span class="line">    	q.<span class="built_in">pop</span>();</span><br><span class="line">    	ll u = now.u;</span><br><span class="line">    	<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    	vis[u] = <span class="number">1</span>;</span><br><span class="line">    	ll len = edges1[u].<span class="built_in">size</span>();</span><br><span class="line">    	<span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    		ll v = G1[edges1[u][i]].to;</span><br><span class="line">    		<span class="keyword">if</span>(dist[cnt][v] &gt; G1[edges1[u][i]].dist +  dist[cnt][u])&#123;</span><br><span class="line">    			dist[cnt][v] = G1[edges1[u][i]].dist +  dist[cnt][u];</span><br><span class="line">    			q.<span class="built_in">push</span>(<span class="built_in">node</span>(v,dist[cnt][v]));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++) f[i] = i;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to&gt;&gt;dis;</span><br><span class="line">		ll a = <span class="built_in">tfind</span>(from),b = <span class="built_in">tfind</span>(to);</span><br><span class="line">		G1.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from,to,dis));</span><br><span class="line">		G1.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to,from,dis));</span><br><span class="line">		edges1[from].<span class="built_in">push_back</span>(G1.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">		edges1[to].<span class="built_in">push_back</span>(G1.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">		    G2.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from,to,dis));</span><br><span class="line">		    G2.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to,from,dis));</span><br><span class="line">		    edges2[from].<span class="built_in">push_back</span>(G2.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">		    edges2[to].<span class="built_in">push_back</span>(G2.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		    f[b] = a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from,to,dis));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mst</span>(son,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,tid - <span class="number">1</span>);</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	ll l = G.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">		<span class="built_in">dij</span>(G[i].from);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= t;i++)&#123;</span><br><span class="line">		cin&gt;&gt;nxt;</span><br><span class="line">		ll tans = <span class="built_in">Query</span>(now,nxt);</span><br><span class="line">		<span class="keyword">for</span>(ll j = <span class="number">0</span>;j &lt; l;j++)  tans = <span class="built_in">min</span>(tans,dist[j][now] + dist[j][nxt]);</span><br><span class="line">		ans += tans;</span><br><span class="line">		now = nxt;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="E-变色龙"><a href="#E-变色龙" class="headerlink" title="E - 变色龙"></a>E - 变色龙</h5><blockquote>
<p>给定$ n $个点，$ m $条边，每条边都有颜色，求出从1号点到$ n $号点所需要变换颜色最多的次数</p>
</blockquote>
<p><code>以边代点</code> <code>拆点</code><br>一开始能想到的只有将一条边经过一个点到另外一条边考虑成从一个点到另外一个点，如果颜色相同的两个点的权值就是0，反之为1<br>但是遇到菊花图的时候空间复杂度是$ O(m^2) $，如不存边的话时间复杂度又会变成$ O(m^2) $<br>于是看了题解知道要拆点QAQ，用<code>map</code>把空间复杂度降到$ O(m + n) $，跑一遍dijkstra求最短路再除2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; node;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn*<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u,w));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">	edges[v].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> color)</span></span>&#123;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; tmp1,tmp2;</span><br><span class="line">	tmp1.first = u;</span><br><span class="line">	tmp1.second = color;</span><br><span class="line">	tmp2.first = v;</span><br><span class="line">	tmp2.second = color;</span><br><span class="line">	<span class="keyword">if</span>(node[tmp1] == <span class="number">0</span>) node[tmp1] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span>(node[tmp2] == <span class="number">0</span>) node[tmp2] = ++cnt;</span><br><span class="line">	<span class="built_in">addedge</span>(u,node[tmp1],<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">addedge</span>(node[tmp1],node[tmp2],<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">addedge</span>(node[tmp2],v,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;Node&gt; q;</span><br><span class="line">	<span class="type">bool</span> vis[cnt + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> dist[cnt + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) dist[i] = INF;</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">1</span>,dist[<span class="number">0</span>]));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		Node now = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> u = now.u;</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> len = edges[u].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> v = G[edges[u][i]].to;</span><br><span class="line">			<span class="keyword">if</span>(dist[v] &gt; dist[u] + G[edges[u][i]].dist)&#123;</span><br><span class="line">				dist[v] = dist[u] + G[edges[u][i]].dist;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">Node</span>(v,dist[v]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist[n] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> u,v,color;</span><br><span class="line">	cnt = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;color;</span><br><span class="line">		<span class="built_in">add</span>(u,v,color);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">dij</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="F-zh吃饭"><a href="#F-zh吃饭" class="headerlink" title="F -     zh吃饭"></a>F -     zh吃饭</h5><blockquote>
<p>给出一个有向图，求经过每个边权后到达某个点集内的点总的最大的边权和</p>
</blockquote>
<p><code>tarjan</code> <code>缩点</code><br>tarjan求强连通分量直接缩点重新建图跑最长路，找了以前写的缩点的代码直接粘上来<del>嘿嘿嘿</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,tmp,s,p;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>,sum = <span class="number">0</span>,top = <span class="number">0</span>,dfn[maxn],low[maxn],instack[maxn],q[maxn],fa[maxn],dis[maxn];</span><br><span class="line"><span class="type">int</span> dist[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> w[maxn];</span><br><span class="line">vector&lt;Edge&gt; G,G2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn],edges2[maxn],all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	G2.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v));</span><br><span class="line">	edges2[u].<span class="built_in">push_back</span>(G2.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	cnt ++;</span><br><span class="line">	top ++;</span><br><span class="line">	dfn[x] = low[x] = cnt;</span><br><span class="line">	q[top] = x;</span><br><span class="line">	instack[x] = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> len = edges[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v = G[edges[x][i]].to;</span><br><span class="line">		<span class="keyword">if</span>(dfn[v] == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) low[x] = <span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x] == low[x])&#123;</span><br><span class="line">		sum++;</span><br><span class="line">		<span class="keyword">while</span>(q[top + <span class="number">1</span>] != x)&#123;</span><br><span class="line">			<span class="type">int</span> s = q[top];</span><br><span class="line">			top--;</span><br><span class="line">			instack[s] = <span class="number">0</span>;</span><br><span class="line">			fa[s] = sum;</span><br><span class="line">			dis[sum] += w[s];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(fa[s]);</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mst</span>(dist,<span class="number">0</span>);</span><br><span class="line">	dist[fa[s]] = dis[fa[s]];</span><br><span class="line">	vis[fa[s]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">		<span class="type">int</span> len = edges2[now].<span class="built_in">size</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[now] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> v = G2[edges2[now][i]].to;</span><br><span class="line">			<span class="keyword">if</span>(dist[v] &lt; dist[now] + dis[v])&#123;</span><br><span class="line">				dist[v] = dist[now] + dis[v];</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="built_in">Addedge</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin&gt;&gt;w[i];</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= p;i++) &#123;</span><br><span class="line">    	cin&gt;&gt;tmp;</span><br><span class="line">    	all.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    	u = G[i].from;</span><br><span class="line">    	v = G[i].to;</span><br><span class="line">    	<span class="keyword">if</span>(fa[u] != fa[v]) <span class="built_in">Addedge2</span>(fa[u],fa[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; p;i++) ans = <span class="built_in">max</span>(ans,dist[fa[all[i]]]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="G-hqf吹泡泡"><a href="#G-hqf吹泡泡" class="headerlink" title="G - hqf吹泡泡"></a>G - hqf吹泡泡</h5><blockquote>
<p>给定$ n $个点，有$ m $ 种连接关系，表示$ u $、$ v $两个点连接所需要的代价是$ w $，要求最少的将所有点连接成$ k $块所需要的代价</p>
</blockquote>
<p><code>最小生成树</code><br>本来能1A的一个题结果手太抖了错失一血。。<br>直接用最小生成树的算法，每连接一次就减去当前块数的数量，然后减到k的时候结束输出答案<br>时间复杂度$ O(nlogn) $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ll n,m,k,tt = <span class="number">0</span>;</span><br><span class="line">ll cnt;</span><br><span class="line"><span class="type">int</span> fa[maxn],siz[maxn],vis[maxn];</span><br><span class="line">vector&lt;Edge&gt; all;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? fa[x] : (fa[x] = <span class="built_in">tfind</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	cnt = n;</span><br><span class="line">	<span class="built_in">mst</span>(siz,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		all.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(all.<span class="built_in">begin</span>(),all.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> len = all.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span>(cnt != k &amp;&amp; tt &lt; len)&#123;</span><br><span class="line">		Edge now = all[tt];</span><br><span class="line">		tt++;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">tfind</span>(now.from),b = <span class="built_in">tfind</span>(now.to);</span><br><span class="line">		<span class="keyword">if</span>(a == b) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(siz[a] &gt;= siz[b])&#123;</span><br><span class="line">				siz[a] += siz[b];</span><br><span class="line">				ans += now.dist;</span><br><span class="line">				fa[b] = a;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				siz[b] += siz[a];</span><br><span class="line">				ans += now.dist;</span><br><span class="line">				fa[a] = b;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="H-毁灭东湖计划"><a href="#H-毁灭东湖计划" class="headerlink" title="H - 毁灭东湖计划"></a>H - 毁灭东湖计划</h5><blockquote>
<p>给定一个有向图，求出从1到n的最大流量</p>
</blockquote>
<p><code>网络瘤</code><br>网络瘤板题，抄了紫书的EK板子(逃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn];</span><br><span class="line">ll a[maxn],p[maxn],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll cap)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,cap,<span class="number">0</span>));</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">	edges[v].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Maxflow</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="built_in">mst</span>(a,<span class="number">0</span>);</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">		q.<span class="built_in">push</span>(s);</span><br><span class="line">		a[s] = INF;</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">int</span> len = edges[now].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">				Edge&amp; e = G[edges[now][i]];</span><br><span class="line">				<span class="keyword">if</span>(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123;</span><br><span class="line">					p[e.to] = edges[now][i];</span><br><span class="line">					a[e.to] = <span class="built_in">min</span>(a[now], e.cap - e.flow);</span><br><span class="line">					q.<span class="built_in">push</span>(e.to);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a[t]) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!a[t]) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u = t;u != s;u = G[p[u]].from)&#123;</span><br><span class="line">			G[p[u]].flow += a[t];</span><br><span class="line">			G[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">		&#125;</span><br><span class="line">		res += a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,n,m;</span><br><span class="line">	ll c;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;</span><br><span class="line">		<span class="built_in">Addedge</span>(u,v,c);</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">Maxflow</span>(<span class="number">1</span>,n);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="I-cxx仙女下凡"><a href="#I-cxx仙女下凡" class="headerlink" title="I -  cxx仙女下凡"></a>I -  cxx仙女下凡</h5><blockquote>
<p>给出一个有向图，求出其中从$ s $到$ t $第$ k $短的路径长度</p>
</blockquote>
<p><code>k短路</code> <code>A*</code><br>k短路模板题，先spfa求出其他点到t最短的路径长度，用A*的估价函数进行估值然后拓展，第k次经过的时候就是第k短路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos,d,f;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(f == a.f) <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">		<span class="keyword">return</span> f &gt; a.f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,s,t;</span><br><span class="line">ll dist[maxn];</span><br><span class="line">vector&lt;Edge&gt; G,G2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn],edges2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,w));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	G2.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u,w));</span><br><span class="line">	edges2[v].<span class="built_in">push_back</span>(G2.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="type">bool</span> vis[maxn];</span><br><span class="line">	q.<span class="built_in">push</span>(start);</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	vis[start] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dist[i] = INF;</span><br><span class="line">	dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    	<span class="type">int</span> now = q.<span class="built_in">front</span>(),len = edges2[now].<span class="built_in">size</span>();</span><br><span class="line">    	q.<span class="built_in">pop</span>();</span><br><span class="line">    	vis[now] = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    		<span class="type">int</span> v = G2[edges2[now][i]].to;</span><br><span class="line">    		<span class="keyword">if</span>(dist[v] &gt; dist[now] + G2[edges2[now][i]].dist)&#123;</span><br><span class="line">    			dist[v] = dist[now] + G2[edges2[now][i]].dist;</span><br><span class="line">    			<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">    				vis[v] = <span class="number">1</span>;</span><br><span class="line">    				q.<span class="built_in">push</span>(v);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Get_k</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dist[s] == INF) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	node now,nxt;</span><br><span class="line">	now.pos = s;</span><br><span class="line">	now.d = <span class="number">0</span>;</span><br><span class="line">	now.f = dist[s];</span><br><span class="line">	q.<span class="built_in">push</span>(now);</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		now = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(now.pos == t) cnt++;</span><br><span class="line">		<span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> now.d;</span><br><span class="line">		<span class="type">int</span> len = edges[now.pos].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> v = G[edges[now.pos][i]].to;</span><br><span class="line">			nxt.d = now.d + G[edges[now.pos][i]].dist;</span><br><span class="line">			nxt.f = nxt.d + dist[v];</span><br><span class="line">			nxt.pos = v;</span><br><span class="line">			q.<span class="built_in">push</span>(nxt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	ll d;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;d;</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spfa</span>(t);</span><br><span class="line">	ll ans = <span class="built_in">Get_k</span>();</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="J-cxx守株待兔"><a href="#J-cxx守株待兔" class="headerlink" title="J - cxx守株待兔"></a>J - cxx守株待兔</h5><blockquote>
<p>给出一个二分图，求最大匹配</p>
</blockquote>
<p><code>匈牙利</code> <code>网络瘤</code><br>把二分图的两边加一个超级源点和一个超级汇点，然后跑一下网络流（<br>一开始以为EK会被卡就套了Dinic的板子，结果试了一下EK也可以过。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="type">int</span> n,s,t,cap;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn],cur[maxn];</span><br><span class="line">ll a[maxn],p[maxn],ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> l,r,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll cap)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,cap,<span class="number">0</span>));</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">	edges[v].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> len = edges[now].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">			Edge &amp;e = G[edges[now][i]];</span><br><span class="line">			<span class="keyword">if</span>(!vis[e.to]&amp;&amp;e.cap &gt; e.flow)&#123;</span><br><span class="line">				vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				d[e.to] = d[now] + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(e.to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	ll flow = <span class="number">0</span>,f;</span><br><span class="line">	<span class="type">int</span> len = edges[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = cur[x];i &lt;len;i++)&#123;</span><br><span class="line">		Edge &amp;e = G[edges[x][i]];</span><br><span class="line">		<span class="keyword">if</span>(d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to,<span class="built_in">min</span>(a,e.cap - e.flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			e.flow += f;</span><br><span class="line">			G[edges[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">			flow += f;</span><br><span class="line">			a -= f;</span><br><span class="line">			<span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">		<span class="built_in">mst</span>(cur,<span class="number">0</span>);</span><br><span class="line">		flow += <span class="built_in">dfs</span>(s,INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r&gt;&gt;m;</span><br><span class="line">	s = <span class="number">0</span>,t = l + r + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= l;i++) <span class="built_in">Addedge</span>(s,i,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">1</span>;i &lt;= l + r;i++) <span class="built_in">Addedge</span>(i,t,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="built_in">Addedge</span>(u,v + l,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Maxflow</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="K-cxx承包鱼塘"><a href="#K-cxx承包鱼塘" class="headerlink" title="K - cxx承包鱼塘"></a>K - cxx承包鱼塘</h5><blockquote>
<p>给出一个带权无向图，求出最多免费k条边后$ s $到$ t $的最短距离</p>
</blockquote>
<p> <code>分层图</code> <code>DP</code><br> 在<code>dijkstra</code>里面加一个免费这条边的情况下的最短距离，然后类似于动态规划搞一下<br> 时间复杂度$ O((m + n)logn) $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,k,s,t;</span><br><span class="line"><span class="type">int</span> from,to,dis;</span><br><span class="line">ll dist[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="type">bool</span> vis[maxn][<span class="number">30</span>];</span><br><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addegde</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,d));</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u,d));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">	edges[v].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">mst</span>(dist,<span class="number">0x3f3f3f</span>);</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	dist[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">node</span>(s,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node now = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[now.u][now.t]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.u][now.t] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> len = edges[now.u].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">			<span class="type">int</span> v = G[edges[now.u][i]].to;</span><br><span class="line">			<span class="keyword">if</span>(dist[v][now.t] &gt; dist[now.u][now.t] + G[edges[now.u][i]].dist)&#123;</span><br><span class="line">				dist[v][now.t] = dist[now.u][now.t] + G[edges[now.u][i]].dist;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">node</span>(v,now.t,dist[v][now.t]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now.t + <span class="number">1</span> &lt;= k)&#123;</span><br><span class="line">				<span class="keyword">if</span>(dist[v][now.t + <span class="number">1</span>] &gt; dist[now.u][now.t])&#123;</span><br><span class="line">					dist[v][now.t + <span class="number">1</span>] = dist[now.u][now.t];</span><br><span class="line">					q.<span class="built_in">push</span>(<span class="built_in">node</span>(v,now.t + <span class="number">1</span>,dist[v][now.t + <span class="number">1</span>]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to&gt;&gt;dis;</span><br><span class="line">		<span class="built_in">Addegde</span>(from,to,dis);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dij</span>();</span><br><span class="line">	cout&lt;&lt;dist[t][k]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="L-cxx的压岁钱"><a href="#L-cxx的压岁钱" class="headerlink" title="L - cxx的压岁钱"></a>L - cxx的压岁钱</h5><blockquote>
<p>给定n个电视所需要花费的代价，以及选取某几个电视就可以得到的利润，求出最大的利润</p>
</blockquote>
<p><code>最大权闭合子图</code> <code>网络流</code><br>抽象一下，就是选取某一个结点，那么它的后继也要被选取<br>看到题目的时候满脸网络流，但是不知道建模是怎么建的emmm<br>建模的就是将选取的后继的这一边的容量设为无穷大，源点连接的所需要选取的容量为对应利润，后面汇点连接的容量为对应的代价<br>跑出最大流，然后用$ \sum c$减去最大流</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="type">int</span> n,m,s,t,cap;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn],cur[maxn];</span><br><span class="line">ll a[maxn],p[maxn],ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll cap)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v,cap,<span class="number">0</span>));</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">	edges[v].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> len = edges[now].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">			Edge &amp;e = G[edges[now][i]];</span><br><span class="line">			<span class="keyword">if</span>(!vis[e.to]&amp;&amp;e.cap &gt; e.flow)&#123;</span><br><span class="line">				vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				d[e.to] = d[now] + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(e.to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	ll flow = <span class="number">0</span>,f;</span><br><span class="line">	<span class="type">int</span> len = edges[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = cur[x];i &lt;len;i++)&#123;</span><br><span class="line">		Edge &amp;e = G[edges[x][i]];</span><br><span class="line">		<span class="keyword">if</span>(d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to,<span class="built_in">min</span>(a,e.cap - e.flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			e.flow += f;</span><br><span class="line">			G[edges[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">			flow += f;</span><br><span class="line">			a -= f;</span><br><span class="line">			<span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Maxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">		<span class="built_in">mst</span>(cur,<span class="number">0</span>);</span><br><span class="line">		flow += <span class="built_in">dfs</span>(s,INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	s = <span class="number">0</span>;</span><br><span class="line">	t = m + n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;cap;</span><br><span class="line">		<span class="built_in">Addedge</span>(n + i,t,cap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,k;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;k;</span><br><span class="line">		sum += a;</span><br><span class="line">		<span class="built_in">Addedge</span>(s,i,a);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)&#123;</span><br><span class="line">			<span class="type">int</span> v;</span><br><span class="line">			cin&gt;&gt;v;</span><br><span class="line">			<span class="built_in">Addedge</span>(i,v + n,INF);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum - <span class="built_in">Maxflow</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="M-洁姐姐带我找工作"><a href="#M-洁姐姐带我找工作" class="headerlink" title="M - 洁姐姐带我找工作"></a>M - 洁姐姐带我找工作</h5><blockquote>
<p>给出每两个公司的给出的offer数量关系，求出最少的offer数</p>
</blockquote>
<p><code>dfs</code> <code>并查集</code> <code>拓扑排序</code></p>
<p>既然是图论，一开始想到的是建一个有向图表示大于小于关系，但是等于关系想不清楚<br>当时晚上放题的时候还想到了差分约束emmmm<br>然后想到用并查集将等于的点缩在一个点上，但是排序对应点的权值的处理有点问题<br>后来想到的是<code>并查集</code> + <code>拓扑排序</code>，但是拓扑排序排不出来（我是辣鸡<br>那么把大于的建图反向过来，这样方便从1开始处理权值，然后每次选取入度为0的点开始dfs<br>求出每个点对应的深度就是权值，然后每次递归到某一层如果权值已经不为0了就选择最大的一个深度作为权值<br>最后把权值全部加起来就是答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[<span class="number">1007</span>],siz[<span class="number">1007</span>],in[<span class="number">1007</span>],vis[<span class="number">1007</span>],w[<span class="number">1007</span>];</span><br><span class="line"><span class="type">int</span> n,m,op,u,v,ans = <span class="number">0</span>,maxx = <span class="number">1</span>,flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G,G1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[<span class="number">1007</span>],all;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="built_in">tfind</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	G1.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v));</span><br><span class="line">	edges[u].<span class="built_in">push_back</span>(G1.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = edges[x].<span class="built_in">size</span>();</span><br><span class="line">	w[x] = <span class="built_in">max</span>(w[x],dep + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> v = G1[edges[x][i]].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] == <span class="number">1</span>)&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,dep + <span class="number">1</span>);</span><br><span class="line">		vis[v] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mst</span>(in,<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) fa[i] = i,siz[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">1</span>) G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v,u));</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> a = <span class="built_in">tfind</span>(u),b = <span class="built_in">tfind</span>(v);</span><br><span class="line">			fa[b] = a;</span><br><span class="line">			siz[a] += siz[b];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = G.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u = G[i].from,v = G[i].to;</span><br><span class="line">		u = <span class="built_in">tfind</span>(u),v = <span class="built_in">tfind</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(u == v)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		in[u] ++;</span><br><span class="line">		<span class="built_in">addedge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(w[<span class="built_in">tfind</span>(i)] == <span class="number">0</span> &amp;&amp; in[<span class="built_in">tfind</span>(i)] == <span class="number">0</span>) <span class="built_in">dfs</span>(<span class="built_in">tfind</span>(i),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ans += w[<span class="built_in">tfind</span>(i)];</span><br><span class="line">		<span class="keyword">if</span>(w[<span class="built_in">tfind</span>(i)] == <span class="number">0</span>) flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="N-洁姐姐带我上分"><a href="#N-洁姐姐带我上分" class="headerlink" title="N -     洁姐姐带我上分"></a>N -     洁姐姐带我上分</h5><blockquote>
<p>jjjj一次能带$ k $个人上段位，每次jjjj不在的情况下每队cp都不能在一起，jjjj可以随意地上段位或者下段位，求出最少的让所有人都到高段位的代价</p>
</blockquote>
<p><code>DAG</code> <code>DP</code> <code>状态压缩</code><br><del>这题也是康题解做的</del><br>用二进制整数表示当前某个段位的状态，然后筛出合法的数据，按照条件得到合法转移条件连边<br>最后跑一遍最短路。。</p>
<blockquote>
<p>合法状态：末位为0的同时不能有一对cp的位置同时为1<br>合法转移：1的个数少于等于$ k $ 、状态转移的变量末位是1、同时两个转移状态之间的最大值减去状态变化值是两个转移状态的最小值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> uu,<span class="type">int</span> dd):<span class="built_in">u</span>(uu),<span class="built_in">d</span>(dd)&#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,maxx;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; all;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; statu;</span><br><span class="line">vector&lt;Edge&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[maxn * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Addedge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> dist)</span></span>&#123;</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from,to,dist));</span><br><span class="line">	G.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to,from,dist));	</span><br><span class="line">	edges[from].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">	edges[to].<span class="built_in">push_back</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> now_ = maxx - now,len = all.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">bool</span> flag1 = <span class="number">0</span>,flag2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((now &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((now &gt;&gt; all[i].x) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((now &gt;&gt; all[i].y) &amp; <span class="number">1</span> == <span class="number">1</span>)) flag1 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>((now_ &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((now_ &gt;&gt; all[i].x) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((now_ &gt;&gt; all[i].y) &amp; <span class="number">1</span>) == <span class="number">1</span>) flag2 = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag1 == <span class="number">1</span> || flag2 == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>) res ++;</span><br><span class="line">		x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> dist[maxx];</span><br><span class="line">	<span class="type">bool</span> vis[maxx];</span><br><span class="line">	priority_queue&lt;Node&gt; q;</span><br><span class="line">	<span class="built_in">mst</span>(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= maxx;i++) dist[i] = INF;</span><br><span class="line">	dist[maxx] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(maxx,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    	Node now = q.<span class="built_in">top</span>();</span><br><span class="line">    	q.<span class="built_in">pop</span>();</span><br><span class="line">    	<span class="type">int</span> u = now.u;</span><br><span class="line">    	<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    	vis[u] = <span class="number">1</span>;</span><br><span class="line">    	<span class="type">int</span> len = edges[u].<span class="built_in">size</span>();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    		Edge &amp;e = G[edges[u][i]];</span><br><span class="line">    		<span class="keyword">if</span>(dist[e.to] &gt; dist[u] + e.dist)&#123;</span><br><span class="line">    			dist[e.to] = dist[u] + e.dist;</span><br><span class="line">    			q.<span class="built_in">push</span>(<span class="built_in">Node</span>(e.to,dist[e.to]));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;tmp.x&gt;&gt;tmp.y;</span><br><span class="line">		all.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	maxx = (<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= maxx;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(i)) statu.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = statu.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">			<span class="type">int</span> det = statu[i] ^ statu[j];</span><br><span class="line">			<span class="type">int</span> cnt = <span class="built_in">get</span>(det);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">max</span>(statu[i],statu[j]) - det == <span class="built_in">min</span>(statu[i],statu[j]) &amp;&amp; cnt &lt;= k &amp;&amp; det &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">Addedge</span>(statu[i],statu[j],cnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">dij</span>();</span><br><span class="line">	<span class="keyword">if</span>(ans == INF) cout&lt;&lt;<span class="string">&quot;mole&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="O-洁姐姐带学画画"><a href="#O-洁姐姐带学画画" class="headerlink" title="O - 洁姐姐带学画画"></a>O - 洁姐姐带学画画</h5><blockquote>
<p>给出n个点，已经它们在三维空间中的坐标，求出生成树，并且每条线段的连接的两个点的高度差之和比上水平距离之和最小</p>
</blockquote>
<p><code>最小生成树</code> <code>prim</code> <code>牛顿迭代</code> <code>01分数规划</code><br>用一个表达式表示一个最小生成树，权值总和为<br>$$<br>x_1a_1 + x_2a_2 + … +x_na_n<br>$$<br>$x_i$表示选取或者不选取<br>令得到的答案为$ans$<br>那么有<br>$$<br>\frac {\sum x_ih_i}{\sum x_id_i} &gt;= ans \<br>移项，有 \sum x_ih_i &gt;= ans\sum x_id_i \<br>展开，x_1(h_1 - ans<em>d_1) + x_2(h_1 - ans * d_2) + … + x_n(h_n - ans</em>d_n) &gt;= 0<br>$$<br>可以进行二分判断得到的ans是否使得最小生成树为0即可，<br>除了使用二分，还可以使用牛顿迭代法更新答案直到$x &gt;= xx$，也就对应二分上面式子为0的时候</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node nodes[maxn];</span><br><span class="line"><span class="type">double</span> cost[maxn][maxn],len[maxn][maxn];</span><br><span class="line"><span class="type">double</span> M[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">			cost[i][j] = cost[j][i] = <span class="built_in">fabs</span>(nodes[i].z - nodes[j].z);</span><br><span class="line">			len[i][j] = len[j][i] = <span class="built_in">dis</span>(nodes[i],nodes[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> low[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;n;i++)&#123;</span><br><span class="line">		vis[i] = <span class="number">0</span>;</span><br><span class="line">		low[i] = M[<span class="number">0</span>][i];</span><br><span class="line">		pre[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">double</span> sumcost = <span class="number">0</span>,sumlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> min = INF;</span><br><span class="line">		<span class="type">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; min &gt; low[j])&#123;</span><br><span class="line">				nxt = j;</span><br><span class="line">				min = low[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[nxt] = <span class="number">1</span>;</span><br><span class="line">		sumcost += cost[pre[nxt]][nxt];</span><br><span class="line">		sumlen += len[pre[nxt]][nxt];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; low[j] &gt; M[nxt][j])&#123;</span><br><span class="line">				low[j] = M[nxt][j];</span><br><span class="line">				pre[j] = nxt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sumcost / sumlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mapp</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">			M[i][j] = M[j][i] = cost[i][j] - x * len[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;nodes[i].x&gt;&gt;nodes[i].y&gt;&gt;nodes[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get</span>();</span><br><span class="line">	<span class="type">double</span> sumc = <span class="number">0</span>,suml = <span class="number">0</span>,xx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++) sumc += cost[<span class="number">0</span>][i],suml += len[<span class="number">0</span>][i];</span><br><span class="line">	<span class="type">double</span> x = sumc / suml;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	xx = x;</span><br><span class="line">    	<span class="built_in">Mapp</span>(xx);</span><br><span class="line">    	x = <span class="built_in">prime</span>();</span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">fabs</span>(xx - x) &lt; eps) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://decision01.com">Solan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://decision01.com/post/ef8cd2a7.html">https://decision01.com/post/ef8cd2a7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://decision01.com" target="_blank">Decision`s blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a></div><div class="post-share"><div class="social-share" data-image="https://picsum.photos/seed/graph/700/400" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/11fc2100.html" title="UESTC暑假前集训-字符串与搜索-解题报告"><img class="cover" src="https://picsum.photos/seed/string/700/400" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UESTC暑假前集训-字符串与搜索-解题报告</div></div><div class="info-2"><div class="info-item-1">A - qh与复读机I A、每次按顺序给出$ n $个字符串，求出每个字符串是前面多少个字符串的前缀和后缀  tire树因为题面给定数据范围$\sum |S_i| &lt; 1e6$，也就是说如果建一棵树的话结点数是不会超过这么多的，而且遍历的时候也是，那么考虑正序和逆序建树，每次建树的同时到达最后一个结点返回当前结点已经记录的单词数量，也就分别对应了前缀和后缀时间复杂度$O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142#define maxn 1000007struct Node&#123;	int child[26];	int sum;	void init()&#123;		for(int i = 0;i &lt; 26;i++) child[i] = 0;		sum = 0;	&#125;&#125;Tree[2][maxn];int cnt1 = 0,cnt2 = 0;int insert(bool statu,const string&amp; s)&#12...</div></div></div></a><a class="pagination-related" href="/post/4f8e3ebd.html" title="UESTC暑假前集训-动态规划-解题报告"><img class="cover" src="https://picsum.photos/seed/dppppp/700/400" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UESTC暑假前集训-动态规划-解题报告</div></div><div class="info-2"><div class="info-item-1">A - oy环游世界 A、给定n个点，求出从起点开始遍历到最后一个点的最短曼哈顿距离  状态压缩n最多有17个点，可以考虑将17个点压缩到一个int里面，这个时候可以考虑一个状态$f _ {S,i}$，表示遍历了集合S后以i为终点的路径的最短的距离，状态转移方程为:$$f_{S,j} = min(f_{S,j},f_{S_j,j  + dist(j,k)})$$$S_j$表示集合$S$除去点$j$后的集合 12345678910111213141516171819202122232425262728293031323334struct Point&#123;	ll x,y;	ll operator - (const Point&amp; a) const&#123;		return abs(x - a.x) + abs(y - a.y);	&#125;&#125;all[20];ll n,s;ll f[1&lt;&lt;20][20];int main()&#123;	cin&gt;&gt;n&gt;&gt;s;	mst(f,0x3f3f3f);	for(ll i = 0;i &...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s.gravatar.com/avatar/d3c332e47b56134bab228c086c6578d5?s=250" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Solan</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/decision2016" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:personal@decision01.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://orcid.org/0000-0002-5094-7468" target="_blank" title="ORCID"><i class="fab fa-orcid"></i></a><a class="social-icon" href="https://500px.com.cn/solan" target="_blank" title="500px"><i class="fab fa-500px"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E8%BF%B7%E5%AE%AB"><span class="toc-number">1.</span> <span class="toc-text">A - 迷宫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-oydy%E7%9A%84%E5%BE%81%E9%80%94I"><span class="toc-number">2.</span> <span class="toc-text">B - oydy的征途I</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-oydy%E7%9A%84%E5%BE%81%E9%80%94II"><span class="toc-number">3.</span> <span class="toc-text">C - oydy的征途II</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-oydy%E7%9A%84%E5%BE%81%E9%80%94III"><span class="toc-number">4.</span> <span class="toc-text">D - oydy的征途III</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E5%8F%98%E8%89%B2%E9%BE%99"><span class="toc-number">5.</span> <span class="toc-text">E - 变色龙</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#F-zh%E5%90%83%E9%A5%AD"><span class="toc-number">6.</span> <span class="toc-text">F -     zh吃饭</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G-hqf%E5%90%B9%E6%B3%A1%E6%B3%A1"><span class="toc-number">7.</span> <span class="toc-text">G - hqf吹泡泡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#H-%E6%AF%81%E7%81%AD%E4%B8%9C%E6%B9%96%E8%AE%A1%E5%88%92"><span class="toc-number">8.</span> <span class="toc-text">H - 毁灭东湖计划</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I-cxx%E4%BB%99%E5%A5%B3%E4%B8%8B%E5%87%A1"><span class="toc-number">9.</span> <span class="toc-text">I -  cxx仙女下凡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#J-cxx%E5%AE%88%E6%A0%AA%E5%BE%85%E5%85%94"><span class="toc-number">10.</span> <span class="toc-text">J - cxx守株待兔</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#K-cxx%E6%89%BF%E5%8C%85%E9%B1%BC%E5%A1%98"><span class="toc-number">11.</span> <span class="toc-text">K - cxx承包鱼塘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#L-cxx%E7%9A%84%E5%8E%8B%E5%B2%81%E9%92%B1"><span class="toc-number">12.</span> <span class="toc-text">L - cxx的压岁钱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#M-%E6%B4%81%E5%A7%90%E5%A7%90%E5%B8%A6%E6%88%91%E6%89%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">13.</span> <span class="toc-text">M - 洁姐姐带我找工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#N-%E6%B4%81%E5%A7%90%E5%A7%90%E5%B8%A6%E6%88%91%E4%B8%8A%E5%88%86"><span class="toc-number">14.</span> <span class="toc-text">N -     洁姐姐带我上分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#O-%E6%B4%81%E5%A7%90%E5%A7%90%E5%B8%A6%E5%AD%A6%E7%94%BB%E7%94%BB"><span class="toc-number">15.</span> <span class="toc-text">O - 洁姐姐带学画画</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/1342f7b5.html" title="Restāre"><img src="/../images/restare.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Restāre"/></a><div class="content"><a class="title" href="/post/1342f7b5.html" title="Restāre">Restāre</a><time datetime="2025-12-22T14:48:08.000Z" title="发表于 2025-12-22 22:48:08">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/898b7ce0.html" title="濑户内海｜高松"><img src="/../images/ogijima.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="濑户内海｜高松"/></a><div class="content"><a class="title" href="/post/898b7ce0.html" title="濑户内海｜高松">濑户内海｜高松</a><time datetime="2025-12-12T16:34:32.000Z" title="发表于 2025-12-13 00:34:32">2025-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/af68713.html" title="微雪墨水屏简单开发记录"><img src="/../images/s-l1600.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微雪墨水屏简单开发记录"/></a><div class="content"><a class="title" href="/post/af68713.html" title="微雪墨水屏简单开发记录">微雪墨水屏简单开发记录</a><time datetime="2025-06-03T04:56:00.000Z" title="发表于 2025-06-03 12:56:00">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/90641208.html" title="秩父市圣地巡礼｜未闻花名"><img src="/../images/chichibu.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秩父市圣地巡礼｜未闻花名"/></a><div class="content"><a class="title" href="/post/90641208.html" title="秩父市圣地巡礼｜未闻花名">秩父市圣地巡礼｜未闻花名</a><time datetime="2025-04-20T09:08:51.000Z" title="发表于 2025-04-20 17:08:51">2025-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d7134320.html" title="Solidity 编程优化策略"><img src="/../images/solidity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Solidity 编程优化策略"/></a><div class="content"><a class="title" href="/post/d7134320.html" title="Solidity 编程优化策略">Solidity 编程优化策略</a><time datetime="2024-12-11T08:55:37.000Z" title="发表于 2024-12-11 16:55:37">2024-12-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2026 By Solan</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.2</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","placeholder":"Just go go","recordIP":true,"meta":"nick,mail,link","emojiCDN":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/","enableQQ":true,"requiredFields":"nick, mail"}

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'cUf5ViGX0WC6Py07aH4nm68S-MdYXbMMI',
      appKey: 'SHhI9rHOdX3eD7ezCMFp0G9m',
      avatar: 'identicon',
      serverURLs: 'https://cuf5vigx.api.lncldglobal.com',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>