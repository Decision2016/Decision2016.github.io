<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decision`s blog</title>
  
  
  <link href="http://decision01.com/atom.xml" rel="self"/>
  
  <link href="http://decision01.com/"/>
  <updated>2024-04-08T14:56:31.204Z</updated>
  <id>http://decision01.com/</id>
  
  <author>
    <name>Decision</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bitcoin 支付方式及地址类型</title>
    <link href="http://decision01.com/post/8a19da7d.html"/>
    <id>http://decision01.com/post/8a19da7d.html</id>
    <published>2024-04-08T12:16:05.000Z</published>
    <updated>2024-04-08T14:56:31.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>由于 Bitcoin 中的支付类型众多，这也导致地址各式各样，在 btcd 中提供了不同的函数来为公钥生成不同的地址。</p><p>这一篇作为 <a href="https://decision01.com/post/c19159ae.html">btcd：Golang 下的交易构建</a> 的补充，说明各种支付方式和地址类型。</p><p>另外，这篇博文的大部分内容对应 Learn me a bitcoin <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Learn me a bitcoin](https://learnmeabitcoin.com/)">[1]</span></a></sup> 的 <a href="https://learnmeabitcoin.com/technical/script/">Script</a>，所以这篇博文更像一个学习记录</p></div><h1 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h1><p><em>Script is a mini programming language used as a locking mechanism for outputs in bitcoin transactions.</em></p><p>脚本是一种迷你程序语言，用作比特币交易输出的锁定机制。</p><ul><li>在每笔交易的输出上都会由一个<strong>锁定脚本</strong>，它对应了输出中的 $ScriptPubKey$ 字段；</li><li>每笔交易还需要提供对应每个输入的<strong>解锁脚本</strong>，用于在这笔交易中解锁前一笔交易的输出，这对应了输入中的 $ScriptSig$​ 字段；</li></ul><p>锁定脚本和解锁脚本在比特币中体现为二进制形式混合的操作码和数据，并且通过运行时栈来运行，如果<strong>最终栈内的唯一元素</strong>是<code>OP_1</code>或更大的元素，那么脚本就是有效的；</p><p>基于此，一笔有效的交易需要所有输入的有效（每一笔输入的锁定脚本和在该笔交易下的输出脚本所构成的脚本有效）</p><p>脚本语言、EVM 两者存在很大的相似性，都是以字节码的形式在运行时栈中运行。它们最大的区别在于<strong>脚本语言只验证脚本的有效性用于实现支付</strong>，而不会保存程序的状态，也因此 Bitcoin 的脚本语言不能做到像 Ethereum 那样的 DApp。</p><h1 id="支付脚本"><a href="#支付脚本" class="headerlink" title="支付脚本"></a>支付脚本</h1><h2 id="P2PK：支付到公钥"><a href="#P2PK：支付到公钥" class="headerlink" title="P2PK：支付到公钥"></a>P2PK：支付到公钥</h2><p>支付到公钥涉及到两个操作码：</p><ul><li><code>OP_PUSHBYTES</code>：向栈中压入指定字节长度的数据</li><li><code>OP_CHECKSIG</code>：取出栈顶的两条数据，并进行签名校验，如果这两条数据分别是签名<code>sig</code>以及对应的公钥<code>pk</code>，签名正确则返回<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[OP_CHECKSIG - Bitcoin Wiki](https://en.bitcoin.it/wiki/OP_CHECKSIG)">[3]</span></a></sup></li></ul><blockquote><p>签名的格式<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[“可一学院”区块链科普丨OP_CHECKSIG](https://zhuanlan.zhihu.com/p/667783299)">[2]</span></a></sup>为<code>[DER signature][hashtype]</code>，即 DER 编码格式下的签名和哈希类型，DER 编码格式如下，(R,S) 是椭圆曲线下签名后得到的证明<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DER encode - Learn me a bitcoin](https://learnmeabitcoin.com/technical/keys/signature/#der)">[4]</span></a></sup></p><p><img src="https://learnmeabitcoin.com/diagrams/png/keys-signature-der-encoding.png" alt="A diagram showing how convert a raw signature to DER encoding."></p></blockquote><p>P2PK 的锁定脚本和解锁脚本的形式依次为：</p><ul><li>锁定脚本：<code>OP_PUSHBYTES_65 [pk] OP_CHECKSIG</code></li><li>解锁脚本：<code>OP_PUSHBYTES_72 [sig]</code></li><li>完整脚本：<code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_65 [pk] OP_CHECKSIG</code></li></ul><p>其运行过程就是：先把签名和公钥压栈，然后依次取出后调用 <code>OP_CHECKSIG</code> 来验证签名，OP_CHECKSIG 使用公钥 <code>pk</code> 验证签名 <code>sig</code> 是否对应当前的交易</p><p>这里的交易被作为签名时需要的消息，通常签名需要制定消息输入，否则无法满足签名所需要的安全性（算是密码学常识）</p><p>于是 P2PK 交易的锁定脚本只需要公钥即可，锁定脚本中的公钥可以是压缩形式（33 bytes），也可以是未压缩形式（65 bytes）</p><div class="admonition note"><p class="admonition-title">公钥的压缩</p><p>在椭圆曲线密码中，私钥通是一个大整数 $k$，而私钥则是一个点 $kO$，$O$ 是椭圆曲线上的一个基点</p><p>所以，这就导致公钥实际上是二维坐标系上的一个二维坐标 (x,y)，这就使得正常存储公钥需要存放两个坐标值</p><p>但是根据具体使用的 secp256k1 曲线的公式有 $y^2=x^3 + 7$，只需要知道 $x$ 就可以计算得到 $y$，这就使得通过只存放 $x$ 来压缩公钥成为可能。</p><p>由于平方的存在这使得取值会有两个（在取模下是一个奇数和一个偶数），因此压缩的公钥中需要指定是奇数或是偶数，即前缀中记录0x02（偶数）或0x03（奇数）。</p></div><h2 id="P2PKH：支付到公钥哈希"><a href="#P2PKH：支付到公钥哈希" class="headerlink" title="P2PKH：支付到公钥哈希"></a>P2PKH：支付到公钥哈希</h2><p>支付到公钥的方式需要存放的数据太长，它需要存放完整的公钥信息，于是支付到哈希值这一方法被提出，然而实际上公钥还是需要被包含到交易中，区别在于：P2PK 的公钥在锁定脚本（交易输出）中，P2PKH 的公钥在解锁脚本（交易输入）中。</p><p>支付到公钥哈希涉及的额外操作码：</p><ul><li><code>OP_DUP</code>：取出栈顶的数据，复制一份然后将两份数据都压栈</li><li><code>OP_HASH160</code>：取出栈顶的数据，通过 hash160 计算哈希值后放入栈中</li><li><code>OP_EQUALVERIFY</code>：取出栈顶的两份数据，检查是否相等</li></ul><p>支付到公钥哈希的验证过程和支付到公钥类似，它多出来的步骤是验证解锁脚本中公钥的哈希值和锁定脚本中的哈希值是否相等，然后再验证交易的签名</p><p>P2PKH 的锁定脚本和解锁脚本的形式依次为：</p><ul><li>锁定脚本：<code>OP_DUP OP_HASH160 OP_PUSHBYTES_20 [pkh] OP_EQUALVERIFY OP_CHECKSIG</code></li><li>解锁脚本：<code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_33 [pk]</code> </li><li>完整脚本：<code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_33 [pk] OP_DUP OP_HASH160 OP_PUSHBYTES_20 [pkh] OP_EQUALVERIFY OP_CHECKSIG</code></li></ul><p>完整脚本的除去最后验证签名的部分，都是为了验证公钥的哈希值是否正确</p><p>这种签名方式将交易的手续费从发送者转移到了接收者，因为接收者相比 P2PK 方式需要填入更多的信息，但是减少了发送者的信息长度</p><div class="admonition note"><p>后续都会提到代价转移这一概念，实际上就是越大的交易所需要的手续费越高</p><p>因此，后面的支付方式都在通过降低锁定脚本的大小，然后不得已又使得解锁脚本变大，这个过程中支付的成本就从发送者转移到了接收者</p></div><h2 id="P2SH：支付到脚本哈希"><a href="#P2SH：支付到脚本哈希" class="headerlink" title="P2SH：支付到脚本哈希"></a>P2SH：支付到脚本哈希</h2><p>支付到脚本哈希要求解锁脚本经过哈希后为某个哈希值，它最初被用于多签交易，因为多签交易中需要包含多个钱包的公钥，并且使用 P2PK 方式使得需要存放大量冗余公钥，这使得发送者在锁定时需要消耗较多的手续费（于是同样地，这部分费用被转移到使用者）</p><p>P2SH 的锁定脚本和解锁脚本的形式依次为：</p><ul><li>锁定脚本：<code>OP_HASH160 OP_PUSHBYTES_20 [hash] OP_EQUAL</code></li><li>解锁脚本：没有确定的形式，只需要保证它的哈希值为 <code>hash</code> 即可，这里使用 <code>script</code> 表示</li><li>完整脚本：<code>[args] [script] OP_HASH160 OP_PUSHBYTES_20 [hash] OP_EQUAL</code></li></ul><p>因此，实际上 <code>script</code> 中包含的是完整的脚本代码，同时还有脚本需要的参数 <code>args</code>，在多签交易中，这些参数是签名，这种支付方式完全将交易的代价转移给了发送者</p><h2 id="Witness：隔离见证"><a href="#Witness：隔离见证" class="headerlink" title="Witness：隔离见证"></a>Witness：隔离见证</h2><p>BIP 141 提案中提出了<strong>隔离见证（SegWit）</strong>这一技术，见证隔离其实是某种程度上对区块的<strong>扩容</strong>（原来一个区块大小 1M 到现在的一个区块大小 4M），也算是开发者社区中达到的一种奇怪的平衡</p><div class="admonition note"><p class="admonition-title">隔离见证的核心思想</p><p>其核心思想是每笔交易的解锁脚本不再直接存储到交易的 <code>ScriptSig</code> 字段中，而是额外用一个名为 <code>witness</code> 的数组来存放，它们一一对应输入的位置作为解锁脚本。</p><p>此外，bip-141 还为交易提供了虚拟大小（vSize）这一概念，在计算区块大小的时候按照所有交易的虚拟大小总和作为区块大小。而见证隔离交易的虚拟大小为它真实大小的四分之一。这样就间接使得每个区块的大小变为了原来的 4 倍，但是实际上区块的真实大小还是 1 MB（<del>这不是就是在耍流氓吗</del>）。</p><p>此外，节点还可以剔除隔离见证的数据来减小区块的实际数据，它们在存放时和基础的区块是分开的。</p></div><p>见证隔离的锁定脚本形式：</p><ul><li>针对 P2PKH 交易（P2WPKH）：<code>OP_0 OP_PUSHBYTES_20 [pkh]</code></li><li>针对 P2SH 交易（P2WSH）：<code>OP_0 OP_PUSHBYTES_32 [hash]</code></li></ul><p>可以看出，锁定脚本根据类型具有不同的长度，客户端也可以根据长度来区分它们是 P2WPKH 还是 P2WSH</p><p>同时，见证隔离的解锁脚本也跟真实的 P2PKH 和 P2SH 交易不同，它们使用紧凑的字节码来表示数据，不需要操作码。解锁脚本被存放在交易的 <code>witness</code> 字段，并保证 <code>sigScript</code> 字段为空，解锁脚本的格式如下</p><ul><li><p>针对 P2PKH 交易：<code>[sig] [pk]</code></p></li><li><p>针对 P2SH 交易: <code>[args] [script]</code></p><blockquote><p>在这里，args 是后续脚本 script 的参数，因为不能保证</p></blockquote></li></ul><p>见证隔离中设定了对应的脚本对来运行脚本，以此来达到压缩交易大小的目的</p><p>并且，锁定脚本的 <code>OP_0</code> 操作码对于一个旧的客户端来说，它是一个任何人都可以花费的输出，这就可以很好地兼容新版本客户端的区块和交易</p><h2 id="P2TR：支付到-Taproot"><a href="#P2TR：支付到-Taproot" class="headerlink" title="P2TR：支付到 Taproot"></a>P2TR：支付到 Taproot</h2><p>支付到 Taproot （主根）是版本为 1 的隔离见证，上述的两种隔离见证是版本为 0 的隔离见证</p><p>P2TR 将两种支付方式统一到了一起，通过输出的格式无法知道这个输出是通过签名锁定（Key Path）还是脚本锁定（Script Path）<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot](https://aandds.com/blog/bitcoin-taproot.html)">[5]</span></a></sup></p><p>只有在输出被使用的时候，通过见证信息才知道其锁定形式是签名锁定还是脚本锁定</p><blockquote><p>Taproot 交易也是 Bitcoin 的一个重大升级，这个支付方式设计到 Schnorr 签名和默克尔抽象语法树（Merklized Abstract Syntax Trees, MAST），要讲明白又需要开新的一篇来写了 = =，这里就先放着了，后续开新坑写</p></blockquote><p>由于是版本为 1 的隔离见证，所以它的锁定脚本为 <code>OP_1 OP_PUSHBYTES_32 [hash]</code>，这里由于统一了两种支付路径，所以哈希值都是 32 bytes</p><p>解锁脚本格式：</p><ul><li>针对 P2PKH 交易：<code>[sig]</code></li><li>针对 P2SH 交易：<code>[args] [script]</code></li></ul><p>于是，在 P2TR 交易中，只能通过 witness 来区分交易类型，如果只有一个元素，说明是 P2PKH 交易，否则是 P2SH 交易</p><h1 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h1><p>（todo…）</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/667783299">“可一学院”区块链科普丨OP_CHECKSIG</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/OP_CHECKSIG">OP_CHECKSIG - Bitcoin Wiki</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnmeabitcoin.com/technical/keys/signature/#der">DER encode - Learn me a bitcoin</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://aandds.com/blog/bitcoin-taproot.html">Taproot</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;由于 Bitcoi</summary>
      
    
    
    
    <category term="Dev" scheme="http://decision01.com/categories/Dev/"/>
    
    
    <category term="blockchain" scheme="http://decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="http://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>btcd：Golang 下的交易构建</title>
    <link href="http://decision01.com/post/c19159ae.html"/>
    <id>http://decision01.com/post/c19159ae.html</id>
    <published>2024-04-08T06:01:32.000Z</published>
    <updated>2024-04-08T14:58:09.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p class="admonition-title">锲子</p><p>参与 Bitcoin 的相关生态难免需要涉及到链上的操作，相比于 Ethereum 这样简单的交易发送机制，Bitcoin 上构建交易则需要一定的编程能力，这篇博文记录一下 Bitcoin 上构建交易的各种姿势。（博文不间断更新）</p></div><p>这篇博文的前置知识：UTxO、交易结构与脚本语言，可以在 <a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a> 学习，另外：</p><ul><li>测试网交易池可视化：<a href="https://mempool.space/testnet">https://mempool.space/testnet</a></li><li>测试代币水龙头：<a href="https://bitcoinfaucet.uo1.net/">https://bitcoinfaucet.uo1.net/</a></li><li>测试私钥生成（主网尽量不要使用）：<a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a> </li></ul><p>golang 下的 Bitcoin 工具库为：<code>github.com/btcsuite/btcd</code></p><h1 id="简单交易的构建"><a href="#简单交易的构建" class="headerlink" title="简单交易的构建"></a>简单交易的构建</h1><h2 id="私钥与地址生成"><a href="#私钥与地址生成" class="headerlink" title="私钥与地址生成"></a>私钥与地址生成</h2><h3 id="私钥生成"><a href="#私钥生成" class="headerlink" title="私钥生成"></a>私钥生成</h3><p>私钥有多种形式，在 Bitcoin 中最为常见的是 WIF （Wallet Import Format）格式的私钥，也有 16 进制的私钥，这些私钥之间是可以相互转换的</p><div class="admonition note"><p>事实上目前的大多数钱包插件都不支持 WIF 格式的私钥导入，只能使用一些软件钱包才能导入。</p></div><p>golang 内可以生成私钥并派生 WIF 格式的私钥，也可以使用在线的 BIP-39 助记词生成（不推荐主网使用）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 博文的代码都默认为测试网</span></span><br><span class="line">cfg := &amp;chaincfg.TestNet3Params</span><br><span class="line"></span><br><span class="line">privateKey, err := btcec.NewPrivateKey()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wif, err := btcutil.NewWIF(privateKey, cfg, <span class="literal">true</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Generated WIF Key: %s&quot;</span>, wif.String())</span><br><span class="line"><span class="comment">// Generated WIF Key: cViUtGHsa6XUxxk2Qht23NKJvEzQq5mJYQVFRsEbB1PmSHMmBs4T</span></span><br></pre></td></tr></table></figure><h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><p>同样，Bitcoin 的地址有多种类型，在之前的博文 <a href="https://decision01.com/post/4f925910.html">BIP、闪电网络与 Trao</a> 中略有提及，如果需要具体了解也可以阅 Learn me a bitcoin 的 <a href="https://learnmeabitcoin.com/technical/script/">Script</a> 小节中的各种地址。</p><p>支付类型和地址相关的内容放在了新坑：<a href="https://decision01.com/post/c19159ae.html">btcd：Golang 下的交易构建</a></p><p>目前比较常用的是 Taproot 地址，这是为了支持 Taproot 协议而被提出的地址类型，可以支持不同的 Pay-To 方式</p><p>在代码的实现层面上，通过 WIF 私钥生成地址的代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">taprootAddr, err := btcutil.NewAddressTaproot(</span><br><span class="line">    schnorr.SerializePubKey(</span><br><span class="line">        txscript.ComputeTaprootKeyNoScript(</span><br><span class="line">            wif.PrivKey.PubKey())),</span><br><span class="line">    &amp;chaincfg.TestNet3Params)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Taproot testnet address: %s\n&quot;</span>, taprootAddr.String())</span><br><span class="line"><span class="comment">// Taproot testnet address: tb1p3d3l9m5d0gu9uykqurm4n8xcdmmw9tkhh8srxa32lvth79kz7vysx9jgcr</span></span><br></pre></td></tr></table></figure><p>这里嵌套了四层函数，从内到外依次是</p><ul><li>wif.PrivKey.PubKey()：获取 WIF 密钥对的公钥</li><li>txscript.ComputeTaprootKeyNoScript：通过公钥计算得到一个 Taproot 的 Schnorr 签名公钥，类似一个转换的过程</li><li>schnorr.SerializePubKey：对公钥序列化为字节码</li><li>btcutil.NewAddressTaproot：序列化后的公钥生成 Taproot 地址</li></ul><h1 id="简单交易构建"><a href="#简单交易构建" class="headerlink" title="简单交易构建"></a>简单交易构建</h1><p>Bitcoin 最为简单的交易即一笔输入和一笔输出的交易，它将一笔输入中的 BTC 转入到另外一个地址</p><p>随机生成转账地址：tb1pvwak065fek4y0mup9p4l7t03ey2nu8as7zgcrlgm9mdfl8gs5rzss490qd</p><div class="admonition note"><p>虽然说是“简单”交易构建，实际上 Taproot 类型的交易算是比较麻烦的交易构建方式，较为简单的应该是 P2PKH 交易的构建。</p></div><p>构建交易之前需要获取地址的可用 UTxO，需要一个函数 <code>GetUnspent(address string)</code> 来得到地址的 UTxO，这里先手动填入然后返回所需要的 UTxO 的信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUnspent</span><span class="params">(address <span class="type">string</span>)</span></span> (*wire.OutPoint, *txscript.MultiPrevOutFetcher)&#123;</span><br><span class="line"><span class="comment">// 交易的哈希值，并且要指定输出位置</span></span><br><span class="line">txHash, _ := chainhash.NewHashFromStr(</span><br><span class="line"><span class="string">&quot;7282d54f485561dd21ba22a971b096eb6d0f45ed2fe6bf8c29d87cee162633b4&quot;</span>)</span><br><span class="line">point := wire.NewOutPoint(txHash, <span class="type">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交易的锁定脚本，对应的是 ScriptPubKey 字段</span></span><br><span class="line">script, _ := hex.DecodeString(<span class="string">&quot;51208b63f2ee8d7a385e12c0e0f7599cd86ef6e2aed7b9e033762afb177f16c2f309&quot;</span>)</span><br><span class="line">output := wire.NewTxOut(<span class="type">int64</span>(<span class="number">1000</span>), script)</span><br><span class="line">fetcher := txscript.NewMultiPrevOutFetcher(<span class="literal">nil</span>)</span><br><span class="line">fetcher.AddPrevOut(*point, output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> point, fetcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是一个输出点（output point）和前置输出获取器（Fetcher）</p><ul><li>输出点记录了 UTxO 所在的交易哈希和输出所在交易的位置（index），后续用于填充交易的输入</li><li>获取器中记录了一个映射关系，即一个输出点对应的输出是什么样的（它输出的数量和锁定脚本）</li></ul><p>此外，发送交易之前要将地址解码并且生成 Taproot 下的 PayToAddress 脚本，该过程的实现代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeTaprootAddress</span><span class="params">(strAddr <span class="type">string</span>, cfg *chaincfg.Params)</span></span> ([]<span class="type">byte</span>, </span><br><span class="line"><span class="type">error</span>) &#123;</span><br><span class="line">taprootAddr, err := btcutil.DecodeAddress(strAddr, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byteAddr, err := txscript.PayToAddrScript(taprootAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> byteAddr, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>至此，可以开始一笔简单交易的构建，相比于在 Ethereum 下一个 Json 就可以完成的操作，在 Bitcoin 则是需要实例化一个空的交易体并手动填充</p><p>新建交易的输入（wire.TxIn）需要三个参数：前一输出点、签名、见证脚本（witness），构建交易时后面两者均先默认为 nil，在签名完成后才进行填充</p><div class="admonition note"><p class="admonition-title">签名和见证脚本</p><p>在通常情况下，见证脚本和签名脚本是独立的，或者说见证脚本就是一种签名，只是它独立在交易体外，并且这一部分数据也可以在很久之后被节点修剪掉。</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 version = 1</span></span><br><span class="line">tx := wire.NewMsgTx(wire.TxVersion)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前一笔交易的输出点作为输入</span></span><br><span class="line">in := wire.NewTxIn(point, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">tx.AddTxIn(in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建输出，支付到指定地址并填充转移多少</span></span><br><span class="line">out := wire.NewTxOut(<span class="type">int64</span>(<span class="number">800</span>), byteAddr)</span><br><span class="line">tx.AddTxOut(out)</span><br></pre></td></tr></table></figure><p>然后需要对交易进行签名，签名是对交易的所有输入进行签名，即需要填入正确的解锁脚本到签名脚本或见证脚本字段中。在 Taproot 交易中，通常需要填入解锁的见证脚本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前一笔交易</span></span><br><span class="line">prevOutput := fetcher.FetchPrevOutput(in.PreviousOutPoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥生成见证脚本</span></span><br><span class="line">witness, _ := txscript.TaprootWitnessSignature(tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher), <span class="number">0</span>, prevOutput.Value,</span><br><span class="line">    prevOutput.PkScript, txscript.SigHashDefault, wif.PrivKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充输入的见证脚本</span></span><br><span class="line">tx.TxIn[<span class="number">0</span>].Witness = witness</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将完成签名的交易转为 hex 形式并输出</span></span><br><span class="line"><span class="keyword">var</span> signedTx bytes.Buffer</span><br><span class="line">tx.Serialize(&amp;signedTx)</span><br><span class="line">finalRawTx := hex.EncodeToString(signedTx.Bytes())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Signed Transaction:\n %s&quot;</span>, finalRawTx)</span><br><span class="line"><span class="comment">// Signed Transaction: 01000000000101b4332616ee7cd8298cbfe62fed450f6deb96b071a922ba21dd6155484fd582720000000000ffffffff01200300000000000022512063bb67ea89cdaa47ef81286bff2df1c9153e1fb0f09181fd1b2eda9f9d10a0c5014011a52fdf6ccdda65359ecc9761b199e132d92bb21be059c6c5fb23e86af7152d429dde23314df0db4bcd52428acffab876b8cca1e19d2788a8382c48141b19bd00000000</span></span><br></pre></td></tr></table></figure><p>本节不设计代码层面的交易发送，简单来说交易的广播就是将它发布到任意一个区块链节点</p><p>所以可以将生成的交易提交到 <a href="https://mempool.space/testnet/tx/push">Broadcast Transaction</a> 即可，演示交易为 <a href="https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f">https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f</a></p><p>本节的完整代码：<a href="https://gist.github.com/Decision2016/18057d0d62b0b5f9716385063fb4c3bc">Simple Bitcoin Transaction - Github Gist</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://mahdidarabi.medium.com/create-raw-bitcoin-transaction-and-sign-it-with-golang-96b5e10c30aa">Create Raw Bitcoin Transaction and Sign It With Golang</a></li><li><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="Dev" scheme="http://decision01.com/categories/Dev/"/>
    
    
    <category term="blockchain" scheme="http://decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="http://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>go-libp2p 踩坑记</title>
    <link href="http://decision01.com/post/822fd34d.html"/>
    <id>http://decision01.com/post/822fd34d.html</id>
    <published>2023-11-04T09:06:08.000Z</published>
    <updated>2024-04-08T08:03:49.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>做区块链相关的项目难免会遇到需要构建一个 P2P 网络的时候，去年这个时候在 python 上使用的是一个已经停止维护了很久的 Kademlia 库；在今年转到 go 之后就注意到了 go-libp2p 这个库。go-libp2p 源自于 IPFS，它是用于构建 P2P 网络的模块化网络堆栈和库，功能特别强大，但是坑也特别多，主要的原因还是资料和文档都很少。在使用了一段时间后还是觉得需要写一篇博文来记录，还可以作为以后的一个文档吧。</p></div><p>对于 go-libp2p 的不同模块，可以参考 <a href="https://cloud.tencent.com/developer/article/1988253">长安链P2P网络技术介绍（2）：初识LibP2P</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[长安链P2P网络技术介绍（2）：初识LibP2P](https://cloud.tencent.com/developer/article/1988253)">[1]</span></a></sup>。当然，这是一个很笼统的介绍，而这篇博文也会比较简单（毕竟它所拥有的功能太多了），只会记录笔者所使用到的一些功能：连接建立、流处理、节点发现、消息广播及配置、资源限制；同时，官方的库中也有一些样例可以参考：<a href="https://github.com/libp2p/go-libp2p/tree/master/examples">examples - go-libp2p</a>，这篇博文的完整代码可以在 <a href="https://github.com/Decision2016/libp2p-example">libp2p-example</a> 查看</p><h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><p>先从最简单的 echo 功能开始：两个节点 A 和 B 在建立连接后，节点 A 向节点 B 发送消息 msg，节点 B 也返回消息 msg，可以通过控制台发送消息和打印接收到的消息，这也是 example 中的第一个例子 <a href="https://github.com/libp2p/go-libp2p/tree/master/examples/echo">echo - go-libp2p</a></p><h2 id="节点启动"><a href="#节点启动" class="headerlink" title="节点启动"></a>节点启动</h2><p>在 go-libp2p 中可以使用 <code>func New(opts ...Option) (host.Host, error)</code> 启动一个节点，它会返回一个 <code>Host</code> 对象，通过这个对象可以查询到本地节点的一系列连接信息，也是实现其他功能所需要用到的对象<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[从 go-libp2p 开始](https://www.cnblogs.com/superblockchain/p/14103338.html)">[2]</span></a></sup>。在这里先只考虑使用它来获取这个节点的监听地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/libp2p/go-libp2p&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, err := libp2p.New()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create libp2p host failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infoln(<span class="string">&quot;Create new libp2p host, listen addresses: &quot;</span>, host.Addrs())</span><br><span class="line"><span class="keyword">if</span> err := host.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Close host errored.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码展示的是一个节点的创建，并且在创建后打印出节点的监听信息</p><h2 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h2><p>在连接到另外一个节点之前需要知道节点的连接信息，通常连接信息以 multiaddr<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Addressing in libp2p](https://github.com/libp2p/specs/blob/master/addressing/README.md)">[3]</span></a></sup> 的形式出现，它的格式通常是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ip4/127.0.0.1/tcp/31514/p2p/12D3KooWSc8cftoRYqPdKUg3CSfdHngvbMuc8b4xEBBkF66RFGV8</span><br><span class="line"></span><br><span class="line">/[ip 协议类型/ip 地址/传输协议类型/端口/节点 id</span><br></pre></td></tr></table></figure><p>可以在指定监听端口后直接打印节点信息，并且让其他节点连接，例如添加以下的日志输出语句，并且通过传参的方式传入 <code>port</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logrus.Infof(<span class="string">&quot;Node address: /ip4/127.0.0.1/tcp/%v/p2p/%s&quot;</span>, port, host.ID().String())</span><br></pre></td></tr></table></figure><p>在拥有节点的信息后，就可以通过 <code>Connect(ctx context.Context, pi peer.AddrInfo) error</code> 连接到对端节点，对应的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">addrStr := <span class="string">&quot;/ip4/127.0.0.1/tcp/31514/p2p/...&quot;</span></span><br><span class="line"></span><br><span class="line">maddr, err := multiaddr.NewMultiaddr(addrStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Convert address from string failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr, err := peer.AddrInfoFromP2pAddr(maddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Get address info from multiple address failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = host.Connect(ctx, *addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Connect to new node failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合建立节点的代码，引入传参后可以实现一个连接到对端节点的程序，在传入连接信息 <code>peer</code> 时可以连接到对应的节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> help &#123;</span><br><span class="line">flag.Usage()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localMultiAddr, err := multiaddr.NewMultiaddr(</span><br><span class="line">fmt.Sprintf(<span class="string">&quot;/ip4/0.0.0.0/tcp/%d&quot;</span>, port),</span><br><span class="line">)</span><br><span class="line">host, err := libp2p.New(</span><br><span class="line">libp2p.ListenAddrs(localMultiAddr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create libp2p host failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infoln(<span class="string">&quot;Create new libp2p host, listen addresses: &quot;</span>, host.Addrs())</span><br><span class="line">logrus.Infof(<span class="string">&quot;Node address: /ip4/127.0.0.1/tcp/%v/p2p/%s&quot;</span>, port, host.ID().String())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> peerAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">maddr, err := multiaddr.NewMultiaddr(peerAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Convert address from string failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr, err := peer.AddrInfoFromP2pAddr(maddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Get address info from multiple address failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = host.Connect(ctx, *addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Connect to new node failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infof(<span class="string">&quot;Connect to node %s success.&quot;</span>, peerAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> sign := &lt;-c:</span><br><span class="line">logrus.Infof(<span class="string">&quot;Got %s signal. Aborting...&quot;</span>, sign)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := host.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Close host errored.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>传参</strong> 利用 golang 的 flag 包可以接收、解析传入参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">peerAddr <span class="type">string</span></span><br><span class="line">port     <span class="type">int</span></span><br><span class="line">help     <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.StringVar(&amp;peerAddr, <span class="string">&quot;peer&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Peer node address&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">8123</span>, <span class="string">&quot;Node listen port&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;help, <span class="string">&quot;h&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Command help&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag.Usage = usage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usage</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">`Usage: main [--port port] [--peer address]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">flag.PrintDefaults()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>在完成节点的连接后，还需要实现消息的传输才能完成 echo 程序的功能。在 go-libp2p 中具有创建数据流的功能</p><ul><li>发起流的建立者需要通过 <code>NewStream(ctx context.Context, p peer.ID, pids ...protocol.ID) (network.Stream, error)</code> 发起流的建立</li><li>对端需要通过 <code>SetStreamHandler(pid protocol.ID, handler network.StreamHandler)</code> 设置处理流的函数，并且由这个 <code>handler</code> 来进行流的处理</li></ul><h3 id="流处理函数"><a href="#流处理函数" class="headerlink" title="流处理函数"></a>流处理函数</h3><p>在这个例子中，接受流的创建的那一方在接受到消息后在控制台通过日志打印，并且将数据重新写入流返回给发送方，其函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleStream</span><span class="params">(s network.Stream)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf := bufio.NewReader(s)</span><br><span class="line">str, err := buf.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Receive failed, stream routine exit.&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infof(<span class="string">&quot;Read from stream: %s&quot;</span>, str[:<span class="built_in">len</span>(str)<span class="number">-1</span>])</span><br><span class="line">_, err = s.Write([]<span class="type">byte</span>(str))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Write to stream failed, routine exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在 <code>main</code>  函数中使用 <code>host.SetStreamHandler(&quot;/echo/1.0.0&quot;, handleStream)</code> 来设置流的处理函数</p><p>在这里 <code>/echo/1.0.0</code> 是指定的协议 id，可以根据不同的需要来进行设定</p><h3 id="发送方函数"><a href="#发送方函数" class="headerlink" title="发送方函数"></a>发送方函数</h3><p><code>NewStream</code> 函数在成功创建流之后会返回一个 <code>Stream</code> 对象，后续可以通过这个对象来收发数据，基于此可以编写一个 <code>sendMessage</code> 的函数作为控制台消息写入协程</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(s network.Stream)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line">buf := bufio.NewReader(s)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := fmt.Scan(&amp;msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Read data from console failed.&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">msg += <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">_, err = s.Write([]<span class="type">byte</span>(msg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Write message to stream failed.&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str, err := buf.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">logrus.Infof(<span class="string">&quot;Read from stream: %s&quot;</span>, str[:<span class="built_in">len</span>(str)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，在 <code>main</code> 函数中连接到对端节点后添加</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream, err := host.NewStream(ctx, addr.ID, <span class="string">&quot;/echo/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create stream failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sendMessage(stream)</span><br></pre></td></tr></table></figure><p>对应于上一段代码，此时的程序在省略掉部分代码后如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">logrus.Infoln(<span class="string">&quot;Create new libp2p host, listen addresses: &quot;</span>, host.Addrs())</span><br><span class="line">logrus.Infof(<span class="string">&quot;Node address: /ip4/127.0.0.1/tcp/%v/p2p/%s&quot;</span>, port, host.ID().String())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> peerAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">logrus.Infof(<span class="string">&quot;Connect to node %s success.&quot;</span>, peerAddr)</span><br><span class="line"></span><br><span class="line">stream, err := host.NewStream(ctx, addr.ID, <span class="string">&quot;/echo/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create stream failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sendMessage(stream)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(s network.Stream)</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleStream</span><span class="params">(s network.Stream)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>至此，实现了一个基于 go-libp2p 完成的节点间通信程序。而需要建立一个 P2P 网络所需要的则是连接到一个节点后能够发现其他节点并且进行通信，以及指定节点 id 来进行通信。所以，下一节的内容则是利用 kademlia 库来进行节点的发现和连接。</p><h1 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h1><p>在 go-libp2p 中实现了多种节点发现协议：Rendezvous、mDNS 和 DHT<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is Discovery & Routing ](https://docs.libp2p.io/concepts/discovery-routing/overview/)">[5]</span></a></sup>，在这里，使用 DHT 来进行节点的发现，对应 go-libp2p 的子模块库是 go-libp2p-kad-dht。对于 Kademlia 协议，可以参考 <a href="https://decision01.com/2022/09/27/Kademlia%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%B9%BF%E6%92%AD%E6%96%B9%E6%B3%95/">Kademlia 协议及广播方法</a> (没写完，可以看看参考文章)此外， go-libp2p-kad-dht 的使用还可以在本文之外参考 <a href="https://ldej.nl/post/building-an-echo-application-with-libp2p/">Building an echo application with libp2p</a><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Building an echo application with libp2p](https://ldej.nl/post/building-an-echo-application-with-libp2p/)">[4]</span></a></sup></p><p>有了节点连接建立的基础后，节点的发现和连接就较为简单了（代码量不大，麻烦的是查阅资料）</p><h2 id="KDHT-实例创建"><a href="#KDHT-实例创建" class="headerlink" title="KDHT 实例创建"></a>KDHT 实例创建</h2><p>使用 go-libp2p-kad-dht 需要创建一个 kdht 实例，在完成 host 的创建后可以传入 <code>host</code> 来建立实例，并且调用 <code>Bootstrap</code> 来启动路由的维护，以下是创建 kdht 实例的代码，传入的参数 <code>bootstrapPeers</code> 是启动节点数组，分两种情况考虑：</p><ul><li>空数组：没有启动节点，自身作为一个启动节点</li><li>非空数组：启动节点列表，依次遍历所有的节点地址并且尝试连接，在建立连接后可以发现其他节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKDHT</span><span class="params">(ctx context.Context, host host.Host, bootstrapPeers []multiaddr.Multiaddr)</span></span> (*dht.IpfsDHT, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> options []dht.Option</span><br><span class="line"><span class="comment">// Start with server mode</span></span><br><span class="line">options = <span class="built_in">append</span>(options, dht.Mode(dht.ModeServer))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create new kad-dht instance</span></span><br><span class="line">kdht, err := dht.New(ctx, host, options...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create new kad-dht instance failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bootstrap the kad-dht instance</span></span><br><span class="line"><span class="keyword">if</span> err = kdht.Bootstrap(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Bootstrap kad-dht failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, peerAddr := <span class="keyword">range</span> bootstrapPeers &#123;</span><br><span class="line">info, _ := peer.AddrInfoFromP2pAddr(peerAddr)</span><br><span class="line"><span class="keyword">if</span> err := host.Connect(ctx, *info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorf(<span class="string">&quot;Errored while connecting to node #%s&quot;</span>, *info)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logrus.Infoln(<span class="string">&quot;Connection established with bootstrap node: %q&quot;</span>, *info)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kdht, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由表查询"><a href="#路由表查询" class="headerlink" title="路由表查询"></a>路由表查询</h2><p>在完成 kad-dht 实例的创建后，可以通过它来进行路由表的查询以发现其他节点</p><p>这个过程的初始化需要以下对象：</p><ul><li>context：上下文，以便同步关闭协程</li><li>host：创建的节点实例，用于发起流的创建</li><li>dht：创建的 kad-dht 实例，用于进行路由表中其他节点的发现</li><li>rendezvous：节点发现”密钥“，被称为”集合点”，节点们通过这个值来查找到对等的节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Discover</span><span class="params">(ctx context.Context, h host.Host, dht *dht.IpfsDHT, rendezvous <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create new discovery object</span></span><br><span class="line"><span class="keyword">var</span> routingDiscovery = routing.NewRoutingDiscovery(dht)</span><br><span class="line">dutil.Advertise(ctx, routingDiscovery, rendezvous)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh per 500ms</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            <span class="comment">// Refresh routing table</span></span><br><span class="line">dht.RefreshRoutingTable()</span><br><span class="line">            <span class="comment">// Find other peers</span></span><br><span class="line">peers, err := routingDiscovery.FindPeers(ctx, rendezvous)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithField(<span class="string">&quot;error&quot;</span>, err).Debugln(<span class="string">&quot;Find peers failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">                <span class="comment">// Check whether is self host</span></span><br><span class="line"><span class="keyword">if</span> p.ID == h.ID() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check connected</span></span><br><span class="line"><span class="keyword">if</span> h.Network().Connectedness(p.ID) != network.Connected &#123;</span><br><span class="line">_, err := h.Network().DialPeer(ctx, p.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">&quot;peerID&quot;</span>: p.ID,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:  err,</span><br><span class="line">&#125;).Debugln(<span class="string">&quot;Connect to node failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">stream, err := h.NewStream(ctx, p.ID, <span class="string">&quot;/echo/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create new stream failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... some function with stream</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在较老的版本中，rendezvous 是通过 <code>discovery.Advertise(ctx, routingDiscovery, rendezvous)</code> 来“宣布”的，但是在目前的版本下貌似不能生效，需要使用 <code>dutil.Advertise(ctx, routingDiscovery, rendezvous)</code></p><p>而最为关键的也是 ticker 的处理函数，<code>dht.RefreshRoutingTable()</code> 刷新路由表，然后使用 <code>FindPeers</code> 函数在“集合点”发现其他节点；它会返回一个 具有一系列 Peer 的 channel，遍历这个 channel 可以获取到对端节点的信息</p><p>并且在得到节点信息后需要根据节点 id 是否为自身，否则会和本地的节点建立流，以及查询是否以及建立了连接，以便在建立数据流之前建立连接。在完成流的建立后，可以基于这个流来进行节点间的通信。要实现一个可以指定节点 id 发送消息的应用，可以添加其他逻辑代码后实现。</p><h1 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h1><p>消息广播对应的库是 <a href="https://github.com/libp2p/go-libp2p-pubsub">go-libp2p-pubsub</a>，目前所实现的广播路由方式有：1、Gossip 协议<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[一致性算法-Gossip协议详解](https://cloud.tencent.com/developer/article/1662426)">[6]</span></a></sup>；2、 Flood 洪泛协议<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[洪泛路由](https://zh.wikipedia.org/wiki/%E6%B4%AA%E6%B3%9B%E8%B7%AF%E7%94%B1)">[7]</span></a></sup>；3、 随机路由；同时，go-libp2p 的文档中也写了发布/订阅模式的相关原理<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is Publish/Subscribe](https://docs.libp2p.io/concepts/pubsub/overview/)">[8]</span></a></sup>，但是没有涉及到具体的使用；</p><p>消息的广播和订阅涉及到四个函数:</p><ul><li><code>NewGossipSub</code>：创建一个 Gossip 广播对象，go-libp2p 底层会创建流，gossip 所使用的的是其底层建立的流，且创建的对象是一个单例</li><li><code>Join</code>：加入一个 topic，并返回一个 <code>Topic</code> 对象，调用其 <code>Subscribe</code> 函数进行订阅</li><li><code>Subscribe</code>：订阅 topic，返回 <code>Subscription</code> 对象，用于后续接收其他节点广播的消息</li><li><code>Publish</code>：广播消息到某个 topic，向订阅了该 topic 的所有节点发送消息</li></ul><p><strong>注：go-libp2p-pubsub 默认的消息限制为 1M，所以大于 1M 的消息无法广播到其他节点会被直接丢弃</strong></p><p>前三个函数在具体使用时如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">goosip, err := pubsub.NewGossipSub(ctx, h)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Create new gossip subscribe failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topic, err := goosip.Join(<span class="string">&quot;/gossip/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Join topic /gossip/1.0.0 failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub, err := topic.Subscribe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Subscribe topic failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，sub 对象需要一个协程来专门进行处理，协程可以从中取出消息并且进行处理，这个函数通常实现为下面的样子，持续取出消息并且判断是否是自身发出的广播消息，如果是则丢弃，否则进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSub</span><span class="params">(ctx context.Context, sub *pubsub.Subscription, h host.Host)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := sub.Next(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Get data from subscription failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> msg.ReceivedFrom == h.ID() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... do something with msg.Data</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，还需要使用 <code>Publish</code> 进行消息的广播，这也较为简单，可以编写一个函数从 channel 中读出消息并且广播到网络中，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcastMessage</span><span class="params">(msgChan <span class="keyword">chan</span> <span class="type">string</span>, topic *pubsub.Topic)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-msgChan:</span><br><span class="line">err := topic.Publish(context.Background(), []<span class="type">byte</span>(msg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Publish message failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go-libp2p-pubsub 在发送时会将它打包到一个定义好的 proto 结构体中，序列化后发送，所以在 <code>handleSub</code> 中还需要通过 <code>msg.Data</code> 获取字节数据</p><h1 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h1><p>最后这里放一些使用时会遇到的配置问题，go-libp2p 中会有许多的自定义配置，但是在文档中都没有一一列举，只能自行查阅代码</p><h3 id="网络资源限制"><a href="#网络资源限制" class="headerlink" title="网络资源限制"></a>网络资源限制</h3><p>资源管理器可以用来限制节点对流的创建、连接的创建所消耗的网络资源，这里需要一个函数来创建一个资源管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildResourceManager</span><span class="params">()</span></span> *network.ResourceManager &#123;</span><br><span class="line">scalingLimits := rcmgr.DefaultLimits</span><br><span class="line">libp2p.SetDefaultServiceLimits(&amp;scalingLimits)</span><br><span class="line">scaledDefaultLimits := scalingLimits.AutoScale()</span><br><span class="line"></span><br><span class="line">cfg := rcmgr.PartialLimitConfig&#123;</span><br><span class="line">System: rcmgr.ResourceLimits&#123;</span><br><span class="line"><span class="comment">//Conns: 20,</span></span><br><span class="line">Streams: <span class="number">50</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">limits := cfg.Build(scaledDefaultLimits)</span><br><span class="line">limiter := rcmgr.NewFixedLimiter(limits)</span><br><span class="line">rm, err := rcmgr.NewResourceManager(limiter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorln(<span class="string">&quot;Build resource manager failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;rm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里限制了流的最大数量为50，在节点启动前可以创建这样一个资源管理器，并且引入到节点配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host, err := libp2p.New(</span><br><span class="line">    libp2p.ResourceManager(*rm),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更多的配置需要参阅：<a href="https://pkg.go.dev/github.com/srene/go-libp2p/p2p/host/resource-manager">The libp2p Network Resource Manager</a></p><h3 id="广播调整"><a href="#广播调整" class="headerlink" title="广播调整"></a>广播调整</h3><p>正如前面所说，go-libp2p-pubsub 中限制了最大广播数据大小为 1M，在某些场景下是不够的，所以需要进行调整</p><p>这需要在创建 Gossip 对象的时候引入配置，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pubsubMaxSize = <span class="number">1</span> &lt;&lt; <span class="number">22</span> <span class="comment">// 4 MB</span></span><br><span class="line"></span><br><span class="line">gossip, err = pubsub.NewGossipSub(ctx, h,</span><br><span class="line">    pubsub.WithMaxMessageSize(pubsubMaxSize),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过这样的代码可以将广播调整为 4M 内进行广播，其他的配置目前笔者还没有涉及到，在未来涉及到更多的自定义配置时会更新到这里。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1988253">长安链P2P网络技术介绍（2）：初识LibP2P</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/superblockchain/p/14103338.html">从 go-libp2p 开始</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/libp2p/specs/blob/master/addressing/README.md">Addressing in libp2p</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://ldej.nl/post/building-an-echo-application-with-libp2p/">Building an echo application with libp2p</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.libp2p.io/concepts/discovery-routing/overview/">What is Discovery &amp; Routing </a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1662426">一致性算法-Gossip协议详解</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E6%B4%AA%E6%B3%9B%E8%B7%AF%E7%94%B1">洪泛路由</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.libp2p.io/concepts/pubsub/overview/">What is Publish/Subscribe</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;做区块链相关的项目</summary>
      
    
    
    
    <category term="Dev" scheme="http://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="http://decision01.com/tags/golang/"/>
    
    <category term="go-libp2p" scheme="http://decision01.com/tags/go-libp2p/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 指标监控</title>
    <link href="http://decision01.com/post/cc6b7110.html"/>
    <id>http://decision01.com/post/cc6b7110.html</id>
    <published>2023-08-01T07:57:27.000Z</published>
    <updated>2024-04-08T08:03:49.041Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Prometheus 是由 SoundCloud 开源的监控告警解决方案<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Prometheus学习笔记（1）Prometheus架构简介](https://www.cnblogs.com/linuxk/p/12017580.html)">[3]</span></a></sup>,它可以被用于程序暴露一系列监控指标给外界，用于对程序的性能、运行状态进行监控，并且还提供了监控告警功能。</p><h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p>以下是官方给出的架构图</p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/006tNbRwly1fwcgsn11fej311j0mjadw.jpg" alt="Prometheus 架构图" style="zoom:50%;"><p>在图中，Prometheus 的组成部分有<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Prometheus学习笔记（1）Prometheus架构简介](https://www.cnblogs.com/linuxk/p/12017580.html)">[3]</span></a></sup>：</p><ul><li>Prometheus Server：抓取和存储时间序列化数据</li><li>Exporters：主动拉取数据的插件</li><li>Pushgateway：被动拉取数据的插件</li><li>Altermanager：告警信息发送模块</li><li>Prometheus web UI：界面化，包含结合 Grafana 进行数据展示或告警发送</li></ul><p>其工作逻辑如下<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Prometheus](https://jimmysong.io/kubernetes-handbook/practice/prometheus.html)">[4]</span></a></sup>：</p><ol><li>Prometheus server 定期从静态配置的目标（target）或服务发现的目标中拉取指标（metric）数据；</li><li>拉取数据大于内存缓冲区大小时，将数据持久化到数据库（时序数据库）；</li><li>Prometheus 可以配置规则，用于定时查询数据，在条件触发时将警告推送到配置的 Altermanager；</li><li>Altermanager 受到告警时，可以根据配置，聚合、去重、降噪，最后发送警告；</li><li>可以使用 API、Prometheus Console 或者 Grafana 查询和聚合数据；</li></ol><h1 id="四大指标类型"><a href="#四大指标类型" class="headerlink" title="四大指标类型"></a>四大指标类型</h1><p>这里主要是 Golang 下的 Prometheus 指标，需要其它语言可以根据需求查找<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[程序监控（一）Prometheus的四种类型及golang示例](https://zhuanlan.zhihu.com/p/592560633)">[1]</span></a></sup></p><p>Prometheus 定义了四种不同的指标类型<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Metrics类型](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-metrics-types)">[2]</span></a></sup>：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）</p><ul><li><p><strong>Counter</strong>：只增不减的计数器</p><p>  Counter Metrics 是<strong>只能递增</strong>的值，可以一用来记录 API 的请求次数、错误码的触发次数，它的接口如下</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter by 1. Use Add to increment it by arbitrary non-negative values.</span></span><br><span class="line">    <span class="comment">// Inc 方法会为计数器 +1</span></span><br><span class="line">Inc()</span><br><span class="line"><span class="comment">// Add adds the given value to the counter. It panics if the value is &lt; 0.</span></span><br><span class="line">    <span class="comment">// 传入一个 value 为计数器添加对应的值，如果小于 0 会报 painc</span></span><br><span class="line">Add(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Gauge</strong>：可增可减的仪表盘</p><p>  Gauge Metrics 侧重于反应系统当前的状态，这样的数据<strong>可增可减</strong>，也可以直接设置，常用于显示当前主机的空闲内容大小、可用的内存大小，其接口如下</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Gauge <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the Gauge to an arbitrary value.</span></span><br><span class="line">    <span class="comment">// 为该指标设置一个值</span></span><br><span class="line">Set(<span class="type">float64</span>)</span><br><span class="line"><span class="comment">// Inc increments the Gauge by 1. Use Add to increment it by arbitrary values.</span></span><br><span class="line">    <span class="comment">// 为该指标增加 1</span></span><br><span class="line">Inc()</span><br><span class="line"><span class="comment">// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary values.</span></span><br><span class="line">    <span class="comment">// 为该指标减少 1</span></span><br><span class="line">Dec()</span><br><span class="line">    <span class="comment">// 为指标增加一个指定值</span></span><br><span class="line"><span class="comment">// Add adds the given value to the Gauge. (The value can be negative, resulting in a decrease of the Gauge.)</span></span><br><span class="line">Add(<span class="type">float64</span>)</span><br><span class="line">    <span class="comment">// 为减去一个指定值</span></span><br><span class="line"><span class="comment">// Sub subtracts the given value from the Gauge. (The value can be negative, resulting in an increase of the Gauge.)</span></span><br><span class="line">Sub(<span class="type">float64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetToCurrentTime sets the Gauge to the current Unix time in seconds.</span></span><br><span class="line">SetToCurrentTime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Histograms</strong>：指定范围的直方图</p><p>  Histograms 是直方图度量类型，测量落在定义的桶中的数据的数据的值，可以用于记录 API 服务的请求耗时在所有桶中的分布情况、或者消费者处理某个事件的好事在所有桶中的分布情况，其接口也比较简单</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Histogram <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observe adds a single observation to the histogram. Observations are</span></span><br><span class="line"><span class="comment">// usually positive or zero. Negative observations are accepted but</span></span><br><span class="line"><span class="comment">// prevent current versions of Prometheus from properly detecting</span></span><br><span class="line"><span class="comment">// counter resets in the sum of observations. (The experimental Native</span></span><br><span class="line"><span class="comment">// Histograms handle negative observations properly.) See</span></span><br><span class="line"><span class="comment">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span></span><br><span class="line"><span class="comment">// for details.</span></span><br><span class="line">    <span class="comment">// 传入一个观察值，这个值通常是大于等于 0 的数，负的值也可以接受</span></span><br><span class="line">    <span class="comment">// 但是导致检测观测值总和中的计时器不能正常重置</span></span><br><span class="line">Observe(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Summary</strong>：分位数下的直方图</p><p>  Summary 和 Histograms 一样是统计直方图数据，但是也存在不一样的地方：</p><ul><li>Summary 基于分位数来统计数据，而 Histogram 基于桶来统计数据</li><li>Histogram 的分位数在 Prometheus 上计算，而 Summary 则是在提供度量数据的应用上来计算，此后再暴露数据到接口外</li><li>Summary 用于需要计算准确的分位数，但是并不能知道值的精确范围</li></ul><p>  它的接口和 Histogram 类似</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Summary <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observe adds a single observation to the summary. Observations are</span></span><br><span class="line"><span class="comment">// usually positive or zero. Negative observations are accepted but</span></span><br><span class="line"><span class="comment">// prevent current versions of Prometheus from properly detecting</span></span><br><span class="line"><span class="comment">// counter resets in the sum of observations. See</span></span><br><span class="line"><span class="comment">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span></span><br><span class="line"><span class="comment">// for details.</span></span><br><span class="line">Observe(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实时指标监控"><a href="#实时指标监控" class="headerlink" title="实时指标监控"></a>实时指标监控</h1><p>使用 Prometheus 对程序进行监控并且实时观察指标有三个步骤：</p><ul><li>在程序中编写指标监控代码，并且暴露一个http服务便于外界拉取数据；</li><li>安装 Prometheus 服务端，在配置文件下指定需要监控的 http 链接并启动；</li><li>进一步地，如果需要对多个指标同时进行实时的查看，可以安装 Grafana 进行数据的实时监控；</li></ul><h2 id="指标服务及代码"><a href="#指标服务及代码" class="headerlink" title="指标服务及代码"></a>指标服务及代码</h2><p>要对外界暴露指标的服务接口，需要指定端口并启动服务，在 golang 中暴露 mertics 服务的代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中获取端口</span></span><br><span class="line">metricPort := <span class="string">&quot;:&quot;</span> + config.String(<span class="string">&quot;metrics.port&quot;</span>)</span><br><span class="line">http.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line"><span class="comment">// 启动协程进行服务</span></span><br><span class="line"><span class="keyword">go</span> http.ListenAndServe(metricPort, <span class="literal">nil</span>)</span><br><span class="line">log.Infof(<span class="string">&quot;Metric server start on localhost%s&quot;</span>, metricPort)</span><br></pre></td></tr></table></figure><p>此外，还需要注册指标并且对指标进行操作，例如，使用仪表盘来监控一个节点下的交易数量，需要注册一个仪表盘指标</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">poolTransactionsMetric = promauto.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">&quot;core_tx_pool_transactions&quot;</span>,</span><br><span class="line">Help: <span class="string">&quot;Transaction count in memory pool.&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在接收交易时，可以通过调用 <code>Inc</code> 方法来对指标 +1</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poolTransactionsMetric.Inc()</span><br></pre></td></tr></table></figure><p>类似地，可以调用 <code>Dec</code> 方法在打包交易时对指标 -1</p><p>假设暴露的端口是 9090，在完成这些工作后可以访问 <a href="http://localhost:8700/metrics">http://localhost:8700/metrics</a> 得到指标数据，这些指标表现为键值对的形式</p><p>而 Prometheus 的服务端就是根据配置文件，每隔一段时间访问 targets 来获取指标数据并进行解析，并且放入内存、数据库</p><h2 id="Prometheus-安装以及配置"><a href="#Prometheus-安装以及配置" class="headerlink" title="Prometheus 安装以及配置"></a>Prometheus 安装以及配置</h2><p>Prometheus 本身是一个开源项目，所以可以直接安装程序并启动，例如目前最新的已编译好的安装包在 <a href="https://github.com/prometheus/prometheus/releases/tag/v2.46.0">Prometheus 2.46.0</a></p><p>此外，也有 windows 下的安装教程 <a href="https://blog.csdn.net/qq_38362419/article/details/108527506">Windows 安装 prometheus + grafana</a></p><p>以及在安装后需要修改配置文件 <code>prometheus.yml</code>，一个简单的配置文件如下：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">1s</span><span class="comment"># 监控间隔时间，每隔多少时间拉取一次数据</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;prometheus&quot;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="comment"># 监控的目标，这里是一个 ip:port 数组</span></span><br><span class="line">        <span class="string">&quot;localhost:8700&quot;</span>,</span><br><span class="line">        <span class="string">&quot;localhost:8701&quot;</span>,</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure><p>如果配置文件中没有设置端口，默认会使用 9090 端口来暴露 Prometheus 的数据查询服务</p><p>最后，Grafana 的安装和使用不再进行赘述，Grafana 类似一个数据库查询展示工具，它通过拉取 Prometheus 暴露的数据查询服务来得到信息并在前端进行展示，例如对节点的一系列指标监控如下</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/QQ20230703-110943@2x.png" alt="QQ20230703-110943@2x"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/592560633">程序监控（一）Prometheus的四种类型及golang示例</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-metrics-types">Metrics类型</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/linuxk/p/12017580.html">Prometheus学习笔记（1）Prometheus架构简介</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://jimmysong.io/kubernetes-handbook/practice/prometheus.html">Prometheus</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Prometheus 是由 SoundCloud 开源的监控告警解决方案&lt;s</summary>
      
    
    
    
    <category term="Dev" scheme="http://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="http://decision01.com/tags/golang/"/>
    
    <category term="metrics" scheme="http://decision01.com/tags/metrics/"/>
    
  </entry>
  
  <entry>
    <title>Json Web Token</title>
    <link href="http://decision01.com/post/9f5baac8.html"/>
    <id>http://decision01.com/post/9f5baac8.html</id>
    <published>2023-07-16T13:35:55.000Z</published>
    <updated>2024-04-08T08:03:49.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Json Web Token (JWT) 是一个开放标准（RFC 7519），它符合设计 Restful API 时的<strong>无状态原则</strong>，每一次从客户端向服务器发出的请求都是独立的。</p><p>JWT 由三个部分组成：Header、Payload 和 Signature，它是一个长字符串，每个子串之间不存在换行符，一般的格式是<code>[Header].[Payload].[Signature]</code></p><p>其 <code>Header</code> 承载了两部分信息：类型和所使用的密码算法，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Payload</code> 存放了实际需要传递的数据，JWT 中所规定的 7 个可选用的常规字段如下，负载默认是不会进行加密的，所以<strong>不可以用来存放秘密信息</strong></p><table><thead><tr><th>Field</th><th>Name</th><th>Desc</th></tr></thead><tbody><tr><td>iss</td><td>Issuer</td><td>签发人</td></tr><tr><td>exp</td><td>Expiration Time</td><td>过期时间</td></tr><tr><td>sub</td><td>Subject</td><td>主题</td></tr><tr><td>aud</td><td>Audience</td><td>受众</td></tr><tr><td>nbf</td><td>Not Before</td><td>生效时间</td></tr><tr><td>iat</td><td>Issued At</td><td>签发时间</td></tr><tr><td>jti</td><td>JWT ID</td><td>编号</td></tr></tbody></table><p><code>Signature</code> 是对前面两部分消息的签名，以避免数据被篡改，<strong>签名的密钥只有服务器知道</strong>，使用 <code>Header</code> 指定的签名算法来产生签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAMAC-SHA256(base64(header) + &quot;.&quot; + base64(payload), secret)</span><br></pre></td></tr></table></figure><p>客户端在通过认证后接收服务器返回的 JWT，将其存放在 cookie 或 localStorage 中，此后客户端会在与服务器的交互中都携带 JWT 以表明自身身份</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Json Web Token (JWT) 是一个开放标准（RFC 7519）</summary>
      
    
    
    
    <category term="Wiki" scheme="http://decision01.com/categories/Wiki/"/>
    
    
    <category term="cryptography" scheme="http://decision01.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Golang 泛型编程</title>
    <link href="http://decision01.com/post/26091937.html"/>
    <id>http://decision01.com/post/26091937.html</id>
    <published>2023-06-18T08:02:33.000Z</published>
    <updated>2024-04-08T08:03:49.039Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>这里涉及到要学习泛型是由于工程里面遇到一个问题，<a href="https://github.com/inkeliz/karmem">karmem</a> 下在序列化和反序列化的时候所编写的代码在很大程度上是相似的</p><p>于是解决方案就是为不同的结构体都写对应的序列化和反序列化函数来封装</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeGeneralParams</span><span class="params">(byteParamsData []<span class="type">byte</span>)</span></span> (*common.GeneralParams, <span class="type">error</span>) &#123;</span><br><span class="line">generalParams := <span class="built_in">new</span>(common.GeneralParams)</span><br><span class="line">generalParams.ReadAsRoot(karmem.NewReader(byteParamsData))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generalParams, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样又存在一个问题，每次新增结构体都需要 copy 新的函数为它进行反序列化和序列化，那么就特别麻烦，所以考虑能不能通过泛型实现类似下面的操作</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeKarmemStruct</span>[<span class="title">T</span> <span class="title">KarmemStruct</span>]<span class="params">(byteParamsData []<span class="type">byte</span>)</span></span> (*T, <span class="type">error</span>) &#123;</span><br><span class="line">generalParams := <span class="built_in">new</span>(T)</span><br><span class="line">T.ReadAsRoot(karmem.NewReader(byteParamsData))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generalParams, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将一系列 Karmem 生成的类的反序列化放到一起，现在看完了泛型的一系列东西后貌似无法解决这个问题（？</p></blockquote><h1 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h1><p>在一个简单的实现加法的函数中，函数上写明的 <code>a int, b int</code> 是<strong>形参</strong>（Parameter）列表，只有在调用时传入的值才是<strong>实参</strong>（Argument）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>将形参和实参的概念进行推广，给类型引入类似形参和实参的概念后，就可以有类型形参（Type Paramether） 和类型实参（Type Argument）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 是这里的类型形参，在定义函数时类型补确定，只有在函数被调用时再传入具体的类型，这里被传入的具体类型就是类型实参</p><p>传入类型实参的方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add[T=<span class="type">int</span>](<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><p><strong>问题提出</strong></p><p>考虑一个例子</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a IntSlice = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b IntSlice = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>b</code> 的赋值不能实现，这是由于 <code>IntSlice</code> 的底层类型是 <code>[]int</code>，浮点类的 Slice 不能进行赋值</p><p>如果需要不同类型的切片，可以考虑为每种类型都定义新的类型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Float32Slice []<span class="type">float32</span></span><br></pre></td></tr></table></figure><p><strong>解决方法</strong></p><p>这样为每个不同的成员类型定义新类型的方法<strong>极为繁琐</strong>，所以就要使用到泛型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>|<span class="type">float32</span>|<span class="type">float64</span>] []T</span><br></pre></td></tr></table></figure><ul><li><code>T</code> 是<strong>类型形参（Type Parameter）</strong>，定义 Slice 时其代表的类型不确定，它是一个占位符</li><li><code>int|float32|float64</code> 是<strong>类型约束（Type Constraint）</strong>，用于说明类型形参只能接受哪些类型的实参（有点类似于对形参的类型定义）</li><li><code>T</code> 和 <code>int|float32|float64</code> 构成了<strong>类型形参列表（Type Parameter List）</strong></li></ul><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><p>使用类型形参来替代原有的类型，可以定义一个泛型函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">float32</span>|<span class="title">float64</span>] <span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前实现不同的是这里添加了类型约束，保证函数的类型只能使用这三种类型，使用泛型函数需要传入类型实参</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add[<span class="type">int</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Add[<span class="type">float32</span>](<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>也可以直接传入参数让编译器自行推导类型实参（让编译器推导类型后传入参数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add(1, 2)</span><br><span class="line">Add(1.0, 2.0)</span><br></pre></td></tr></table></figure><p>需要注意的是下面两种情况不能使用泛型函数：</p><ul><li><p>在匿名函数中使用未定义的类型形参（但是可以使用已定义的形参）</p></li><li><p>不支持泛型方法，即 receiver 下不能支持泛型</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A)</span></span> Add[T <span class="type">int</span>|<span class="type">float32</span>|<span class="type">float64</span>](a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但是可以通过 receiver 来使用类型形参</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span></span> Add(a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a A[<span class="type">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="type">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="组合与底层类型"><a href="#组合与底层类型" class="headerlink" title="组合与底层类型"></a>组合与底层类型</h1><p>考虑现在一个泛型类型下有一系列类型的类型约束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>|<span class="type">int8</span>|<span class="type">int16</span>|<span class="type">int32</span>|...|<span class="type">uint32</span>|<span class="type">uint64</span>] []T;</span><br></pre></td></tr></table></figure><p>为了实现对这样的代码进行维护，可以对类型进行分类后把类型约束写入到接口类型中，即可以在类型约束中进行嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span>|<span class="type">int8</span>|<span class="type">int16</span>|<span class="type">int32</span>|<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line"> <span class="type">uint</span>|<span class="type">uint8</span>|<span class="type">uint16</span>|<span class="type">uint32</span>|<span class="type">uint64</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int|Uint] []T</span><br></pre></td></tr></table></figure><p>如果要使得最终的类型定义更为简单，可以在 <code>interface</code> 中进行嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">Int|Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><p>通过 <code>interface</code> 进行嵌套并在类型约束中进行组合的方式，就可以使得后续对代码的维护更为方便。但是这样的方式存在的缺陷是，如果类型约束中包含了一种类型 <code>type1</code>，另外一种类型通过 <code>type1</code> 定义了 <code>type type2 type1 </code>，这样的情况下就不能满足类型约束条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]</span><br></pre></td></tr></table></figure><p>这样的代码在第四行是错误的，因为虽然其底层类型是 <code>int</code>，但是它自身并不是 <code>int</code> 类型，不符合类型约束</p><p>于是可以使用 <code>~</code> 来表示类型约束的底层类型，例如 <code>type Slice [T ~int|~float32]</code>，这样只要底层类型满足约束条件即可，使用该符号的限制是</p><ul><li>符号后类型不能是接口</li><li>符号后类型必须为底层类型</li></ul><h1 id="类型集"><a href="#类型集" class="headerlink" title="类型集"></a>类型集</h1><p>在 Go 1.18 之前， Go 官方对接口的定义是：</p><blockquote><p>An interface type specifies a method set called its interface</p></blockquote><p>对于 <code>ReaderWriter</code> 接口，它定义了一个接口，这个集合中包含了 <code>Read</code> 和 <code>Write</code> 两种方法，所有同时定义了这两种方法的类型被称为实现了该接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderdWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err error0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从另外一个角度来看，<code>ReaderWriter</code> 可以是一个类型的集合，所有实现了其包含的两个方法的类型都在接口代表的类型集合中，这样就是一个类型集（Type Set）</p><p>在可以使用接口来简化类型约束后，接口就有了定义类型集的作用，在原来的功能上，它只是定义一系列的方法，所以是方法集</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">Int|Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><p>在这里，类型接口 <code>SliceElement</code> 是一个类型集合，所有满足约束 <code>Int|Uint</code> 的类型都在这一类型集中</p><p><code>type Slice[T SliceElement] []T</code>中，类型约束指定了形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化</p><p>原有的实现某个接口的定义是：<strong>实现了一个接口的所有方法那么就隐式地实现了这个接口</strong></p><p>而现在，如果类型 T 满足下面的条件，那么就说它实现了接口 I:</p><ul><li>T 不是接口时：<strong>类型</strong> T 是接口 I 代表的类型集中的<strong>一个成员</strong></li><li>T 是接口时：T 接口代表的类型集是 I 代表的类型集合的<strong>子集</strong></li></ul><h2 id="基本接口和一般接口"><a href="#基本接口和一般接口" class="headerlink" title="基本接口和一般接口"></a>基本接口和一般接口</h2><p>基本接口：在 Go 1.18 前的方法集，即接口定义中只有方法的接口被称为基本接口</p><p>一般接口：而如果一个接口中不只有方法，还有类型，那么这样的接口就被称为一般接口</p><p><strong>一般接口类型不能用于定义变量，只能用于进行泛型的约束</strong></p><p>到这里该写的也写的差不多了，剩下一些东西可以在 <a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a> 里翻一下，里面写的比较详细</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a></li><li><a href="https://alankrantas.medium.com/%E7%B0%A1%E5%96%AE%E7%8E%A9-go-1-18-%E6%B3%9B%E5%9E%8B-1d09da07b70">https://alankrantas.medium.com/%E7%B0%A1%E5%96%AE%E7%8E%A9-go-1-18-%E6%B3%9B%E5%9E%8B-1d09da07b70</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;这里涉及到要学习泛型是由于工程里面遇到一个问题，&lt;</summary>
      
    
    
    
    <category term="Dev" scheme="http://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="http://decision01.com/tags/golang/"/>
    
    <category term="generic" scheme="http://decision01.com/tags/generic/"/>
    
  </entry>
  
  <entry>
    <title>BIP、闪电网络与 Trao</title>
    <link href="http://decision01.com/post/4f925910.html"/>
    <id>http://decision01.com/post/4f925910.html</id>
    <published>2023-05-26T07:19:07.000Z</published>
    <updated>2024-04-08T14:56:25.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="BIP-标准"><a href="#BIP-标准" class="headerlink" title="BIP 标准"></a>BIP 标准</h1><p>比特币改进建议（Bitcoin Improvement Proposal, BIP）是 Amir Taaki 在2001年的 <a href="https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki">BIP-0001</a> 中提出，由 Luke Dash Jr. 在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki">BIP-0002</a> 中对该标准进行了扩展<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[什么是BIP？一分钟搞懂BIP标准](https://www.jinse.com/blockchain/465498.html)">[1]</span></a></sup>。</p><blockquote><p>BIP stands for Bitcoin Improvement Proposal. A BIP is a design document providing information to the Bitcoin community, or describing a new feature for Bitcoin or its processes or environment. The BIP should provide a concise technical specification of the feature and a rationale for the feature.</p><p>BIP 代表比特币改进提案。BIP是向比特币社区提供信息的设计文档，或描述比特币或其流程或环境的新功能。BIP 应提供该功能的简明技术规范和功能的基本原理。</p></blockquote><p>本文主要着重深入对闪电网络和 Trao 资产的研究，于是这里只会提及相关的部分标准。</p><h2 id="地址标准"><a href="#地址标准" class="headerlink" title="地址标准"></a>地址标准</h2><p>截止到今天，比特币区块链有四种不同的地址标准，分别是遗留（Legacy）地址，支付脚本哈希（Pay to Script Hash, P2SH）地址，隔离见证（SegWit）地址，主根（Taproot）地址<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[科普| 比特币地址有哪些？ - BlockBeats](https://m.theblockbeats.info/news/37101)">[2]</span></a></sup>。在本文中，和 Trao 资产最为相关的是最后一种地址 —— Traproot。</p><h3 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h3><p>Legacy 地址也被称为传统地址，它是比特币区块)链诞生开始就使用的地址。这样的地址以1开头，其生成流程如下</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312207185.jpg" alt="Legacy(4)"></p><p>依据 <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-0032 (公钥分层推导标准)</a> 和 <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-0044 （派生路径标准）</a>，一个私钥可以对应派生出不同的公钥，由此也可以通过一个私钥管理多个地址。</p><p>由于在这里地址的生成过程中使用到了对公钥的哈希，这样的地址类型也被称为向公钥哈希支付（Pay to Public Key HasH, P2PKH）。这样的交易方式下，发送方需要在发送交易时嵌入 PubKey 脚本以将比特币发送给目标地址<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[比特币升级提案 Taproot 技术解读](https://www.btcstudy.org/2021/09/29/bitcoin-taproot-a-technical-explanation/)">[3]</span></a></sup>。</p><h3 id="P2SH"><a href="#P2SH" class="headerlink" title="P2SH"></a>P2SH</h3><p>P2SH 是另外一种地址类型，它被称为“向脚本支付”，从名称上就已经决定了这样的地址的使用方式和 Legacy 地址的不同，其地址以 3 开头。P2SH 是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP-0016</a> 中被提出，它被提出的动机是：</p><blockquote><p>The purpose of pay-to-script-hash is to move the responsibility for supplying the conditions to redeem a transaction from the sender of the funds to the redeemer.</p><p>The benefit is allowing a sender to fund any arbitrary transaction, no matter how complicated, using a fixed-length 20-byte hash that is short enough to scan from a QR code or easily copied and pasted.</p></blockquote><p>该标准定义了新的交易类型，使得提供花费UTxO所需的条件和责任由发送者转移到了接收者。先说说 BIP-0012：</p><p>而 P2SH 类型的地址是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki">BIP-0013</a> 中提出，在此之前提出的 <a href="https://github.com/bitcoin/bips/blob/master/bip-0012.mediawiki">BIP-0012</a> 中为了实现 P2SH 而尝试将预留的 OP_NOP1 操作码定义为新的 OP_EVAL 操作码，该操作码的功能是从栈顶弹出一个对象，对它反序列化后得到一个脚本代码，然后执行该脚本代码。但是该操作码在实现时没有准确地限制脚本语言运行时的栈的深度，这会导致执行脚本的节点在这里进入死循环，于是这一次软分叉在上线之前被放弃。</p><blockquote><p>O’Connor 在 <a href="https://github.com/bitcoin/bitcoin/issues/729">https://github.com/bitcoin/bitcoin/issues/729</a> 提出了这一漏洞：</p><p>在 OP_EVAL 的处理代码中，有这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">EvalScriptInner</span>(stack, subscript, txTo, nIn, nHashType, pbegincodehash, pendcodehash, nOpCount, nSigOpCount, fStrictOpEval, nRecurseDepth++))</span><br></pre></td></tr></table></figure><p>而 <code>nRecurseDepth++</code> 返回的是变量未递增的值，这会导致执行该操纵码时不会限制递归的深度。</p></blockquote><p>P2SH 类型的地址和 P2PKH 类型的地址生成过程是一样的，不同的地方在于最后进行 Base58-Check 的输入：</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312205969.png" alt="image-20230531220559720"></p><p>P2SH 定义了新的交易输出的类型，它在 scriptPubKey 中定义了新的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OP_HASH160][ScriptHash][OP_EQUAL]</span><br></pre></td></tr></table></figure><p>这使得发送者只需要在输出中指定使用该输出的发送方所提供的脚本需要满足的条件（脚本代码的hash对应），这样就将进行交易时的费用转移到了接收方而不是发送方，具体的实现原理见 <a href="https://learnmeabitcoin.com/technical/p2sh">How does P2SH work? - learn me a bitcoin</a> 以及脚本语言执行过程 <a href="https://learnmeabitcoin.com/technical/script">Script -A mini programming language</a></p><h3 id="SegWit"><a href="#SegWit" class="headerlink" title="SegWit"></a>SegWit</h3><p>SegWit 是隔离见证（Segregated Witness），隔离见证是一系列的 BIP 标准组成的：</p><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-0141 (共识层的隔离见证)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP-0143 (定义了新的交易签名算法，以减少验证时的冗余哈希)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-0144 (在节点层面定义交易的消息和序列化算法)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki">BIP-0145 (为 RPC 接口提供隔离见证的支持)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki">BIP-0147 (交易有效验证的规则更改))</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173 (为隔离见证提供的地址格式)</a></li></ul><p>隔离见证的用意是优化比特币交易和区块结构，将交易的签名（scriptSig）从交易中移到另外一个独立的结构中。</p><p>首先考虑比特币交易中的签名，对于 Pay-to-PubKey-Hash 交易，它的输出中的 scriptPubKey 脚本格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OP_DUP][OP_HASH160][PUBLIC_KEY][OP_EQUALVERIFY][OP_CHECKSIG]</span><br></pre></td></tr></table></figure><p>这部分脚本被称为锁定脚本，结合输入中的 scriptSig 形成一段脚本，由矿工在进行交易打包时进行验证，其具体的过程见<a href="https://learnmeabitcoin.com/technical/p2pkh">How does P2PKH work?</a></p><p>而进行隔离见证后，锁定脚本变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[VERSION][PUBLIC_KEY]</span><br></pre></td></tr></table></figure><p>在具有隔离见证功能的客户端上，只需要将两个值压栈，第一个数字上版本号，而第二个值是锁定脚本，而在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP - 0143</a> 中，规定了隔离见证的输出应该使用压缩公钥的哈希值来进行创建</p><p>同样地，在原有的另外一种交易类型 P2SH 下，锁定脚本中存放的是一个叫脚本的哈希值，尝试花费这笔 UTxO 的使用者需要提供满足哈希值的签名/口令来使用，在隔离见证后，输出的锁定脚本变为如下所示，这里进一步地减少了输出中的数据量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[VERSION] [SCRIPT_HASH]</span><br></pre></td></tr></table></figure><p>而在隔离见证下，交易的结构中多了一个 <code>witness</code> 字段，解锁 UTxO 的解锁脚本被存放在这一字段下</p><p>另外，为了进一步支持隔离见证交易，对于 SigWit 类型的交易的交易费用会进行“打折”，它原来的交易大小不变，但是在隔离见证下引入的“虚拟大小”比正常的交易更低</p><h3 id="Taproot"><a href="#Taproot" class="headerlink" title="Taproot"></a>Taproot</h3><p>Taproot，翻译为中文是“主根”。</p><blockquote><p><em>A taproot is a large, central, and dominant from which other roots sprout laterally.</em></p></blockquote><p>比特币区块链的 Traproot 升级由三个 BIP 标准组成：<a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP-0340 （Schnorr 签名）</a>、<a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP-0341 （Traproot）</a>和<a href="https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki">BIP-0342 （TapScript）</a></p><p>其中，BIP-0340 中引入了 Schnorr 签名，该签名方案的最大好处是可以聚合签名，它能够使得多位签名整合到一起，从而节省空间<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Schnorr签名对比特币有何意义？](https://academy.binance.com/zh/articles/what-do-schnorr-signatures-mean-for-bitcoin)">[7]</span></a></sup>。</p><h4 id="MAST"><a href="#MAST" class="headerlink" title="MAST"></a>MAST</h4><p>BIP-0341 中引入了默克尔抽象语法树（Merklized Abstract Syntax Tree, MAST）<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Merklized Abstract Syntax Tree](https://xiaohuiliu.medium.com/merkelized-abstract-syntax-tree-6a49b2008435)">[15]</span></a></sup><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Merklized Abstract Syntax Tree](https://www.mit.edu/~jlrubin/public/pdfs/858report.pdf)">[16]</span></a></sup><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[17]</span></a></sup>，其目的是隐藏 UTxO 的支出条件，并且减少信息的大小。这是 Taproot 升级的一部分，Taproot 升级将原有的 P2SH（Pay-to-Script-Hash） 和 P2PKH（Pay-to-Public-Key-Hash）结合在一起，使得一笔数输出可以直接通过私钥使用，也可以提供花费输出的脚本和默克尔证明来使用。</p><p>MAST 结合了抽象语义树和默克尔树，默克尔树作为一种在区块链中常见的数据结构，在这里不再进行赘述。而抽象语法树（AST）是一种把程序分割为独立的小块以描述程序的方法，这样会让程序变得容易分析和优化，具体可查阅<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax tree</a>。MAST 结合了 AST 的将程序划分为多个小块的思想，再把程序每个小块进行哈希，利用默克尔哈希树的思想把这些哈希结果构建为默克尔树。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202902204.png" alt="image-20230910202902204"></p><p>考虑这样一个脚本<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[17]</span></a></sup>：Alice 希望可以随时花费她的比特币，但是如果她连续三个月没有花费，那么她的兄弟姐妹 Bob 和 Charlie 就可以花费这笔 UTxO，其脚本实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_IF</span><br><span class="line">&lt;Alice&#x27;s pubkey&gt; OP_CheckSig</span><br><span class="line">OP_ELSE</span><br><span class="line">&quot;3 months&quot; OP_CSV OP_DROP</span><br><span class="line">2 &lt;Bob&#x27;s pubkey&gt; &lt;Charlie&#x27;s pubkey&gt; 2 OP_CHECKMULTISIG</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>在 P2SH 下，这样的脚本是需要在花费时完全暴露在交易中的，Alice 在花费这笔 UTxO 的同时需要提供该脚本，以及包含在其中的 Bob 和 Charlie 的公钥</p><p>而在有了 MAST 后，对该脚本的两个条件进行划分，得到一个简单的 MAST</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202920105.png" alt="image-20230910202920105"></p><p>此时，Alice 在花费的时候只需要选择提供她的公钥验证脚本和 Hash2 作为默克尔证明即可，而不需要暴露 Hash 2 下的具体脚本，这部分信息不会上链。而这样也进一步降低了类似交易的开销，这是很自然的，提供完整的脚本总是比提供脚本的哈希值的数据量少。而这样的结构也给智能合约的实现提供了可能，这样的方式正如 EVM 中的字节码一样，在运行前可以根据输入数据的前4个字节来选取将要调用的函数。不同地方在于，这样的脚本调用需要用户提供具体的脚本，以及默克尔证明来证明脚本是合法的。</p><h1 id="多重签名与PSBT"><a href="#多重签名与PSBT" class="headerlink" title="多重签名与PSBT"></a>多重签名与PSBT</h1><h2 id="多重签名"><a href="#多重签名" class="headerlink" title="多重签名"></a>多重签名</h2><p>多重签名正如其名字一样，一笔交易需要两个或者更多的签名才能生效，多重签名也被称为 <code>n-of-m</code> 交易，指该交易需要 $m$ 个签名者下的至少 $n$ 个签名才能生效</p><p>它的脚本形式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n [PUBLIC_KEY] [PUBLIC_KEY] [PUBLIC_KEY] ... [PUBLIC_KEY] m CHECKMULTISIG</span><br></pre></td></tr></table></figure><p>如果使用 P2PKH 的交易形式来实现多重签名，就需要发送交易的交易方来指定该脚本，并且输入一系列的签名者公钥匙，于是出现了 P2SH 来指定脚本哈希，使得这部分输入输入所产生的开销转移到了使用者</p><h2 id="PSBT"><a href="#PSBT" class="headerlink" title="PSBT"></a>PSBT</h2><p>PSBT 是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP-0174</a> 中所提出的标准，它被用来协助未签名交易（unsigned transactions）的传输</p><p>它可以允许多个签名者并行地对交易进行签名，然后再将交易组装为合成一个完整的 PSBT，目前 Ordinals 相关的交易平台的 Bid 和 Offer 就是利用了 PSBT 来实现</p><p>而 PSBT 也可以被用于实现多重签名</p><h1 id="Ordinals"><a href="#Ordinals" class="headerlink" title="Ordinals"></a>Ordinals</h1><h2 id="序数理论"><a href="#序数理论" class="headerlink" title="序数理论"></a>序数理论</h2><p>序数是一种比特币的编号方案，这是的跟踪和转移单个 sat 成为可能<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[概述 - 序数理论手册](https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu)">[13]</span></a></sup>，它按照每个比特币被挖掘出的顺序以及交易时根据先入先出的规则来进行编号</p><p>序数的表示方式：</p><ul><li>整数符号：<code>2099994106992659</code> 这个序号是根据挖掘聪的顺序分配。</li><li>十进制符号：<code>3891094.16797</code>，第一个数字是挖掘聪的区块高度，第二个数字是区块内聪的偏移量。</li><li>度数符号：<code>3°111094′214″16797‴</code>，具体的度数表示原理见序数理论手册<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[概述 - 序数理论手册](https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu)">[13]</span></a></sup></li><li>百分数符号：<code>99.99971949060254%</code>。以百分比表示聪在比特币供应中的位置。</li><li>名字：<code>satoshi</code>（聪）。使用字符a到z对序号进行编码。</li></ul><h2 id="铭刻"><a href="#铭刻" class="headerlink" title="铭刻"></a>铭刻</h2><p>铭文的铭刻利用了隔离见证后的特性<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[解读比特币Ordinals协议与BRC20标准的原理创新与局限](https://www.odaily.news/post/5187233)">[12]</span></a></sup>，即将见证脚本放入到交易本身之外的一个 <code>witness</code> 字段中，使用隔离见证的交易只需要 20% 的交易费用</p><p>铭文的相关内容被放入到脚本中，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OP_FALSE</span><br><span class="line">OP_IF</span><br><span class="line">OP_PUSH &quot;ord&quot;</span><br><span class="line">OP_1</span><br><span class="line">OP_PUSH &quot;text/plain;charset=utf-8&quot;</span><br><span class="line">OP_0</span><br><span class="line">OP_PUSH &quot;Hello, world!&quot;</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>在这里，<code>OP_1</code> 指示下一次压入包含内容类型，<code>OP_0</code> 指示后续数据压入包含内容本身</p><p>开头的 <code>OP_FALSE</code> 指令入栈后脚步立刻停止，但是由于隔离见证的特性，这部分数据依然在链上存在，所以 Ordinals Inscription 的本质是在比特币上借助这样一个用于不能被执行的脚步来实现一个记账的功能</p><p>所以，<strong>铭文的索引只能高度依赖链下的中心化索引</strong>，这样铭刻的一个铭文在链下会被记录到对应输出的第一个聪上，在 ordinals.com 中可以看到每个聪的相关信息，以及它是否存在铭刻的数据，目前索引这些铭文（Ordinals Inscription）的程序在 <a href="https://github.com/ordinals/ord">https://github.com/ordinals/ord</a> 维护</p><p>例如 <a href="https://ordinals.com/inscription/6fb976ab49dcec017f1e201e84395983204ae1a7c2abf7ced0a85d692e442799i0">inscription#0</a>，它被铭刻在了序数为 1252201400444387 的聪上</p><h1 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h1><p>闪电网络是建立在 Bitcoin 上的 Layer 2 解决方案，其目的是在 Bitcoin 的支付场景下帮助用户节省成本、提高效率。而闪电网络所依赖的思想也很简单，即构建资金池，这样的资金池也被称为交易双方的微支付通道。更具体一点，涉及到两个核心概念：</p><ul><li>Revocable Sequence Maturity Contract（RSMC）：序列到期可撤销合影</li><li>Hashed Timelock Contract（HTLC）：哈希时间锁定合约</li></ul><p>RSMC 假定了交易双方之间存在一个微支付通道，双方先存放一部分资金到这个通道中，初始情况下双方的分配方案就是预先存放的金额。在每一次发生交易时，双方都需要对交易后产生的分配结果进行确认，同时把原有的分配方案作废。这个过程涉及到的概念较多，而且比较巧妙，具体可参阅 <a href="https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2">A Dive into Lightning Network (Part One)</a><sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A Dive into Lightning Network (Part One)]([A Dive into Lightning Network (Part One)](https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2))">[18]</span></a></sup>，而它的作用是在闪电网络中的作用是构建双方之间的支付通道。</p><p>HTLC 是一种带事件的哈希锁定，它要求某一方在一定时间内提交某个哈希值 $h=H(m)$ 的原像 $m$ 以取得使用某一笔 UTxO 使用权。它在闪电网络中被用于构建支付路由，具体的实现过程见 <a href="https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8">Lightning network in depth, part 2: HTLC and payment routing</a><sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Lightning network in depth, part 2: HTLC and payment routing](https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8)">[19]</span></a></sup>。</p><p>闪电网络整合了这两种机制，使得交易可以在闪电网络中的任意两个节点间能够在链下完成。</p><h1 id="Taro"><a href="#Taro" class="headerlink" title="Taro"></a>Taro</h1><p>主根资产（Taproot Assets，后续简称为 Taro）<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What Is Taro in Bitcoin?](https://river.com/learn/what-is-taro-in-bitcoin/)">[20]</span></a></sup><sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot Assets](https://docs.lightning.engineering/the-lightning-network/taproot-assets)">[21]</span></a></sup><sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot Assets: A New Protocol for Multi-Asset Bitcoin and Lightning](https://www.youtube.com/watch?v=-yiTtO_p3Cw)">[22]</span></a></sup>是一种还在提议阶段的协议，它可以实现在 Bitcoin 上发行资产，这样的资产可以通过链上的交易通过比特币网络转移（对 NFT 的交易、转移已经被 Ordinals 实现）。特别地，同质化的 Taro 资产可以在存入闪电通道后在闪电网络上以更低的手续费、更为隐私地转移，类似的还有尝试在闪电网络上运行智能合约的 RGB 协议<sup id="fnref:23"><a href="#fn:23" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A BRIEF INTRODUCTION TO RGB PROTOCOLS](https://bitcoinmagazine.com/guides/a-brief-introduction-to-rgb-protocols)">[23]</span></a></sup>。</p><p>Taro 可以在 Bitcoin 主网或二层的闪电网络上流通。先考虑在 Bitcoin 网络的情况，Taro 是附加在交易上的<strong>哈希化元数据形式</strong>，使用哈希化的目的在于降低交易的占用空间以节省手续费。而这样的<strong>哈希化元数据形式</strong>则是 Taro 的核心，这样的一条哈希值甚至可以代表实际上的几百万次交易，它的原理会在后续进行介绍。</p><p>其次是 Taro 在闪电网络上的情况，使用闪电网络可以让同质化的 Taro 资产实现更快的交易速度，这类似于使用闪电网络可以更快、成本更低地转移比特币。在 Taro 的提议中，闪电网络自身不需要改变，为了实现一笔某种 Taro 资产的交易，只需要整条支付路径的第一条通道和最后一条通道可以识别 Taro 资产即可，而中途的路由通道则是正常的闪电网络转账方法，它们转账等价的比特币，这也导致 Taro 资产通常会在网络的边缘和其他资产交换。下图是 RIVER FINANCIAL 所展示的在闪电网络中实现 Taro 资产转移的过程。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/taro-lightning-network.png" alt="Taro assets exchanged on the Lightning Network"></p><h3 id="资产树"><a href="#资产树" class="headerlink" title="资产树"></a>资产树</h3><p>资产树是 Taro 中的一种两级默克尔树结构，它被用来代表 Taro 资产。第一级是由 Taro 信息作为叶子节点而构成的默克尔树，而第二级则是通过 MS-SMT 构成的表示每个账户所具有的该资产的树，MS-SMT 的思想较为简单，它在默克尔哈希树基于哈希来构成树形结构的同时，每个节点还存放了左右两个子节点的和来实现（进行哈希运算本身也算一种求和），这样的资产树和 MS-SMT 树被用来构建 Taro 的 UTxO。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910203608411.png" alt="image-20230910203608411"></p><p>资产叶（Aseet Leaft）是资产树中的最底层结构，它表现为资产树示意图中的淡蓝色节点，它以 assetScriptKey （assetScriptKey 可以类比 P2SH 交易中对交易脚本的哈希值）作为键。每个资产叶表示 Taro 资产的一个 UTxO，资产叶中包含的可选项可参见 <a href="https://medium.com/nayuta-en/understanding-taproot-assets-protocol-e2dfe3fc1e07">Understanding Taproot Assets Protocol</a>。</p><h3 id="Taro-资产发行"><a href="#Taro-资产发行" class="headerlink" title="Taro 资产发行"></a>Taro 资产发行</h3><p>Taro 资产的发行需要一个标识符，正如 ERC-20 代币的智能合约会拥有一个地址一样，Taro 协议定义了标识符的生成方式：<br>$$<br>ID=SHA256(genesisPoint||assetTag||assetMeta)<br>$$<br>它将铸造资产所使用的交易输出信息、资产标签（例如资产名称的哈希值）以及资产的元数据（图片、链接或文档）进行哈希，从而得到一个标识符。</p><p>Taro 资产的转移脚本可以有类似比特币交易的输入输出，而创建资产的交易不需要包含任何的 Taro 资产的输入，由此可见，Taro 资产沿用了比特币的 UTxO 模型，资产的发行就是发布一笔 Taro 资产的交易，它没有输入，只有输出。</p><p>Taro 的输入和输出是基于资产树来实现的，正如前文所述，资产树的第一级代表了该笔 UTxO* （后面会继续沿用这种写法，*表明这样的结构是在 Taro 资产中而非 Bitcoin中）中存放的 Taro 资产有哪些，而 Taro 资产 ID 所对应的 MS-SMT 中所存放的是该笔 UTxO* 输出的 Trao 资产的信息。</p><p>构建一笔 Taro 资产的发行交易如下图所示，以一笔 Bitcoin 的 UTxO 作为输入，输出一笔正常的 Bitcoin UTxO 以及附加的 Taro 资产 A 的 UTxO*。<strong>这样的 UTxO*在 Bitcoin 上表现为一个默克尔根的形式</strong>，而它在链下表现为资产树的形式，资产树中记录了 Taro 资产 A 的 assetId 以及资产 A 对应的 MS-SMT 中的记录。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910203812171.png" alt="image-20230910203812171"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jinse.com/blockchain/465498.html">什么是BIP？一分钟搞懂BIP标准</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://m.theblockbeats.info/news/37101">科普| 比特币地址有哪些？ - BlockBeats</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2021/09/29/bitcoin-taproot-a-technical-explanation/">比特币升级提案 Taproot 技术解读</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://juejin.cn/post/6844903573742944263">译-BIP16:P2SH交易脚本</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2022/04/20/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war/">P2SH 之争：第一次比特币战争不为人知的故事</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://bitcoinmagazine.com/technical/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war">THE BATTLE FOR P2SH: THE UNTOLD STORY OF THE FIRST BITCOIN WAR</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://academy.binance.com/zh/articles/what-do-schnorr-signatures-mean-for-bitcoin">Schnorr签名对比特币有何意义？</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/Segregated_Witness">Segregated Witness</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2021/09/07/what-is-a-bitcoin-merklized-abstract-syntax-tree-mast/">什么是比特币默克尔化抽象语法树？</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2020/08/27/segregated-witness-for-dummies/">详尽解释隔离见证</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.blocktempo.com/segwit-for-dummies-concept-and-case-study/">詳解》比特幣隔離見證 Segwit －工作原理與案例分析</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.odaily.news/post/5187233">解读比特币Ordinals协议与BRC20标准的原理创新与局限</a><a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu">概述 - 序数理论手册</a><a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://newbtcworld.medium.com/understanding-of-tapscript-transaction-structure-5979a7645205">Understanding of Tapscript Transaction Structure Tapscript</a><a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://xiaohuiliu.medium.com/merkelized-abstract-syntax-tree-6a49b2008435">Merklized Abstract Syntax Tree</a><a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.mit.edu/~jlrubin/public/pdfs/858report.pdf">Merklized Abstract Syntax Tree</a><a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[A Dive into Lightning Network (Part One)](<a href="https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2">A Dive into Lightning Network (Part One)</a>)<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8">Lightning network in depth, part 2: HTLC and payment routing</a><a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://river.com/learn/what-is-taro-in-bitcoin/">What Is Taro in Bitcoin?</a><a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.lightning.engineering/the-lightning-network/taproot-assets">Taproot Assets</a><a href="#fnref:21" rev="footnote"> ↩</a></span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.youtube.com/watch?v=-yiTtO_p3Cw">Taproot Assets: A New Protocol for Multi-Asset Bitcoin and Lightning</a><a href="#fnref:22" rev="footnote"> ↩</a></span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://bitcoinmagazine.com/guides/a-brief-introduction-to-rgb-protocols">A BRIEF INTRODUCTION TO RGB PROTOCOLS</a><a href="#fnref:23" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;BIP-标准&quot;&gt;&lt;a href=&quot;#BIP-标准&quot; class=&quot;</summary>
      
    
    
    
    <category term="Wiki" scheme="http://decision01.com/categories/Wiki/"/>
    
    
    <category term="blockchain" scheme="http://decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="http://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>密码累加器</title>
    <link href="http://decision01.com/post/ae4d471f.html"/>
    <id>http://decision01.com/post/ae4d471f.html</id>
    <published>2023-01-02T14:12:49.000Z</published>
    <updated>2024-04-08T08:03:49.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>密码累加器用于高效地证明元素是否存在于集合中，定义：</p><ul><li><p>集合 $X = {x_1, …,x_n}$</p></li><li><p>集合的累加值 $acc_X$</p></li><li><p>集合中的元素 $x_i$，对应一个证明 $w_i$</p></li></ul><p>通过证据 $w_i$，可以证明元素 $x_i$ 存在于集合 $X$</p><blockquote><p>累加器的三个性质：正确性、健壮性、不可区分性</p><p>正确性：对于所有诚实生成的密钥、所有诚实计算的累加值和证据，验证算法始终返回 1</p><p>健壮性：指无碰撞性，对于元素 $y\notin X$，很难找到其成员证明，而对于元素 $x_i \in X$，也很难找到其非成员证明</p><p>不可区分性：累加器和持有证明的用户都不会泄露有关累加集合 $X$ 的信息</p></blockquote><h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><ul><li>1993年首次被提出，其最初的构造为<strong>静态累加器</strong>，集合固定不变</li><li>2002年提出了<strong>动态累加器</strong>的概念，可以支持动态添加、删除元素</li><li>2007年，<strong>通用累加器</strong>被提出，可以姐姐成员证明和非成员证明</li></ul><blockquote><p>非通用累加器智能支持元素的成员证明，即证明 $x_i \in X$，无法提供 $y\notin X$ 的证明 $w_y$</p></blockquote><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>一个密码累加器中有三个主体：</p><ul><li>累加器管理员：生成密钥对，创建并发布累加器</li><li>用户：接收累加器管理员提供的证证明，这个证明是它们在累加器系统中的凭证，可以提供给验证方进行验证</li><li>验证方：通过证明 $w$ 和 $acc_X$，验证某个元素在累加器中</li></ul><h2 id="静态累加器"><a href="#静态累加器" class="headerlink" title="静态累加器"></a>静态累加器</h2><p>静态累加器可以描述为四元组 $\Pi=(Gen, Eval, WitCreate, Ver)$，静态累加器不能动态地添加元素</p><p>$Gen(1^\lambda, t) \Rightarrow (sk_{acc}, pk_{acc})$：管理员输入安全参数$\lambda$，累加上限$t$，输出密钥对$(sk_{acc},pk_acc)$，如果没有陷门，陷门信息$sk_{acc} = \varphi$</p><p>$Eval((sk_{acc}, pk_{acc}),X) \Rightarrow acc_X$：管理员计算累加值和辅助信息，输入集合、密钥对，输出一个累加值。并且，公布给用户和验证方，输出辅助信息$aux$发送给用户，用户通过辅助信息更新本地证明</p><p>$WitCreate((sk_{acc},pk_{acc}), x_i, acc_X, aux) \Rightarrow w_i$：创建用户 $x_i$ 的证明，输入密钥对、累加值、元素 $x_i$ 和辅助信息 $aux$，生成证据 $w_i$</p><p>$Ver(pk_{acc}, x_i, w_i,acc_X) \Rightarrow {0/1}$：验证方验证元素 $x_i$ 是否在累加器中，如果 $w_i$ 是 $x_i$ 的证据，返回1，否则返回0</p><h2 id="动态累加器"><a href="#动态累加器" class="headerlink" title="动态累加器"></a>动态累加器</h2><p>为了可以支持动态地更新集合 $X$，并且可以有效地更新集合中的证明对静态累加器进行扩展，可以得到动态累加器</p><p>动态累加器<strong>在静态累加器的基础上</strong>添加了一个三元组 $\Pi=(Add, Del, MemWitUp)$</p><p>$Add((sk_{acc},pk_{acc}),acc_X,aux,x) \Rightarrow (acc_{X’},aux’)$：累加器管理员添加元素 $x\notin X$ 到累加器中，并且更新累加值 $acc_x$，这个过程和 $WitCreate$ 较类似，它输出的是 $x$ 加入后的累加值$acc_{X’}$，并且更新辅助信息 $aux$</p><p>$Del((sk_{acc},pk_{acc}),acc_x,x,aux)\Rightarrow(acc_{X’},aux’x)$：与上一个元素类似，输入需要删除的元素 $x$ 和辅助信息，然后输出新的累加值，更新辅助信息</p><p>$MemWitUp((sk_{acc},pk_{acc}), x, w_i, aux) \Rightarrow w_{i’}$：在添加或删除元素后，用户更新元素 $x_i$ 的证明 $w_i$，它输出$x_i$更新后的证明$w_i’$ </p><h2 id="通用累加器"><a href="#通用累加器" class="headerlink" title="通用累加器"></a>通用累加器</h2><p>通用累加器在前面 $WitCreate$ 组件中，添加一个布尔参数 $type$，创建成员证明时 $type=0$，创建非成员证明时 $type=1$。通用累加器可以根据是否可以添加元素进行分类，如果不可动态添加元素称为<strong>通用静态累加器</strong>，如果可以动态添加元素则称为<strong>通用动态累加器</strong></p><p>如果是通用动态累加器，则需要在前面两个累加器的基础上添加 $NonMemWitUp$ 组件，在累加器集合更新时，对非成员证明更新</p><p>$NonMemWitUp((sk_{acc},pk_{acc}),x,w,aux) \Rightarrow u’$：在添加或删除元素 $x$ 时,用户更新非成员元素 $y \notin X$ 的证据$u$ 为 $u’$</p><h1 id="基于-RSA-的累加器"><a href="#基于-RSA-的累加器" class="headerlink" title="基于 RSA 的累加器"></a>基于 RSA 的累加器</h1><h2 id="静态累加器-1"><a href="#静态累加器-1" class="headerlink" title="静态累加器"></a>静态累加器</h2><p>最开始在1993年被提出的静态累加器就是基于 RSA 实现的，其具体构造方案如下</p><p>$Gen(1^\lambda, t) \Rightarrow ((p, q), N)$：输入安全参数，生成累加器的初始值 $g\in Z_n$，输出密钥对，私钥是 RSA 加密中的两个大素数，$N = pq$</p><p>$Eval(pk_{acc}, X) \Rightarrow acc_X$：管理员计算累加值，$acc_X=g^{x_1…x_n}\ mod\ N$，其中$X = {x_1,…,x_n}$</p><p>$WitCreate(pk_{acc},x,acc_X) \Rightarrow w_i$：生成用户的证明 $w_i=g^{x_1…x_{i-1}x_{i+1}…x_n}\ mod\ N$</p><p>$VerMem(pk_{acc},x_i,w,acc_X) \Rightarrow {0/1}$：验证方判断等式$acc_X=w_i^{x_i} \ mod\ N$ 是否成立来验证元素是否在累加器中</p><h2 id="动态累加器-1"><a href="#动态累加器-1" class="headerlink" title="动态累加器"></a>动态累加器</h2><p>动态累加器利用了 RSA 的陷门来更新累加器，利用陷门信息 $sk_{acc}$ 进行求逆运算，删除信息时需要利用陷门信息更新累加值，更新成员证明时不需要陷门信息</p><p>$Gen(1^\lambda, t) \Rightarrow ((p,q),N)$：和静态累加器一样，生成密钥对</p><p>$Add(acc_X,x,X,pk_{acc}) \Rightarrow acc_X$：添加元素 $x$ 后，更新累加值<br>$$<br>acc_{X’}=acc_{X \cup{x}}=acc_X^x \ mod\  N<br>$$<br>$Del(acc_X,x,X,(sk_{acc},pk_{acc}))$：删除元素 $x$ 后更新累加值，删除元素后更新累加值为<br>$$<br>acc_{X’}=acc_{X \textbackslash {x}}=acc_{X}^{x^{-1} \ mod\  \varphi(N)} \ mod \ N<br>$$<br>其中，$\varphi$ 是欧拉函数</p><p>$VerMem(acc_X,x,w_i,pk_{acc})$：验证方通过等式 $acc_X =w_i^{x_i}\ mod\ N$ 来判断元素是否在集合中</p><p>$MemWitUp(x,w_i,x_i,pk_{acc},acc_X,acc_{X’})$：用户更新元素 $x_i$ 的证明。</p><p>添加元素 $x\notin X$ 到累加器时，用户更新证明 $w_i’ = w_i^x \ mod\ N$。</p><p>删除元素 $x \neq x_i \in X$ 时，通过扩展欧几里得算法求出 $a,b\in Z$ 使得 $ax_i + bx = 1$，然后从 $x_i$ 的旧证明计算新证明<br>$$<br>w_i’ = w_i^bacc_{X’}^a<br>$$</p><h1 id="Merkle-树累加器"><a href="#Merkle-树累加器" class="headerlink" title="Merkle 树累加器"></a>Merkle 树累加器</h1><p>Merkle 树密码累加器使用了 Merkle 树的性质来提供某个元素存在于集合中的证明</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/merkle.png" alt="Merkle Tree"></p><p>对于上图中的元素 L2，如果要提供它存在于当前集合中的证明，从 L2 开始往上依次得到 <code>Hash(0-0)</code> 和 <code>Hash(1)</code>，这样得到的序列就是一个 Merkle Proof</p><p>在进行验证时，先对 L2 进行哈希得到 <code>Hash(0-1)</code> 然后连接 <code>Hash(0-0)</code> 进行哈希得到 <code>Hash(0)</code>，最后连接 <code>Hash(1)</code> 进行哈希得到 Merkle 根</p><p>这样的验证方式在实际的场景下可以用于进行轻量节点的实现、跨链协议中的锚定技术（已支付证明）以及智能合约中调用权限的证明</p><p>基于 Merkle 哈希树的累加器也可以提供非成员元素证明，具体见<a href="https://d.wanfangdata.com.cn/periodical/xadzkjdx202201008">密码累加器研究进展及应用</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://d.wanfangdata.com.cn/periodical/xadzkjdx202201008">密码累加器研究进展及应用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;密码累加器用于高效地证明元素是否存在于集合中，定义：&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="Research" scheme="http://decision01.com/categories/Research/"/>
    
    
    <category term="cryptography" scheme="http://decision01.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Kademlia协议及广播方法</title>
    <link href="http://decision01.com/post/db10e69d.html"/>
    <id>http://decision01.com/post/db10e69d.html</id>
    <published>2022-09-27T06:57:33.000Z</published>
    <updated>2024-04-08T08:03:49.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Kademlia-协议"><a href="#Kademlia-协议" class="headerlink" title="Kademlia 协议"></a>Kademlia 协议</h1><p>Kademlia<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kademlia: A Peer-to-peer Information System Based on XOR Metric](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)">[1]</span></a></sup>协议是一种分布式散列表(Distributed Hash Table, DHT) 技术。它可以被用来构建 P2P 网络，相比其他的散列表技术，提高了路由的查询速度。</p><p>在 Kademlia 协议中，利用异或来定义了节点之间的<em>距离</em>。这个<em>距离</em>是一个逻辑距离，而不是两个节点实际上的物理距离。在 Kademlia 协议中，每个节点都有一个随机生成的长度为160 bit的ID，而两个节点之间的<em>距离</em>就是把它们的 ID 异或后得到的值。</p><blockquote><p>结合异或本身的性质，可以得到<em>距离</em>的一些特点<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kademlia协议](https://segmentfault.com/a/1190000023417884)">[2]</span></a></sup>：</p><ul><li>$A \bigotimes B = B \bigotimes A$：A 到 B 和 B 到 A 的距离是一样的</li><li>$A \bigotimes A = 0$：节点自身和自身的距离是0</li><li>$A \bigotimes B &gt; 0$：任意两个不同节点之间的距离大于0</li><li>$(A \bigotimes B) + (B \bigotimes C) \ge (A \bigotimes C)$：A 经过 B 到达 C 的距离大于 A 直接到达 C 的距离</li></ul></blockquote><h2 id="K-bucket"><a href="#K-bucket" class="headerlink" title="K-bucket"></a>K-bucket</h2><p>在 Kademlia 协议中，定义了 K 桶(K-bucket)，这里的 K 表示一个桶的容量。K 桶存储了其他邻居节点的信息，K 桶是每个节点在自己的视图下进行划分得到的。以下图为例，节点11（对应二进制为1011），它存储了包含自己id共16个节点的路由信息，然后将节点 ID 以前缀树的方式进行维护，然后通过以其他节点和自己的最长公共前缀来划分 K 桶，图中的每一个框都是一个 K 桶。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202209271541434.png" alt="kademlia_routing_table_in_tree"></p><p>第 $n$ 个 K 桶理论上维护的节点到当前节点的距离理论上为 $[2^{n -1 }, 2^n)$，但是每个 K 桶是存在容量限制的，距离本地节点较远的节点只维护 K 个。在查询某个节点的时候，可以求出另外一个节点和本地节点的 ID 的最长公共前缀长度来确认节点应该所在的 K 桶，如果节点不在路由表中，则可以去询问 K 桶中的节点。</p><p>在实际的代码实现中，go-lib-p2p-kbucket 使用了最长公共前缀长度来作为 K 桶的序号，查询邻居节点时利用最长公共前缀来定位节点所应该在的 K 桶，然后查找最近的 K 个节点来得到结果。而 python-kademlia 则没有利用这种方式，它将维护的 K 桶并非按照距离/最长公共前缀长度来维护，而是维护每个 K 桶的节点序号范围，在查找邻居的时候交替从目标 K 桶的左右 K 桶获取元素来得到 K 个最近的节点。</p><h2 id="路由表更新机制"><a href="#路由表更新机制" class="headerlink" title="路由表更新机制"></a>路由表更新机制</h2><p>(待续，抽空写)</p><h1 id="广播方法"><a href="#广播方法" class="headerlink" title="广播方法"></a>广播方法</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">Kademlia: A Peer-to-peer Information System Based on XOR Metric</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://segmentfault.com/a/1190000023417884">Kademlia协议</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.wanghaoyi.com/blockchain-p2p-kademlia.html">P2P网络之Kademlia协议</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Kademlia-协议&quot;&gt;&lt;a href=&quot;#Kademlia-协</summary>
      
    
    
    
    <category term="Research" scheme="http://decision01.com/categories/Research/"/>
    
    
    <category term="blockchain" scheme="http://decision01.com/tags/blockchain/"/>
    
    <category term="distributed" scheme="http://decision01.com/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>Sundaeswap feature</title>
    <link href="http://decision01.com/post/6ba030b7.html"/>
    <id>http://decision01.com/post/6ba030b7.html</id>
    <published>2022-08-14T03:45:01.000Z</published>
    <updated>2024-04-08T08:03:49.041Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>这篇是前几个月的Sundaeswap的可搬砖套利的小特性(bug)的记录，目前特性已经被修复，所以也没法用了</strong></p><p>Sundaeswap是Cardano链上上线的第二个去中心化交易所（Decentralized exchange， Dex），由于Cardano使用的UTXO模型的原因，所以它在实现的本质上还是一种挂单交易的方式，不过流动性相比于直接挂单的交易所更好</p><p>在上线前三个月存在一个特性，可以在Sundaeswap的首页查询到一个币种的多个交易池，但是在实际的swap界面上只能默认流动性最高的池子。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208141215809.png" alt="image-20220814121457096"></p><blockquote><p>交易池：放入了不同币种对的一种抽象模型，可以放入一种币种在交易池中换取另外一种币种，现在的去中心化交易所使用的都是一类公式。</p><p>做一个简单的举例，假设人民币比美元是6:1，那么就可以创建一个交易池放入600人民币和100美元，这样其他人就可以在里面交易，而交易池可以得到手续费。如果不按照比例来进行设置，那么其他人就存在一定的套利空间，导致交易池出现损失。</p></blockquote><p>在抓包后可以发现，Sundaeswap进行一次交易要经过下面的一系列操作</p><ul><li>本地根据流动性、滑点、手续费计算得到该笔交易中能够获取到的另外一个币种的<strong>最低限制数量</strong></li><li>将<strong>交易信息</strong>发送到sundaeswap的服务器上，生成一笔未签名的交易的cbor，这里的交易信息包含了地址、输入币种、输出币种以及具体数量信息</li><li>返回本地让本地的钱包进行签名，发送交易到链上</li><li>交易完成，钱包收到目标币种</li><li>如果交易池不能满足最低限制数量，则会在链上一直等待交易可以完成</li></ul><p>在交易信息中还包含了一个重要的字段：目标交易池标识，这里的标识就是一个整形数据，标识从哪个交易池进行交易</p><p><em>如果目标交易池中没有现在需要兑换的币种，那么这笔交易同样会一直卡在链上，直到撤销这笔交易返回代币</em></p><p>在swap页面不能选择交易池，这就会导致默认的交易池价格会一直变动（因为频繁会有人兑换），而其他的交易池价格不会或者很少发生变动（其他人没有发现可以修改json数据来更改交易池）</p><p>于是这就会导致存在多个交易池的币种存在套利空间，在默认交易池出现频繁的价格波动的时候就可以来回薅</p><p>顺便说一下自动做市(Auto Market Maker, AMM)在这种场景下的可套利计算方法</p><p>假设有两个币种A和B，它们有两个交易池在DEX上，在一个交易池中有a个A币种，b个B币种，在另外一个交易池中有c个A币种，d个B币种</p><p>并且a/b和c/d的差距比较大，这种情况下就有可套利空间</p><p>现在我放入x个A币种到第一个交易池中得到y个B币种，再将它放入到第二个交易池中换出A币种</p><p>根据AMM的输出计算公式(白皮书参考：<a href="https://sundaeswap.finance/papers/SundaeSwap-2021-06-01-Fundamentals.pdf">SundaeSwap Fundamentals</a>)，可以得到<br>$$<br>y = b - \frac{ab}{x + a}<br>$$<br>同样，在另外一个交易池中进行兑换，输出z个A币种<br>$$<br>z = c - \frac{cd}{y + d}<br>$$<br>套利空间也就是$z - y$，这里最后化简后得到一个关于x的方程，在之前计算的时候不太好找极大值。然后发现在1w以内对计算机来说计算量也不是很大，就直接用python写程序直接求极大值了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;strong&gt;这篇是前几个月的Sundaeswap的可搬砖套利的小特性(b</summary>
      
    
    
    
    <category term="Wiki" scheme="http://decision01.com/categories/Wiki/"/>
    
    
    <category term="blockchain" scheme="http://decision01.com/tags/blockchain/"/>
    
    <category term="dex" scheme="http://decision01.com/tags/dex/"/>
    
  </entry>
  
  <entry>
    <title>毕业行·甘肃</title>
    <link href="http://decision01.com/post/3d984fbf.html"/>
    <id>http://decision01.com/post/3d984fbf.html</id>
    <published>2022-08-10T15:36:23.000Z</published>
    <updated>2024-04-08T08:03:49.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>8月2日（<em>Day.10</em>）中午在机场还车后赶飞机，从西宁飞到敦煌，到敦煌市区的时候是下午4点过。在飞机上可以看到敦煌这边周围都是荒漠隔壁，只有沿着市区发展出来的一片片“绿洲”，这也是甘肃很多市的一种特色。</p><p>在酒店休息整顿后时间还比较充足，于是我们先去鸣沙山。鸣沙山以沙动而响为名，面积有200平方公里。进入景区的门票是55/人，大哥一直好奇为什么售票大厅写的是110，甚至想排队专门去问问。在进了进去后，看到了门口有一个讲解我就知道大哥想要干什么了。在请了讲解后，讲解问了我们进来的票价，才说现在还是按照淡季来收费的，所以是半价票。</p><p>在讲解了前面的一个城楼后，我们又买观光车进月牙泉。<em>我一开始以为沿途有景点，还想先走进去再买票回来。</em>坐在观光车上有一段能够看到成群的骆驼队，在那个点位拍照能够得到很好的效果，可惜的是等我掏出相机的时候已经晚了，就没有拍到。讲解带着转的这一圈感觉没有什么好写的，直接快进到爬沙丘，在爬沙丘之前拍了一下芦苇丛对面的沙丘。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111848134.jpg" alt="20220802-DSC00903"></p><p>上沙丘的有路有两条景区设置的路，放了一些木板在上面以降低压强方便爬上去。我们不想在梯子上一个挨着一个的爬上去就选择了另外一边没有梯子的地方上去。在月牙泉背后拍到的照片里面可以看到人数比较密集的两条上沙丘的路。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111857590.jpg" alt="20220802-DSC00898"></p><p><em>说来在游戏、电视上看到过沙漠，但是第一次面对高耸的沙丘还是让人觉得很震撼的。它如山一样高，是由沙子所堆起来的沙山。</em>鸣沙山应该不算是真正的沙漠，它的底部应该是有坚固的岩石的，所以沙丘也不会是完全由沙子堆砌而成。爬沙丘的时候能够真实地感觉到在沙丘上行走的困难，由于沙子的流动性导致我们每走一步都会后退一点，到了最后我们就真正地是在爬山了，真正意义上的手脚并用地爬上去。上去后拍了两张照片用来拼接，可是下面游客比较多，所以就裁掉了，就凑合着看看。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111855638.jpg" alt="鸣沙山和月牙泉"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111900355.jpg" alt="20220802-DSC00932"></p><p>在上去之后可以拍背后的一座山丘，感觉调一调可以当个手机背景之类的，总体而言是一种常见的构图，还有竖拍的就懒得现在调整了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111903169.jpg" alt="鸣沙山沙丘"></p><p>在被大哥拉着体验了ATV后我就没打算回之前那个沙丘了，走下去没多久听到周围的人在说开灯什么的，查了一下月牙泉在晚上的时候会开灯光，然后我就找了个地方坐着。在QQ上让大哥等着，结果没一会他说他已经下去了，我还想着如果他还没下去那我走上去。等了一会应该是9点过的时候，天快黑了就开灯了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208112314019.jpg" alt="月牙泉"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208112314262.jpg" alt="月牙泉"></p><p>时间差不多了我就下去了，然后找到大哥坐了观光车回到景区入口。在入口的地方还有一个民俗博物馆，进去后发现是那种以前的人供奉的地方，其实很有贵州这边有些人家里的那种感觉。不过比较阴间的是晚上里面没有开灯，有一个房间里面全是一些供奉的画像，我在外面看了一下就有点不寒而栗。</p><p>8月3日（<em>Day.11</em>）租车往雅丹魔鬼城的方向跑，途中经过玉门关，还计划回来的时候往阳关去一趟。这两个地方都是曾经背过的，但是也只能记住那一句了。春风不度玉门关和西出阳关无故人，而每一句前面的也就记不住了。自驾过去走省道S303往新疆的方向走，雅丹地质公园那边已经很靠近新疆了。从敦煌出发行程160km，这边的省道上面没有什么车，大哥都说这边狗都不来。在原来青甘大环线的行程中我们也只是说可能往玉门关的方向走一下，大哥在来敦煌前几天又说可以去一下魔鬼城，正好空出来一天还租了车那就过去了。</p><p>在S303上没什么车，而且路也比较好，于是大哥心心念念想着换我坐牢的机会就来了。其实在青海那边我也挺想开一段路，但是那边确实路况不太好，车道上面的情况也比较复杂，就算换我开也有一定的风险。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211559842.png" alt="省道S303"></p><p>在省道上面开了快一个小时后到了玉门关，在路边已经能够看到平地上高起来的玉门关遗址，我就说玉门关看完了，我们可以直接走了（不是）。而这边来的人比较少，停车场里面也只有寥寥几辆车。停好车做好防晒措施后买门票进景区，在售票处还遇到了上一天在鸣沙山遇到的一对夫妻。本来我一开始是没注意到的，但是对方先打招呼了我才想起来。在上一天爬上鸣沙山的时候，就被他们问休息了多久，然后他们还感叹了一下大哥的体力好，居然还负重爬沙丘。</p><p>买了门票后我们跟在他们后面一点往景区走，在进大厅之后大哥看了一下讲解的价格，觉得有点贵就不太想请了。然后那对夫妻就说要不要我们四个人请一个讲解，人多了之后就感觉划算了一些，那就一起请一个讲解了。付完费之后我们要在大厅里面等一下导演，这个时间大哥就去厕所了。我在这段时间就和他们聊了一下，了解到他们是从青海一路开车过来的，也就是我们原计划的青甘环线。不一样的就是我们缩短了自驾的行程，总体来说我们走的地方是差不多的。他们后面也要往雅丹的方向走，就说后面也结伴同行，但是这也是后话了。</p><p>玉门关景区里面还有其他两个景点，可能也是因为只有一个城楼遗址太单调才加到玉门关景区的。景区观光车的路线是汉长城-大方盘城-玉门关遗址。汉长城是用就地取材的芦苇和沙石修建的，据说原来能有7m高，而现在仅存的只有1~2m高的遗迹了。在这边听讲解的时候还有观光车上另外一些人凑过来听，可能是因为讲解在车上用广播的时候被误会成观光车的导游了。然后那对夫妻里面的大哥应该也是有点看不下去，才问导游这帮人也是和我们一起的吗，他们才自己走开了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211635355.jpg" alt="汉长城和远处的烽火台"></p><p>在这边停留了几分钟后上车去离得比较远的大方盘城，大方盘城是一个粮仓遗址，相比于玉门关来说留下来的遗迹会更多一些（感觉这样说不太恰当）。<del>在这边看到这些残留的土墙老是让我想到在刺客信条起源里面爬墙暗杀</del></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211651755.jpg" alt="DSC01245"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211651702.jpg" alt="DSC01248"></p><p>我们围着这边转了一圈就回去了，在这种人文景点里面确实也只能看一看，听一听讲解来了解一下。而且在来之前一直在忙论文的事情也就没怎么查过相关的资料（就算查资料也不会想到会到这边来）。回到了起点大厅附近，然后又去看玉门关遗址。在来之前根据我看的网图我一直觉得它就是个只有一面的城楼遗址，而实际上玉门关遗址是一个四方的，有两个口可以出入。据讲解说的是，有一边的口还是以前放牧的人把它当作一个羊圈用的时候凿开的。。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211703213.jpg" alt="DSC01278"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211704734.jpg" alt="DSC01290"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211706750.jpg" alt="DSC01299"></p><p>到这里玉门关的景点算是逛完了，大厅里面的一些展示也就是听了听讲解，也没有太多能记住的（<del>出去整个脑子都是放空的能记住啥</del>）</p><p>出门之后因为太渴太饿在门口的小店里面点了一份冰粉和西瓜，之前那对夫妻在窗外看到我还示意我一会过去。而我出门回车上的时候也没有遇到他们，我们也因为比较赶时间在吃完西瓜之后就直接上路去雅丹魔鬼城了。第一次看到雅丹魔鬼城应该是在小学的时候，父亲买了一本地质相关的书，那个时候的我就拿出来翻，而那个时候也没想到能有一天自己亲自过来看一看。</p><p>到了雅丹的时候算是那边的正午，一开车门就能感受到一股热浪。由于上午没有吃东西，在这边找到了餐厅就吃了48元一份的盒饭，离市区这么远也算是能对得起这个价格了。然后又是固定的买票、坐观光车环境。到魔鬼城来就是看雅丹地貌，连导游都说过来看就是“八分靠想象”，游览的景点都是在自然形成之后，人们靠想象脑补，并且换一个角度就是另外一个样貌了，这边也先随便放点照片了。（在轻薄本上调照片是真的折磨）</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211737950.jpg" alt="DSC01362"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211737329.jpg" alt="DSC01410"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211737130.jpg" alt="DSC01437"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211738970.jpg" alt="DSC01464"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211738962.jpg" alt="DSC01479"></p><p>在这边看完之后我们就往市区的方向走，本来还打算去一趟阳关但是时间不太够了，因为预订的沙漠露营的活动有点赶。在出省道的时候还有一个设卡检查，我们还猜测是不是新疆过来的有安全检查，排队排了快半个小时才知道是在查健康码。在路上还能一直看到道路左边一直有一个东西在发光，在后面我们才确认那是附近的光伏电站聚集起来发电的光。</p><p>出卡后没多久经过了敦煌古城，是一个中日合资建成的影视基地。由于赶时间的原因我们也没有进去看，只在外面看了有宫殿和一些其他的建筑，好像还有一个狮身人面像（？）然后到了沙漠营地，在一开始我想象的沙漠营地是在最起码两个沙丘后到的地方，由那边的人用越野车送过去。到了之后才发现其实也就是在市区边缘的沙漠附近弄的营地，想来倒也合理，如果远了的话电和水什么的供应不上，而且维护成本也会更高一些。下面是在沙丘上拍的日落，第一张为了能看到下面的营地稍微调低了对比度(<del>他们说的沙漠腹地算不算虚假宣传</del>)</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202209172242802.jpg"></p><p>在青海和甘肃这段时间不是赶着看日出就是等着看日落，那个时候也开始觉得好像两者并没有什么太大的差别。在日落后回到营地下面，等着营地里面搞的篝火晚会。无非也就是和其他到这边来玩的人一起坐着吃火锅，然后同时看这边的人办办活动。总的来说还算是一种很难得的体验，在烟花升起的时候还让我恍惚了一下，多少感觉有点小时候过节的那种氛围了。而随着年龄的增长和回家的时间越来越短，能让我有这种感觉的场景也越来越少了。（后面还有篝火和蹦迪，感觉没啥写的就略过了）</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112104125.jpg" alt="DSC01634"></p><p>这边晚会差不多结束后我和 f1ag 大哥就回帐篷了，因为接人去沙丘的队列还要等会。而后面到了之后才发现所谓“沙漠腹地”就是在看日落的沙丘上。不过在远离了帐篷区后，确实能够看到很多的星星，也不是不能拍。记忆里看到这么多星星还是在老家停电的时候，大概是初中的时候，偶尔遇到停电的时候能看到漫天星河，不过那个时候没有怎么注意观察过银河。爬上沙丘，在眼睛短暂地适应后能够明显地看到银河。而这个时候我们带了一路的三脚架也终于可以用上了，架好脚架先试着拍两张，然而焦没对上直接糊了。而且比较不好的一点是那边经常会有 ATV 经过，导致有灯光的污染，我旁边的大叔就一直在吐槽这怎么拍= =</p><p>然后大叔带了相机没带脚架，找我借脚架折腾了差不多十分钟，我感觉时间有点长了才要回来，然后大叔又去找了别人借脚架。我自己拍了很多张后感觉差不多了，拍多的好像也就哪样。而且因为延时比较长又没有赤道仪（太贵了），导致拍出来的银河放大能够看到很明显的星轨。后面回来了才想到应该可以多拍点低延时的再堆栈，确实也是经验不够足也没想到，下次不知道是啥时候了。老是感觉可以啥时候回老家可以试试，不过大多数时间都是回市里回不去村里。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112124053.jpg" alt="DSC01772"></p><p>而在沙丘上回头能够一样看到北斗七星，应该来说是头一次看到北斗七星，确实来说活了20多年都没有怎么好好地抬头看过星星。一方面也是条件不允许，在城市里面抬头只能看到寥寥几颗星星。在此之前也没有注意到过原来北斗七星能有这么大，它大概占据了人的视角的一半，怪不得会有人看到后会有巨物恐惧症。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112131000.jpg" alt="DSC01798"></p><p>在沙丘上待到了凌晨一点才坐那边的 ATV 下去，我实在顶不住困意下去就直接睡觉了。随身携带的耳塞也正好派上了用场，挡住了其他帐篷传来的吵闹声。后面醒过来是凌晨5点，醒来发现 f1ag 大哥还醒着，合着是一整夜没睡。后面才知道他在帐篷外面折腾了几个小时在拍星轨，还说中间还想过自己走到山丘上去，又怕出问题。然后我们又开始守着看日出了，其实最好的还是到山丘上去，但是那个时候太冷也不太想动，我们就守在帐篷外面看坐了一个小时。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112141435.jpg" alt="DSC01827"></p><p>时间差不多了之后就开车回酒店，因为头一天没订上莫高窟的票，导致我们今天没法去看，只能在敦煌又歇一天。由于大哥通宵了一整晚，然后只能让我开车。战战兢兢开了十多公里后才回到市区，然后在市区里面还因为没及时变道在十字路口转了好几圈（搁这逛街呢）。然后我们找了个加油站加油，回到酒店下面还了车，拖着行李上楼倒头就睡。休息到晚上在酒店后面敦煌夜市找吃的，然后现在也忘记吃了除了驴肉黄面还有什么了（下次一定吃的都记录一下）。</p><p>第二天快到中午了就直接打车去莫高窟，本来在我原计划里面环线甘肃没法走就直接不来的，但是大哥死活都要来莫高窟那就加了后面这段行程。在去洞窟之前先在游客中心看了又见敦煌的纪录片，里面就具体讲了附近几个景点，还有莫高窟的文化背景。而且还有球幕的展厅，算是比较新奇，但是看的时候感觉也就这样。在看完之后才被带着去莫高窟。莫高窟距离游客中心应该有30km，下车后能够看到没有开放的北窟，据导游说北窟的一些洞窟里面还留有以前一些僧人的骸骨。然后还有一条很宽的河道，不太清楚甘肃的雨季是什么时候，这个时候是8月份，在这边的河道里面也没有见过一点水，只能看到水流侵蚀过的痕迹。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112159249.jpg" alt="DSC01842"></p><p>莫高窟里面的洞窟是不给拍照的，所以在里面参观就没有图片了。最后参观大佛的时候在外面拍了点九层塔的照片，九层塔里面就是大佛，在里面看的时候也能感觉到特别壮观（什么叫做巨构建筑啊）。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112202154.jpg" alt="DSC01845"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112202913.jpg" alt="DSC01849"></p><p>在这边一共能参观的有8个洞窟，里面除了九层塔里面的大佛之外让我印象比较深刻的是323窟，里面有个元素是张骞出使西域图，因为以前在历史书上见过所以记得比较清楚。其他的洞窟在参观时基本上是左耳进右耳出，确实也只是了解一下了。参观完了出来后我们就在外面的陈列馆转转，里面是一些国家对莫高窟探索、保护的记录。陈列馆也就是以前的工作人员在这边生活的住处，只是看着的话感觉蛮惬意的，但是再看看周遭的环境就能知道在这边工作需要多大的信念了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112207762.jpg" alt="DSC01852"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112211464.jpg" alt="DSC01864"></p><p>在这边出来后就到了卖纪念品的地方，逛了一圈感觉没什么特别想买的。还说和在青海一样，买了一套明信片，在这边还能自己盖印，然后就有了奇怪的收集欲。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112223041.jpg" alt="DSC01948"></p><p>（莫高窟这边还逛了另外有两个展览馆，先放着后面再写了= =，咕咕咕）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;8月2日（&lt;em&gt;Day.10&lt;/em&gt;）中午在机场还车后赶飞机，从西宁飞到</summary>
      
    
    
    
    <category term="杂记" scheme="http://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="游记" scheme="http://decision01.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>毕业行·青海</title>
    <link href="http://decision01.com/post/de12d551.html"/>
    <id>http://decision01.com/post/de12d551.html</id>
    <published>2022-08-10T15:35:11.000Z</published>
    <updated>2024-04-08T08:03:49.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>7月29日（<em>Day.06</em>）结束了三天的隔离，虽说隔离这几天感觉可以自己偷偷润了，但是考虑到还是在别人地盘上就别瞎搞了，万一被整个活赋个黄码到处都没法去。</p><p>这一天上午不太想出去找吃啥，还是点了个外卖随便吃点。然后中午等f1ag大哥来西宁，后面写的话就一直写大哥了，在博客里面带上名字老感觉有些许奇怪。本来一开始青甘环线是在群里叫了四个人的，其他两个人后面时间不凑巧也就没法来了。然后只有f1ag大哥一个人开车，一天也没法跑太远，所以我们就放弃了跑青甘大环线的计划。后面商量了一下只能在青海走四天的小环线之后直接飞去敦煌，去看甘肃那边剩下的几个景点。青甘大环线全长2200km，一大部分时间是在赶路，所以是可以放弃中间的路程的，不过现在想的话，未来如果有机会想再跑一趟青甘大环线。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101438852.png" alt="青甘大环线"></p><p>事先问了下酒店能不能晚点到下午2点退房，因为大哥12：30到西宁，半个小时的时间应该没法办完租车手续，并且开车过来。酒店老板说目前过来旅游的比较多，所以最多只能到下午1点，如果要加时间的话只能开钟点房。对比了一下之后还是只能去楼下的王府井广场找个咖啡厅坐着等大哥过来。</p><p>大哥过来之后就先去了KFC，坐了一上午高铁也没吃东西。完了之后说让我中午就在市区里开会车，但是西宁那个路比毕节还窄，很难相信这是一个省会城市会有的公路，所以后面也就没让我开车了。于是青海小环线的这1100km我一直在坐车，让大哥坐牢（bushi）。原计划是从另外一条国道去塔尔寺，然后再去拉脊山。不巧的是这几天青海在举办环湖骑行赛，正好封闭了拉脊山的道路，所以我们只能直接上高速，往黑马河的方向走。</p><p>从西宁出发大概是下午3点，看了导航到黑马河有4个小时的路程。在出市区后的一个小时的路程上还是能看到比较陡峭的山，和贵州这边的山相比就是少了植被。然后山上还有一种类似梯田的结构，但是上面没有种植的痕迹，猜测是以前种植东西，后来被丢荒了的地。一段时间后能够见到以前只在网络上看到的那种草原了，远处是看起来不怎么高的山丘。在路上还能时不时遇到被放养的🐏群，遇到这种只能慢慢跟着走（<del>科目一复习</del>）。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101511453.jpg" alt="青海的草原"></p><p>又过了一个小时后才到了青海湖边，我们找到了一处临时停车场可以停车。停车场附近有一条路可以到湖边，在来之前看了一些攻略说靠近湖边会有牧民要收费，幸运的是这边没有人守着，应该是公开给游客进入的。后面路过一些地方就是围栏边上有人守着，那种可能就是靠近需要给一点费用。</p><p>选择来青海和看青海湖应该算是小时候的一种情结，以前家里买了一张世界地图，在地图上能够看到形似兔子的青海省，还有正好在眼睛位置的青海湖。而切实到达这里后发现青海湖的确很广，在停留的这边出发到黑马河的路程中还能够看到不远处的湖。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101558465.png" alt="在湖边拍的青海湖"></p><p>青海天黑的世界比较晚，所以我们就没有在这边停留等着看青海湖的日落。第二天也要早起看青海湖的日出，从某种方面来说看日出和日落是差不多的。在这边和大哥合影，随手拍了几张照片之后我们继续往黑马河走，大哥说到了乡道再换我开车，然而这个时候我比较纳闷的是黑马河乡就是国道边上的村子，似乎也没有什么乡道。也是到了黑马河之后我才知道，这天晚上是住在集装箱里，不过也行，这种地方能有个睡的地方就很好了。在黑马河这边找了一家餐馆吃青海的特产——土火锅，吃起来只能说一般，就是放了冒菜会放的那些素菜和牛羊肉一起在一个火锅里面煮。比较麻烦的是还不太好把菜翻出来，算是在旅途中吃过第一次就不想吃了的东西，只能说是第一次吃感觉比较新奇。</p><p>吃完之后在周边也转了转，没有急着回<del>酒店</del>集装箱里面。大哥到处看想买点水果，但是这边的水果都不给帮忙切，到最后就只是在一家超市买了两瓶氧气就回了。回集装箱后又开始原来的建群活动，下了吃鸡手游玩玩，时间差不多了就定了早上5点的闹钟准备第二天看日出。</p><p>7月30日（<em>Day.07</em>）凌晨5点在安详中被手机震醒，大哥头一天说定的5点的闹钟也没有听到动静。于是我只能先起床等一会，凌晨5点的青海湖边上特别冷，感觉和入秋那个时候一样，这个时候突然明白了酒店给了一床毛毯的意义。并且集装箱里面的空调也没有什么用，开着空调能感觉到在吹暖风，但是整个集装箱里面还是冷的。没几分钟之后大哥被我起床的动静吵醒了，我以为他也是设置的静音振动就没问，我们看着天快亮了就开车找个能够靠近湖边的地方。本来我想的是能够直接开车进湖边，绕了一下只有一个入口的地方人和车都比较多，但是只能步行或者乘当地人的摩托进去。于是我们在路边停车后带好相机就走进去了，大概走了1.5km到了湖边，这个时候湖边一家围一堆人，那就找空隙的地方或者别人坐的后面插进去占个拍照的位置。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208102300636.jpg" alt="青海湖日出"></p><p>在太阳完全升起之后相机也没法承受直射CMOS了，有点后悔没把ND镜拿出来，但是带上ND镜的话又要拿三脚架，所以也没啥太值得后悔的，最开始还是比较想轻装出行。然后我们就在后面拍了拍经幡和远处的山。在我觉得拍的差不多了的时候，大哥守着湖边的几只鸟等它们起飞的时候拍鸟，于是在这边耗了点时间。在青海湖边还看到了海鸥，最开始大哥说是海鸥的时候我觉得不太可能，海鸥怎么可能在这么内陆的地方。后面上网查了一下，青海湖正好在鸟类迁徙的途中，所以会有海鸥在这边繁衍，<strong>想不到青海湖真的有海鸥</strong>。返程的话大哥说要节省点时间那就直接坐摩托了，本来走着觉得温度还好，但是上了摩托后体会到了切实的冷，短短几分钟的路程让我感觉度过了半个小时。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208102332963.jpg" alt="湖边的经幡"></p><p>在经幡周围会有一些藏民堆起的石堆，这些石堆被叫做玛尼石堆，藏民认为石堆有灵性，于是会在经幡附近、山上、湖边这些地方堆起石堆用来祈福。（<del>大哥说这个是坟头</del>）</p><p>回到路边后先把车开回酒店停着，在酒店对面找了一家面馆解决早餐。早上不太想吃面，于是我在这里点了一份混沌，但是吃起来感觉有一种说不出的怪味，但是不影响能吃下去。这之后我们就启程去茶卡盐湖，从黑马河到茶卡盐湖的这段路风景都很不错，虽然录了像但是也没法单独截取图片出来。</p><p>在快到茶卡盐湖的时候路过一个小路路口，然后边上还写了“茶卡盐湖·天空壹号”，这让我们误以为是茶卡盐湖的另外一个景区是从这里进去，但是越到里面越发现不对劲，到了没路的地方才发现里面有一个经幡，可能是藏民祭祀之类的地方。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208102332125.jpg" alt="道路尽头的荒芜"></p><p>稍作停留之后我们又倒回去，在到路口的时候又有几个车想要进去，在大哥说了里面没有什么看的之后他们也跟着出来了。在国道上走了一段距离才是真正的天空壹号的入口，可是这里也不让进，只能买门票坐观光车进去。实际上整个茶卡盐湖景区都是只能坐观光车进去，而我一开始做攻略的时候把观光车免票记成了可以开车进入，于是我们在到景区门口后又被劝返。在回到游客服务中心的途中还做了一下核酸，这一段路上基本上是需要一路做着核酸走，不然一些景区没有48小时核酸不给进。</p><p>在游客中心买了门票，下车的时候忘了带上水，于是在门口买水。大哥还买了所谓的盐湖的盐冰淇淋尝味道，老板说15块钱一支的之后还自己打折说10块钱就行，还说在景区里面要排队买，实际上到了景区买的人也寥寥无几。坐观光车到景区后还要自己买个小火车票或者电动车票，景区里面分了4个站点，只有第一个站点是能够坐电动观光车过去的，其他的站点都只能坐景区里面的小火车过去。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208102329087.jpg" alt="盐湖景区的小火车"></p><p>第一站有盐雕和经幡，在这边就是到处转转拍拍照。在这种地方俩大男人互拍也蛮奇怪的，所以就算各自拿着相机拍盐湖、盐雕。在某个地方能够下到盐湖边上，踩下去能发现非常的坚实。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111209879.jpg" alt="盐湖"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111209090.jpg" alt="盐湖附近的经幡"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111216576.jpg" alt="随风飘动的经幡"></p><p>这边转了一圈后坐小火车往里面走，后面的几站基本上就是游客租鞋套进去拍照的地方了。我们在第二站停留了一会后直接往最后一站去，因为想着票都买了，只坐一站有点亏，但是坐到最后又要买一张票回去。<del>这是景区的圈套</del></p><p>在最后一站我们也是随意看了看，然后拍了几张照就算是游览完了。因为早上凌晨5点起床，所以现在我们俩人都非常困，我们选择等敞开的那种火车再回去，不然在封闭的车上容易睡着。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111221570.jpg" alt="20220730-DSC00464-3"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111221418.jpg" alt="20220730-DSC00465"></p><p>坐火车的时候把ac2贴在护栏上录像，不太好的地方是ac2的方向不能自适应，也就是和手机那种竖向不能拍横屏，大概是由于底就是长方形的。在火车上的时候对面还来了一家三口，看起来是一家人带着刚高考完的学生出来玩。家长问要不要去这里那里看看，而对面的女孩就有些许不耐烦的说有啥好看的。下车后就和大哥说，如果是我们高考完那会被家里人带出来玩得有多高兴。</p><p>景区出口前有一个纪念品购物的地方，进去转了转没啥想买的，买回家估计还得被骂浪费钱。不过里面有大块的盐结晶挺有意思，不过它不是单独卖的，而是一个套盒。出来之后临近出口的地方还有一个卖东西的地方，刚好遇到有人在卖大块的盐结晶，问了下价格也就5块钱，感觉还可以就卖了一块，然后老板又送了一块。这种东西自己在家里都可以做出来，也就买来算是一个纪念。出来的时候还买了两份酸奶，来都来了还是要尝尝特产。</p><p>出门之后大哥要去看一下景区的自助餐什么样，在看过之后我们都说狗都不吃，比学校里面吃的都不好。然后开车到镇子里面找地方吃东西，最后找了一家店吃炕锅。这个东西其实也就是干锅，不过确实味道和干锅确实有点区别。又带上了在出口买的酸奶，吃了第一口感觉蛮奇怪，应该是表面的酥油的味道。后面吃起来也和普通酸奶没啥区别了，但是由于吃的太多也没法继续吃下去，只能扔在饭店里面了。</p><p>这一天也就只有去茶卡盐湖一个景区，按照原计划这个时候我们应该往大柴旦的方向走了，但是绕湖的小环线就是反方向。看了地图可以原路走109国道返回黑马河再去刚察，也可以直接走另外一条路。总体而言两条路的路程是差不多的，于是我们选择往新的路315国道上去看看。</p><p>去刚察的路上，大哥的闹钟在5点的时候响了。合着大哥设置的是下午5点，怪不得上午的时候没有听到动静。</p><p>到了刚察后，刚到酒店大哥发现酒店没有空调，大哥就说退房找另外一个有暖风的酒店。我也是头一次遇到这种，以为平台只会瞎扯皮，没想到平台处理速度蛮快，没几分钟就给退款了。在我们到另外一个酒店的时候已经9点了，这个时候刚察的天才黑，找了一家烧烤店吃个晚饭。这家烧烤店是中间一个炭火，然后上串好的肉自己烤的那种，味道还不错，又开始我们的边吃边聊环节。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111247842.png" alt="来点烤肉"></p><p>青海这边的餐馆比较奇怪的地方是，他们很少能注意到顾客说话什么的，好几次我们说结账或者加什么东西的时候都没有被注意到。还有我们在说要饮料的时候店员还愣了一下不知道是啥，在大哥换了说法后才说让我们下去拿。吃饱喝足后回到酒店，又开始游戏消磨时间。</p><p>7月31日（<em>Day.08</em>）早晨9点才醒，没多久就收拾东西出发往祁连走。<em>感觉这一路上都比较匆忙，我们的时间只够打卡景区，没有时间在县城里面到处走走看看。</em>出刚察的路上还是广袤的草原，更远处是山脉，在这个季节能让我们看到的山都没有积雪，但是能够积雪的季节估计也没空过来。出县城后没多久转入一条破旧的省道，相比国道来说应该能够省几十分钟的时间。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111253412.jpg" alt="IMG20220731112319"></p><p>在省道这种路上我们的ac2也就不能充当行车记录仪了，车子容易抖，一抖就没法把它放稳。在路过一个县城的时候，大哥让我下车去看看有没有双面胶卖。在马路这一侧的超市看了一圈只有胶布，走到马路另外一侧进了一家超市才买到。一开始过去还以为没有开门都准备走了，但我还是试着推了一下门发现能够推开。问店主要了厚一点的双面胶，然后他给了那种泡沫胶，贴上就不太好撕下的那种。于是这次我们真的可以把ac2当成行车记录仪了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111344115.jpg" alt="大疆 Action 2 行车记录仪"></p><p>中途找了一个岔路口停下吃东西，买的自热快餐再不吃也就要留到西宁了，吃完后在路上的一个观景台拍了祁连山的照片。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111350169.jpg" alt="祁连山全景拼接"></p><p>走过一段距离后大哥找了路边临时停车的地方停车休息，而我没有开车的机会一直精神抖擞，我就拿着相机下车去对面看了看。天气不太好，也就没有什么好拍的风景。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111353199.jpg" alt="20220731-DSC00483-2"></p><p>休息的差不多都快要走了，然后我看到高处的地方不知道是什么动物在动，而且还比较多。大哥看到后二话不说拿着相机就上去了，然后我正好换了长焦我也跟着过去。上去后在相机里面能够看到是像老鼠的一种动物，但是应该不是鼠类，事后查了百科才知道是高原鼠兔。于是我们在这里又继续停留了一个小时，拍了一个小时的鼠兔。。那就放点高原鼠兔的照片，感慨一下长焦的好处，买的长焦镜头一万年没用上。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111406822.jpg" alt="在打架的鼠兔"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111406099.jpg" alt="20220731-DSC00497"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111406975.jpg" alt="20220731-DSC00500"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111406583.jpg" alt="20220731-DSC00506"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111406584.jpg" alt="20220731-DSC00509"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111407729.jpg" alt="快门按下瞬间正好回头的鼠兔"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111407287.jpg" alt="20220731-DSC00516-2"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111407966.jpg" alt="若有所思.jpg"></p><p>在我拍的差不多的时候大哥还在洞边上守着，想要近距离抓拍。我这边守着的另外一个洞口一直有一只在张望，在我拍好了后让大哥过来，可是105mm的焦距靠近洞口就给它吓回去了。后面和大哥合围一只鼠兔的时候它进了一个洞里，然后大哥又开始守这个洞口。在我疑惑的时候，大哥说鼠兔还在里面。在靠近看了后才发现这个洞口特别浅，鼠兔进去后也没地方可以退了，大哥就把我手机伸进去，于是有了下面三张名场面。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111411394.jpg" alt="手机拍到的"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111415849.jpg" alt="大哥拍到的"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111417956.jpg" alt="我拍到的"></p><p>在“折磨”完这只可怜的鼠兔后我们继续启程去祁连，途中有一段路特别有死亡搁浅场景的感觉，不多不少的植物，阴沉沉的天还有笔直望不到边的公路。拿手机拍了一张后加个水印嗯凑元素。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111427594.jpg" alt="IMG20220731152944"></p><p>走了20km左右到了这段旅程中海报最高的地方——大冬树山垭口，据称海拔4120，而手机显示的海拔不到4100。本想着在这里停留几分钟就下十八盘继续赶路，而我俩在往上爬了一段之后又花了可能一个小时的时间。大哥甚至还想去更远处的山头，但是那边太远，而且也被围栏围住了只能作罢。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111421978.jpg" alt="20220731-DSC00553"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111421933.jpg" alt="20220731-DSC00552"></p><p>顺带一提这边的厕所，是旱厕，但是下面是完全空的，底下到上面可能高出来4、5米，不过这种地方确实也只能有这样的厕所了。在这边逛完后继续往祁连的方向走，从这里下去就是蜿蜒曲折的十八盘公路，顾名思义也就是有18个弯。在下来后才感觉到，恐怖的不是18个弯道，而是弯道上一堆“炮弹坑”，并且路边没有护栏，如果控制不好就会直通山底。</p><p>过了十八盘一段路后到了冰沟林海，冰沟林海在原来大环线的路线上并不顺路，需要单独过来看。大哥把车开到了还没修好的景区门口后，看守的大叔就说收点停车费，人可以免费进去看，于是把车停在这里进去拍点照。<em>虽然拍了一些，但是现在看的时候发现没有可以调的照片。</em>然后出来之后上路，在前面指示牌的指示下我们又进了一条小路，开到最里面有一处看起来很高档的建筑。在我们猜是在建的酒店还是私人别墅的时候，到了前面才看到写的是科研基地，很难想象修成别墅一样的科研基地，<del>请务必让我来这里科研</del>。到最里面还能遇到有人在这边拍婚纱照，我们过去后把车停在的河谷边上，大哥拿上相机直接下水，我拿着相机发现不太好找固定的地方就回车里拿出三脚架再套上ND镜，<del>现在感觉还不如手机拍的</del>。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111437302.jpg" alt="手机拍的"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111440676.jpg" alt="ND f/5.0 5s"></p><p>在这边停留的时间差不多后去祁连，冰沟林海到祁连的距离不是很远，但是我们订的酒店里县城比较远，就在卓尔山景区门口。在启程前又遇到了老鹰在头顶上盘旋，大哥又拿出相机停下拍，并且为了守着一只鹰起飞在科研基地的围栏边上等了20多分钟，<del>我说他这样子拿着长焦拍基地里面跟个间谍一样</del>。</p><p>在到了酒店整顿一会之后，本来说出门吃烤羊，但是大哥说可能需要提前预订，那就选择了另外一个方案的自助小火锅。而这一家算是这一趟的一个阴影，上的锅底什么的都还好，摆着的蔬菜水果也很新鲜（用大哥的话说这些东西毕竟没法骗人）。但是在我打开冰箱门的时候我沉默了，里面传来一股恶臭味，而且三个冰箱一个比一个臭，在最后也就吃了点能吃的肥牛和蔬菜之后直接走了。</p><p>8月1日（<em>Day.09</em>）头一天本来是说想看卓尔山的日出，但是这天也不可能早上上山，最后还是睡到了9点多起床，然后买票进景区。这边的景区都只能坐观光车去，可能以往是能够自己开车进去，但是这几年车越来越多为了可控就都只能观光车了。卓尔山的山下一大片是油菜花，很可惜的是我现在的摄影技术还不能拍出那种亲眼所见的震撼，后面也直接放点照片了~</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111455627.jpg" alt="卓尔山油菜花田"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111619945.jpg" alt="远处的村庄"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111619358.jpg" alt="山路和牛、车"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111619651.jpg" alt="卓尔山B线的观光车"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111619909.jpg" alt="休息的牛"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111619648.jpg" alt="全景拼接，忘了拍左边"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111620149.jpg" alt="牛心山"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111620045.jpg" alt="油菜花田"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111620703.jpg" alt="在另一边的观光台拍摄远处的塔"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111632283.jpg" alt="对面山头的观景台"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111633955.jpg" alt="两张图片的拼接"></p><p>游览完了后我们到下面的县城里，又找了一家炕锅吃（已经有PTSD了）。然后做了核酸后启程赶回西宁，途中经过阿柔大寺，大哥就说过去看看。虽然这一段只有30km的路程，但是到了之后两个人都特别困，大哥停车之后就开始摆了。睡了有几十分钟后被大哥的闹钟吵醒，然后大哥开到寺门口，需要下车买票，而我午睡后就是大脑放空的状态，不知道那个时候买票的小姐姐是不是觉得面前这个人是个睿智。</p><p>阿柔大寺门票15/人，算是象征性收一点停车费、清洁费之类的。进去之后也是转圈看一些看不懂的东西，只能在外面拍照。以后去这些地方前还是要提前了解一点宗教的东西，不然没法看懂寺庙里面的东西，很多东西在历史上是邪是正也无从而知。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111641362.jpg" alt="阿柔大寺中的大殿"></p><p>阿柔大寺不同于很多景区的寺庙的地方是很少能看到有推销“佛教产品”的行为，里面也有一些僧侣，不过这些僧侣也都是各干各的不会干扰游客，这样的氛围感觉就很好。在参观完了后，大哥说去尝一下边上的一家牦牛奶茶，虽然我没有太大兴趣但是架不住大哥还是跟着去了。</p><p>因为之前在车上睡醒大脑还是放空的状态，所以我跟着进去也没怎么动脑子。大哥点了一壶奶茶和一份糌粑。然后大哥开口就说是糍粑，我一听也先入为主听成了糍粑。大哥说了两遍糌粑，还问是什么样子的，店里的女孩就反问，你们是要糌粑吗。这个时候我们才发现，上面写的是糌，而这个时候我满脑子红糖糍粑。</p><p>进去的时候还有另外一队客人，一开始还以为是店家的亲戚。过来一会才发现也是游客，但是和店家聊的比较熟悉，还拍了合照，临走前还给女孩说好好学习以后考中山大学。在他们走了后店家台了三盒东西出来，大哥就给我说这奶茶不会是现冲的吧，拿这三个东西和在一起冲泡。我听好像也有些道理，因为有一盒东西确实很像奶茶粉（实际上应该是用青稞做的炒面），而且还有另外一盒是白糖。然后店家又拿了一只透明手套过来，我看了下也没怎么注意，而事后大哥说他想要再要一只手套，毕竟两个人吃。没一会他们端上来了一壶奶茶，还有一盒酥油。那边的酥油是团成球形的，我就在想，原来糌粑是一颗一颗的，那这一份能有多少颗。</p><p>在我还在想的时候，他们倒了两杯奶茶，然后把我以为是糌粑的东西丢了进去。我惊了一下，这玩意儿还不是糌粑吗？</p><p>这个时候店家问是你们自己做吗，我们：？</p><p>愣了一下后大哥说还是你们帮忙做一下吧，店里的大叔就把前面的三盒原料按比例和在一起，然后让大哥喝了一口</p><p>我心里想，啊原来这才是糌粑，可是这东西是直接喝下去就可以的吗，这样调在一起不应该是要和面的那种吗</p><p>大哥喝了一口后，店里的大叔拿了回去，还问味道怎么样）。然后就开始把它们都和在一起了。我们喝了点奶茶之后糌粑也做好了，就是拿和好的材料捏成形，这样才是真的糌粑，而我在之前想的糌粑是一个饼的样子。。</p><p>这个时候大叔看我们喝了半杯就给我们添上，又坐在边上，感觉是想和我们聊聊天。可惜的是店里的女孩子不在边上，因为我们听不懂那边的方言，女孩在的话可以翻译一下。大叔问了一句你们是哪里来的，这句话多少能够听懂一些，我们答复之后大叔发现我们好像不怎么说话，在我们边上坐了一会就走了。</p><p>在去西宁的路上我们复盘了一下，在这个店里的每一步都在我们俩的预料之外。所以在大叔要和我们聊天的时候大哥就没有主动说话了，因为让他们知道一个985和一个211的把糌都成糍还挺丢人的。我说问题不大，<del>你们俩电科不都是专科吗</del>。</p><p>在上高速前我们经过了门源，本来原计划可以在这边看雪山，可是这个温度山顶上没有积雪，只有祁连山脉更远更深处的山才会有积雪。门源这边的路也非常舒服，两边全是油菜花或者稻田。我们还在这边嫖了两次蜂蜜尝尝，路边养蜂的还是比较多，老是会有蜜蜂撞过来。但是我也没有买的心思，买回家还会被骂浪费钱hhhhh，因为家里有亲人是自己养蜜蜂的，也会给我家送一些。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111705528.png" alt="油菜花里的蜂箱"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111707404.jpg" alt="门源的稻田"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111707805.jpg" alt="IMG20220801182815"></p><p>门源这边的风景非常好看，可惜这一次只能在这边路过。离开门源后就上高速了，一路回到西宁，四天的小环线就结束了，然后第二天从曹家堡机场飞到敦煌，开始下一站甘肃的旅程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;7月29日（&lt;em&gt;Day.06&lt;/em&gt;）结束了三天的隔离，虽说隔离这几天</summary>
      
    
    
    
    <category term="杂记" scheme="http://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="游记" scheme="http://decision01.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>毕业行·武汉</title>
    <link href="http://decision01.com/post/5421685b.html"/>
    <id>http://decision01.com/post/5421685b.html</id>
    <published>2022-08-06T16:07:11.000Z</published>
    <updated>2024-04-08T08:03:49.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>时间到达7月21日的时候，手头的事情做的差不多了，所以也开始我这趟所谓的毕业旅行了。</p><p>第一站是湖北武汉。</p><blockquote><p>上一次来到武汉还是在四年前，那应该是高考刚过没几天，当时在通过了几所学校的自主招生初试后选择了华科。</p><p>所以和初中同学约好了一起去一趟，很可惜的是那个时候没钱去玩儿，唯一的印象就是在华科面试和在欢乐谷玩了两个项目。其余的时间就是在酒店颓废，最大的原因是高中刚毕业没钱，也不想太过度花家里的钱，所以很多地方也没有去成。</p><p>也是在四年前到达武汉的那个晚上诉说了自己的几年心情，很可惜<strong>由于曾经错误的选择导致的非预期的结果</strong>，不过回想起来确实草率了一些。</p></blockquote><p>这一次首先选择到武汉是为了见一见本科认识的一位学长，他目前在华科读研，也就是上一篇博文所说的一起组队参加信安大赛的学长。</p><p>本来原定计划是还要去一趟浙江找另外一个学长，也算是对我大学生活影响比较大的一位，可是由于疫情的原因还是尽量缩短行程，未来再找时间去了。</p><p>7月21日 (<em>Day.01</em>) 从成都出发，半夜到达武汉。武汉天河机场候车的地方比较奇怪，转了一圈没有找到可以等网约车的地方。然后坐了个黑车当了次被宰的肥羊，12km的路要了我100。以前没有坐过这种，这次算是体验了一次黑车是啥样。路上一直和黑车司机打诨，大半夜的对这种司机说话也就半真半假。</p><p>然后到了天河机场附近的一个酒店，在网上预订的时候看到离机场比较近，没多想也就订了。结果到了机场才发现在机场边上的城中村里面，绕了一圈有12km。</p><p><em>出门的时候成都的疫情比较严重，比较幸运的是武汉的防疫要求和打电话询问的一致，只要没有中高风险旅居史就只需要3天2检。</em></p><p>7月22日 (<em>Day.02</em>) 从酒店去光谷，在哈啰上面约到一个车从城中村把我接出去了。</p><p><em><del>这种地方下次狗都不去</del></em></p><p>在路上的时候师傅问我是不是出差来了，我说来找同学玩儿。然后师傅就开始给我推荐住在江汉区，武汉大部分玩的都在江汉区。但是想了想还是先按照之前的订的看，毕竟在华科附近可能会方便些。<em>后来看了一下发现也好，住在华科附近的话玩好了可以跟学长一路回去。</em>到达机场地铁站后，坐了将近30站的地铁去光谷。4年前也是坐的地铁去光谷，但是很奇怪的是没有觉得有那么长的时间，或许也是没有太记住这件事，导致自己的认知存在一定的问题。随后到了光谷附近的酒店，到了酒店先和导师通了一下电话讨论了他刚才想出的方案，听起来可行但是具体的实现细节我还没看过，也暂时搁置了。还好的是手机开了自动录音，这样后面有哪里在当时讨论不清楚的地方也可以回放看。</p><p>在酒店充了会电之后出门去光谷找学长吃饭，一开始叙叙旧，然后讨论了一些各自学校的科研组的氛围，还有各自老师怎么样的事儿。吃完饭后学长打算带我去东湖转转，我也正好去一下之前来的时候因为受不了高温没有去成的东湖。在去之前我们又跑到商场里面买了“茶颜悦色”，算是让我尝一下这个闻名已久但是没有喝过的奶茶。光谷的这个店比较奇怪，有线上的平台和电子屏不好好用，只有拿着号去问才能取到，<del>算是用户驱动了</del>。然后打了个车去东湖，先找了个荫凉的地方歇了一会，四处转了一下才找到磨山公园的入口。</p><p>进到磨山公园后我俩就四处瞎转，一直循着上山的路走，边走边聊，就像是在本科时候大家出去吃饭的时候一样，大家一边走一边说过去现在未来的琐事。在磨山公园走了一段时间后到了下山路，也就到了东湖的湖边，湖边的出口处停放了一些自行车。在35℃下想要步行绕行有点费人，于是我们选择骑个车从湖中道绕一圈。骑了没多久到了东湖边上的一座观景的城楼，然后就上去看看，正好这个时候在小群里面另外那个学长让我们来张合照。我们就上了城楼后，在观景台拍了一张合照。可惜的是手短和城楼观景台上留出的空隙不够大，整张照片就被俩人头占满了。下了城楼后继续往前走，东湖这段路大概有7、8km，骑行下来走走停停花了一两个小时。在路上的时候我一直感慨在成电附近没有这么大的湖，不然在有空的时候我肯定会出去转一转。学长也打趣说让我马上弃保考研去华科。</p><p>在东湖转完之后没多长一段路就是湖北省博物馆，找了一个地方停自行车后我们说看看能不能进去瞅瞅。结果发现博物馆都需要提前两天预约，然后又走回到停车的地方想说骑车去别的地方，结果回去之后自行车又被骑走了。剩下两辆应该是坏了的车停着，毕竟有些地方停着车没人骑走是有原因的。这个时候正好也累了，在东湖骑行一趟下来还是毕竟耗费体力的，就在博物馆门口找了个地方坐了一个多小时聊聊天。聊天的时候学长查到了长江附近有一条叫做粮道街的美食街，本来打算骑车过去的但是距离有些远，那就只能打个车过去了。坐车过去的时候正好遇到晚高峰，坐车花的时间应该和坐地铁过去差不多。</p><p>粮道街算是一条小巷，不宽也不窄的那种，两边被车停满了导致中间只有一个车道就显得毕竟挤。在这条街走的时候能发现这边的学校比较多，想来也是因为学校在这里的原因慢慢发展出来的街道。查了一下百科是因为原来武汉设立的粮道署在这边得名，后面粮道署也被改造成学校了。虽说是一条美食街但是让人觉得想吃的东西也没有多少，最后也就是因为渴的原因找到了一家冰粉吃，学长找到了一个便利店买了份快餐。走在街上能够偶尔避开不高的楼房看到不远处的黄鹤楼，在随便吃了点东西后我们还是抱着就算不能进去也在外面看看的心态走过去看一下。<em>上一次来的时候也想去黄鹤楼打个卡，但是在面试之后那几天开始下雨就没怎么出门了，好像还是雨后的晚上才出门在酒店附近转了一趟。</em>到了黄鹤楼下面之后发现还开着可以入场，门票好像是118一个人。付款之后拿付款界面给卖门票的之后，他们会发一个带链接的短信，进去之后是个二维码，然后这就是进场的票,还是头一次遇到这种门票，出来玩的还是少了些。用门票进去后在黄鹤楼下面的广场里面有卖黄鹤楼形状的雪糕，学长买了一个来拍照+吃，我因为之前吃了冰粉不太想吃冰的了就没有买。</p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101447599.jpg" alt="黄鹤楼夜景" style="zoom:25%;"><p>在广场边上有一个围栏处可以看到附近的夜景，黄鹤楼这边比较高，所以能够看到下面的层次比较分明，很有重庆的那种错落感（虽然没去过重庆）。这天有点可惜的是没有带相机出来，因为感觉带着不太方便，又不太想背着包出门。</p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101447403.jpg" alt="黄鹤楼下的武汉夜景" style="zoom:25%;"><p>在下面稍微歇息一下就登楼了，晚上8、9点的时间人还是比较多，能够看到远处大桥的地方都被人占满了，所以也没有能拍到照片。手机里面留下的只有一张光影比较模糊的，就不放在这个地方了。在里面转了一阵子之后就出门了，里面能看的也没有什么，而且因为人比较多我也就没有怎么拍照。出来的时候应该是9点过，我以为这个时候差不多该溜了明天再过来，然后学长说再走过去看看长江大桥。所以我们就顺着出来的这条路一直往长江的方向走，有2-3km的路程。大概走了半个小时到桥边，这个时候才发现在对面的路可以拍到另外一边的比较近的桥，但是这个时候也没法过去了，因为桥上没有供人走的路，路上的车都非常快。也就只能将错就错往另外一边看，这还是我头一次看长江。走在桥上能很明显地感觉到公交车路过的时候桥的震动，在中间拍照的时候还得小心点，不然手滑手机就没了。</p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101447165.jpg" alt="长江大桥夜景" style="zoom:25%;"><p>从桥的这一头走到另外一头之后，我们坐了一站公交去地铁，然后回到光谷休息。而我回到酒店第一件事就是先冲澡，这一天在30多度的温度下走了接近3w步，一整天不是在找买水的地方就是在喝水。冲完澡后发现酒店没有吹风机，那就只能等自然干一些再睡觉，于是打开酒店的投影看到凌晨1点多才睡。</p><p>7月23日 (<em>Day.03</em>) ，虽然躺了一晚上，但是平常不怎么走路，所以脚还是比较疼。在酒店洗漱完了之后问学长今天在哪见，就出门到他们学校附近了。学长就带着我去吃了华科附近的一家热干面，第一口下去我就发现是我错怪4年前那家店了。不是那家热干面店的不好吃，是我真的吃不来热干面的味道。热干面加了芝麻酱和花生酱，不是不好吃，是我确实吃不来这种味道。吃完之后学长说去昨天上地铁的地方，琴台，昨晚在路过的时候看了地图是个公园。然后我们到了江汉路后我说下地铁了，转另外一条线过去。然后学长说要不上去看看这边的步行街，我又跟着去了，反正确实是随缘旅游，头一天该看的也看了。江汉路原来是租界和华界的交界处，后面在资本的催化下变成了一条繁华的商业街。走在这边能看到很多外国风格的建筑，但是也满是商业化的气息，也就是在这边随便逛逛了。而且这一天是阴天，阴沉沉的好像随时都会下雨，出于这个原因也就没有拍照。这之后我们不知道怎么逛的到了武汉美术馆门口，想了想也懒得进去看了，进去无非就是觉得好看但是欣赏不来。走了1-2km的路后到了江滩公园，本来是头一天想晚上过来的，但是走完长江大桥后太晚了，也就放到这一天过来。从江滩公园的门口进去没几步就能到长江边上，江边很多戏水的人。我们俩就在入口那里的江边待了一会就在公园里面沿着江瞎转，走一会就找个地方坐一会，因为头一天确实走的太多了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101447706.jpg" alt="江滩公园对岸"></p><p>后面走到快出口的地方找了一个座椅休息，而我已经累到在那里坐着都能睡着的程度，如果再多待一会真的就在那里睡觉了。我就站起来说走了，这边也转的差不多了。于是出门后我们又走着去地铁站，乘地铁回光谷。到光谷广场后点了一杯咖啡，因为乘地铁的时候差一点在地铁里面睡着了。光谷里面太绕了，找点单的咖啡店比较麻烦，先去了-1楼的咖啡店之后店员说不是在他们店点的，又倒回到1楼才找到，还是很感慨光谷之大，上次来就不怎么能找到路。吃饭前我们就绕了一圈这边的异国风情街，虽然之前来过但是没这么进来看过。<em>上次路过这边是从光谷回到酒店，我也忘了为什么我会是从光谷这边走，应该是从华科出门后坐地铁到光谷走回去吧。</em>逛了一圈后快到6点了，找了一家自助烤肉，吃饱喝足后各自回去了。出地铁站的时候正好看到黄昏时的彩虹，不知道下次什么时候能再看到，也不知道下次啥时候能跟学长再聚一聚，<em>虽然说在打算我们俩去浙江找另外一个学长聚聚，但是感觉很难找到适合的时间</em>。</p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208101447298.jpg" alt="地铁站外的彩虹" style="zoom:25%;"><p>7月24日 (<em>Day.04</em>) ，这天是特意留出来的休息+恰饭时间。在高中的时候有一段时间打比赛，正巧认识了一个比我大一届的也是贵州的一个学长。虽然大家平常不怎么联系，但是看了他发的朋友圈是在武汉，所以就留出这天的时间找他吃一顿饭。因为前面两天走路太多了，下地走路的时候都是一瘸一拐的，所以我选择这一天直接整天在酒店休息，晚饭的时候才出门做核酸然后去找他。</p><blockquote><p>说起做核酸，武汉做核酸非常方便。据华科的学长所说的是因为5天不做一次核酸的话健康码会变成灰色，这就导致武汉这里差不多是隔一条街道就有个做核酸的地方。而我所住的酒店下面就有一个采样点，工作时间段没有什么人排队，一下楼就可以完成。</p></blockquote><p>在楼下做完核酸后发现时间也差不多了，没必要又上去等到5点出门，直接打电话联系学长之后打个车过去。见面后照例点菜，然后两个人互问学习、工作的情况。</p><p>7月25日 (<em>Day.05</em>)从武汉启程去青海，上午待到快10点就出门打车去地铁站。刚上车师傅问我是初中生还是高中生，我：？，然后就开始了一段奇妙的对话</p><p>在我说我是出来玩儿的大学生后师傅又问，“那你是在哪里读书的”</p><p>”成都“</p><p>”哦，那你是成都人？“</p><p>”不是，我是贵州的，来武汉是找华科的同学玩的“</p><p>“找女同学噻？”</p><p>“？没有女同学可以找”</p><p>“你是在成都哪里上学”</p><p>“电子科技大学”</p><p>“电子科技大学，，是985、211吗”</p><p>“嗯，是的是的”</p><p>“那你现在是要坐飞机回贵州？”</p><p>“不是，我飞青海玩儿”</p><p>“你这样玩？家里有矿啊”</p><p>“没有没有，自己在大学的时候攒了点钱”</p><p>聊的差不多了也就到地铁站了，1km的路也不是太远。像刚到武汉那天一样坐了差不多30站的地铁到机场，又飞到西宁。落地后西宁那边的防疫人员看到我有成都行程就先扣了身份证，让我拿了行李后去找他们。这会心里咯噔一下以为要隔离，拿了行李后被带去登记才知道是虚惊一场。结果机场放了我之后，我到了酒店后被那边社区隔离了，说是下午才通知的有成都行程的隔离三天，于是青海的行程就是7月29日才开始了。</p><blockquote><p>后面想来酒店的做法要上报社区其实是比较正常的，但是也不排除酒店和社区一起宰游客的行为。</p><p>因为后面在网上也看到有人遇到和我一样的情况，机场放了人，而且事前打电话问了都说没事，但是一到酒店就说是上午没事但是下午就接到通知要隔离的。</p><p>但是事情也都过去了，怎么想怎么做也没法挽回经济上的损失。也就只有那几天到处投诉打电话恶心一下他们。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;时间到达7月21日的时候，手头的事情做的差不多了，所以也开始我这趟所谓的毕业</summary>
      
    
    
    
    <category term="杂记" scheme="http://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="游记" scheme="http://decision01.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Epilogue/Prologue</title>
    <link href="http://decision01.com/post/774346dc.html"/>
    <id>http://decision01.com/post/774346dc.html</id>
    <published>2022-06-08T14:46:47.000Z</published>
    <updated>2024-04-08T08:03:49.039Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>姑且在毕业/开学之际写点东西</p></div><p>从前就喜欢在某个阶段完成的时候写点东西记录，最开始应该是在高一那一年开始写年度总结这一类的。然后高三毕业的时候也写了些东西，不过那个时候还没有博客，都是扔在空间里面。前两年的我还多少有一些分享欲，一个是因为确实只是单纯地想分享一下自己的生活，另外一个是那个时候还有值得我去分享自己的生活的人。到了现在之后，我这种分享的欲望开始减少了，一方面是越发觉得自己发的一些东西带了一份炫耀的味道，多少可能会带来别人的不快吧，所以后面在空间或者朋友圈发的东西越来越少了。有一两个经常交心的人能够分享一些东西也足够了。</p><p>四年前的这个时候我应该和班上的人吃完饭了，然后和同学们告别之后回到了老家。我完全忘记了那个时候我为什么这么急着回去，我还记得我在路上看到那个仍然亮着灯但是依然不能回去的教室，只能在车里拍了一张照片。然后想着未来十几天后或许我能够在出分之后自信地选择任何一个她能选择的学校，可惜到后面天不遂人意。今天有人问我四年前考完英语是什么感受，我回想起来没有什么感受，在面对充满了无限可能性的未来的时候是不能有什么太多的想法的，只能默默地接受即将到来的一切。在十几天后我得知了某件事后陷入了迷惘，不知道该去哪里，甚至填志愿也尽量不想被家里干预。虽然家里一直在给我说来我电，但是那个时候我想的其实是一个她最大可能会去的学校或者城市。也是在后面和她的聊天中，我下定了决心，把第一志愿从华科改成了我电。很可惜的是，在某种层面上这次我也选择错了，但是后面四年，也就是到现在来看，这样子的选择其实也不坏，不过是有得必有失罢了。</p><p>八月怀着对未来集体生活的憧憬组了寝室，在相处了一个学期后除了一些小问题其实也还好。但是随后的相处过程中这些小问题的积累让我开始不耐烦，一方面的原因也是我一个人生活惯了，导致很多事我在说过几次后就不想再继续沟通。当然，到现在我也抱有这种观点，如果多次沟通无用的话后续的沟通也是不必要的。</p><p>大一的时候进入学校很是迷惘，那个时候我想继续高中的竞赛，然后毕业就直接找工作。所以那个时候的基础课程都是划水过去的，甚至在大一上的时候线代期中考了20多分。其实也不是学不来，就是没法像高中那样去学这些东西，我很不想做的一件事情就是到了大学仍然像高中一样卷文化分，我只想好好学点东西然后毕业找工作尽早搞钱。然后首先是大一的时候先参加了学校里的安全竞赛的一个团体CNSS的招新，但是因为面试没怎么准备就挂了。招新赛光想着做出来卷排名，完全没注意到应该是一个学习的过程，然后在面试的时候去展示学到了哪些东西。然后大一下又去参加了ACM，然后也是在选拔的时候被各种吊打，在真实比赛的时候很多题完全没有思路，这也让我明白了自己确实没有搞算法的能力。</p><p>可是总不能什么都不学就停止了吧，大二下开始接触一些工程方面的东西。但是说来其实那个时候也没学到些啥，也就是随便做了一些前后端项目来练手，好让我在大三下的时候找实习能有些可以写的东西。然后还想学些逆向，但是也因为兴趣不是那么大就没有继续往深的地方学了。所以到了现在之后也还是很多东西停留在表面上多少懂一些，如果继续挖深的东西那么我也不会了。后面的时间过的很快，唯一能让我记住的就是接任了院学生会部门的视频小组，带着新进来的学弟学妹们学了一些视频剪辑的东西，大概大家聚也就两三次。回想起来其实我这个副部长是很不称职的，但是19年12月份的时候都想着还有下个学期可以继续组织一些活动，可是20年1月的时候疫情开始了，第二个学期也就没有了。</p><p>人所能到达的地方除了需要实力之外，运气也是很重要的东西。我现在觉得自己很幸运，能够在高中遇到一个能够让我为之努力的人，很可惜的是我现在不能亲自在她面前说一声谢谢。而在大学，我的运气又起到了作用。在学生会遇到的一位学长，在第二个学期的时候他知道我想要凑些项目经验，就来问我要不要跟着一起参加信安大赛的作品赛。那个时候我正好也在焦虑未来如何编写简历还有这样那样的事情，然后就欣然接受。就只是想单纯的凑个项目经验而已，没有什么获奖的打算。然后在大家就在读了指导老师的论文之后着手实现，这也是我第一次接触到区块链，准确来说是第一次进行区块链上的交易。然后也是我第一接触币圈，2020年其实是一个遍地能够捡钱的时候，现在望着后视镜来看的话，如果拿我第一次爆仓的一千多去买现货，现在也有不少了。可是那个时候什么都不懂，甚至还敢开合约瞎玩。话归正题，实现作品赛的东西的时候每周一次会，那应该是我第一次觉得开会要开吐了。后面结果也很好，我们拿到了一个全国一等奖。本来保研无望的我在加分后也能到往年的保研排名边缘，还有一个原因是我们是第一届大类招生，所以分流后卷王都去了计科，这就导致网安没有那么卷。在得到保研的结果后学长也早就毕业了，未来有机会是一定要去武汉请学长吃个饭的。</p><p>而后到了大三之后就是为了尽量保研开始卷成绩了，大三上的记忆一片空白，唯一让我记得的比较高兴的一件事是隔壁经常晃床导致我经常失眠的室友搬走了。然后大三上的那个假期开始看点数据库、设计模式的东西，到了4月之后开始投春招实习。暑假选择去实习而不是去外校的夏令营也是有两个方面的原因，一个是我认为保研并不是那么稳，所以没必要去外校卷名额，而且我也并不是那么想去外校，对我来说在哪里都是一样的。另外一方面是我想看看我自己能不能适应工作上的事情，那个时候总觉得自己会不会处理不了工作上需要处理的东西，现在来看的话其实是多虑了。后面的事情就是在六七次面试后被腾讯捞了，从6月一直实习到9月。然后9月得到了保研的结果，后面应该是一直在忙两三门课程的事情，似乎也没有太多的记忆。</p><p>寒假在考完科二后就回家了，然后科三到现在都还没去练过。这个学期进了实验室之后周一到周五基本上被占了，然后前两个月封校周末也没去成，最近两个月周末也有事情就一直没约上。随后就是这个学期，一直在科研和毕设两件事情上面串行，好像也没有太多的记忆。在寒假的时候，我的幸运带给我的机会也让我有了能够出来租房住摆脱集体寝室生活的成本。也让我切实体会到了“经济基础决定上层建筑”这件事，如果高中的时候我能有现在这样的自信的话，那大概那件事也不会是现在这样了。而在这四年下来也没有强求过自己去找对象，确实来说高中的执念无法放下是一回事，但是四年过去没有见过面了，人大概也变了吧。另外一个也是一个人待着挺好的，想做啥做啥，不用过于去考虑其他的事情。确实来说我是一个比较喜欢独处的人，特别是在周末就喜欢一个人窝着，就像是工作日耗尽了能量后通过独处来进行恢复一样。</p><p>然后在成都这四年，似乎没有认识一个能够真正交心的朋友。更多的是大家萍水相逢，正好有些共同的话题，共同的事情可以做而已。不过于我而言的话有初高中认识的两个续了多年火的朋友也很足够了。然后这四年好像也没去多少地方玩过，甚至没有出过省，大多数时间是往川西走爬爬山什么的。如果能有暑假的话暑假想到处走走看看，如果不是疫情原因的话是先去日本待几个星期的。当然，如果不是疫情的话现在能够拿出来花的也就没有那么多了，也算是因祸得福了。出去的话大概率也是一个人到处瞎跑，就像我最近一直和师兄师姐说的，毕业照都找不到想一起拍的人。要说自己在学校的主楼图书馆拍个穿学位服的照片吧，但是还要继续待几年，也没有那么必要。</p><p>就算是瞎写的一个总结了，继续走向充满了未知的未来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;姑且在毕业/开学之</summary>
      
    
    
    
    <category term="杂记" scheme="http://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="阶段性" scheme="http://decision01.com/tags/%E9%98%B6%E6%AE%B5%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>可验证随机函数</title>
    <link href="http://decision01.com/post/b30aad48.html"/>
    <id>http://decision01.com/post/b30aad48.html</id>
    <published>2022-04-06T10:21:14.000Z</published>
    <updated>2024-04-08T08:03:49.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>可验证随机函数(Verifiable Random Function)用于生成一个可以进行验证的随机数，生成随机数的生成者通过自己的掌握的私钥来生成一个随机数和一个验证参数(proof)，接收到随机数的验证者可以通过该随机数和验证参数来对随机数进行验证。可验证随机函数的三个特性：可验证性、唯一性和随机性。</p><p>这样一种存在公私钥对用于进行验证的函数，需要通过非对称加密来实现，下面以RSA和ECC为例。</p><p>该函数传入消息，经过生成者处理后输出一个随机数和验证参数</p><h1 id="RSA-VRF"><a href="#RSA-VRF" class="headerlink" title="RSA-VRF"></a>RSA-VRF</h1><p>基于RSA算法的VRF感觉和RSA算法的签名过程一样，只要生成的结果随机且可确认即可</p><p>如RSA算法一样，首先选取两个大素数$p$和$q$，$n=p \times q$，$n$作为进行运算的整数群$Z_n^*$的阶，生成元为$g$</p><p>将消息通过编码的方式映射到群上，如果消息编码后过大需要考虑其他的编码方式，编码映射后的消息为$m$</p><p>在VRF其实并不需要解密得到结果，所以对消息进行编码也可以通过哈希函数缩短输入，保证可以进行验证即可</p><p>生成者选取$e \in (1, \phi(n))$以及生成私钥$d = e^{-1} mod\ n$</p><p>计算$c=m^d\ mod \ n$即可得到随机数，验证方可以使用生成者的公钥进行验证，这里其实就是一个签名的过程</p><h1 id="ECC-VRF"><a href="#ECC-VRF" class="headerlink" title="ECC-VRF"></a>ECC-VRF</h1><p>基于椭圆加密算法的VRF的流程较为复杂，而且和椭圆加密的方法也有一定的差别</p><p>设选定的椭圆曲线的基点为$O$,阶为$n$，生成者选择$k \in [1,\ n-1]$作为私钥，计算公钥$Y=kO$</p><p>将消息映射到椭圆曲线上的一个点$M$，选取随机数$r\in[1, \ n-1]$，计算$rM， rO$</p><blockquote><p>这里映射的方式也是使用时自定义的映射方式，比如直接将消息编码后计算得到在曲线上点，在不需要解密结果的时候也可以直接进行哈希</p><p>我在自己的代码实现中直接哈希得到一个整数$x$，然后计算$y=xO$，得到曲线上的点，这里是拿ecdsa的包来进行改造</p><p><a href="https://github.com/Decision2016/python-ecdsa/blob/master/src/ecdsa/keys.py">https://github.com/Decision2016/python-ecdsa/blob/master/src/ecdsa/keys.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">number = _truncate_and_convert_digest(</span><br><span class="line">    digest,</span><br><span class="line">    self.curve,</span><br><span class="line">    allow_truncate</span><br><span class="line">)</span><br><span class="line">hashfunc = hashfunc <span class="keyword">or</span> self.default_hashfunc</span><br><span class="line"></span><br><span class="line">order = self.curve.order</span><br><span class="line">generator = self.curve.generator</span><br><span class="line"></span><br><span class="line">message_point: ecdsa.ellipticcurve.PointJacobi</span><br><span class="line">rH: ecdsa.ellipticcurve.PointJacobi</span><br><span class="line">rO: ecdsa.ellipticcurve.PointJacobi</span><br><span class="line">message_point = generator * number</span><br></pre></td></tr></table></figure></blockquote><p>将$rM、 rO$编码为整数$s$，然后计算$t = (r - s \times k) \ mod  \ n$,这里$t$和$s$是验证者用于验证随机数的证明参数</p><p>随机数通过计算$R = kM$，然后将$R$编码为整数（这里就存在一个问题，R在编码后会特别大，会增加网络传输负载，如果哈希后会导致验证方不能正常将数据恢复到曲线上）</p><p>验证方知道曲线参数，以及生成方的公钥$Y$,接收到随机数$V$、输入消息$m$，以及验证参数$s、t$后，将消息$m$以同样的方式映射到曲线上的点$M$</p><p>然后计算<br>$$<br>U_1 = tM\ + \ sV \<br>U_2 = tO\ + \ sY<br>$$<br>验证$s$是否等于将$U_1$和$U_2$进行编码后得到整数</p><p>如果消息没有被篡改， $U_1、U_2$和$rM、rO$是一一对应的：<br>$$<br>U_1 = tM\ +\ sV = (r - s\times k)M + skM = rM<br>$$</p><p>$$<br>U_2 = tO\ +\ SY = (r - s \times k)O + skO=rO<br>$$</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Pseudo%20Randomness/Verifiable_Random_Functions.pdf">Verifiable Random Functions PDF</a></p><p><a href="https://en.wikipedia.org/wiki/Verifiable_random_function">Verifiable Random Function - Wiki</a></p><p><a href="https://blog.csdn.net/jingzi123456789/article/details/107023051">可验证随机函数原理和应用浅析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;可验证随机函数(Verifiable Random Function)用于生</summary>
      
    
    
    
    <category term="Research" scheme="http://decision01.com/categories/Research/"/>
    
    
    <category term="blockchain" scheme="http://decision01.com/tags/blockchain/"/>
    
    <category term="cryptography" scheme="http://decision01.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>《Carving Orphaned JPEG File Fragments》阅读笔记</title>
    <link href="http://decision01.com/post/43168d0.html"/>
    <id>http://decision01.com/post/43168d0.html</id>
    <published>2021-11-09T07:58:48.000Z</published>
    <updated>2024-04-08T08:03:49.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>接前面JPEG编码解码的文章:<a href="https://decision01.cn/2021/03/20/JPEG%E7%BB%93%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/">JPEG结构及编码解码</a></p><p>许久之后的现在导师扔了篇论文来让我康康里面的技术有哪些地方比较新颖</p></div><p>在缺失元文件的磁盘中恢复数据存在的两个问题：</p><ul><li>无法在存储器中连续地展开文件数据</li><li>文件为了便于快速和轻量的存储，会被格式化地存储到二进制中</li></ul><h1 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>文件雕刻技术可以在缺失元数据的存储器中恢复文件，当数据被编码和压缩后，对文件的雕刻需要编码和压缩的相关信息（元数据）</p><p>文章检测了大量的JPEG图片头以识别它们的结构特征，并运用这一信息实现需要两个步骤的新技术。</p><ul><li><p>解压不完整的文件数据，以获得一个<strong>空间域的描述</strong></p></li><li><p>然后依据这个在空间域的数据中，还原得到一个感官上有意义的图像（即得到正常的图片）</p></li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>随着越来越多的数据的产生以及被存储到数不尽的设备中，对于在设备错误或遗失情况下的文件数据恢复技术的需求开始增长。所有的设备通过将文件打散为不通过的小块来存储到设备上，对于较为老式的存储设备，这一小块的大小为0.5Kb，而到最新的设备，大小会是64Kb。而在访问这些数据的时候需要根据元数据将这些块连成一个链表，以取得文件的数据。由此，对于一个文件的恢复存在的挑战（challenge）有：</p><ul><li>由于分块存储的原因，无法连续地展开文件数据用来进行恢复</li><li>数据会被进行编码、压缩到二进制中进行存储，以最大化的节省空间（压缩）</li></ul><p>碎片文件雕刻问题受到了人们的研究兴趣，并且具有一定数量的技术来进行解决。这些技术尝试在解码JPEG图像的同时识别出碎片点。在解码失败或者开始产生错误时候将对应的位置识别为一个碎片点，而这些技术通过多次合并新的数据块和已经识别的数据块来恢复和验证数据。但是目前最前沿的技术中，<strong>都默认文件头是存在的</strong>，如果一个文件是部分存在，但是文件头被删除了，现有的技术则不能对该文件进行恢复。</p><p>文章会指出恢复孤立的JPEG碎片的具有挑战性的问题，文章实现的最为根本的方法是为碎片文件重建一个文件头。JPEG图像通常是由数码相机创建，所以通过检查大量的Flick图像分享网站上的大量图片来获取得到编码信息。</p><ul><li>下一节中提供了基于该角度和所描述的挑战给出了恢复一个碎片文件头部的概述</li><li>在第三节中提供了在Flickr数据集中的发现以及它们如何用于重建文件头</li><li>第四节描述了文章提出的文件雕刻技术的每一步</li><li>最后一节通过实现的效果来总结该文章</li></ul><h2 id="Craving-Challengs"><a href="#Craving-Challengs" class="headerlink" title="Craving Challengs"></a>Craving Challengs</h2><p>JPEG标准定义了四个压缩模式：无损、基线（baseline）、渐进式、阶梯式。</p><p>在baseline模式中，通过从上到下扫描图像以顺序存储图像数据，并且这种模式需要在JPEG标准中作为一种基本的能力进行一致的实现。而与之相反的是，渐进式模式通过多次扫描来船速图像数据，阶梯模式允许图像在不同分辨率的机器上显示。而baseline模式是最为广泛被使用的压缩模式，该模式最为简单并且需要较少的计算资源。</p><p>JFIF定义了一种被称为YCbCr的用于编码色彩信息的标准色彩空间，Y（luminance）接近于图像的明度数据，CrCb则接近于图像的色度数据。</p><p>JPEG文件数据包含两类segments，标记段包含关于这个图像的基本信息，而数据段包含了图像的编码数据</p><p>所有的JPEG图像被作为一系列图像块进行存储，而这些图像块的大小具有8x8、8x16、16x8以及16x16像素四种，这样的最小图像块（MCU）中具有确定数量的来自于每个颜色组件的块。而在每个MCU中的颜色组件数量取决于在编码时的子采样过程。</p><p>设计一种自动雕刻孤立碎片的方式需要解决两个问题：</p><ul><li>碎片数据需要解压缩，而解压缩需要正确识别压缩方式、压缩参数和子采样配置。但是在删除文件中进行解码需要在一些任意的位开始解压缩数据流，而这样可能会导致和哈夫曼编码不一致。</li><li>另外一个需要克服的挑战是正确地渲染一部分图像数据，而这需要能够正确通过已经恢复的数据猜测缺失的参数例如宽度和量化表</li></ul><p><strong>很显然的是，解码文件碎片数据最为具有挑战性的是需要尝试大量可能的压缩设置。而最为起到决定性的是选取哈夫曼表。</strong>但是由于现有的图片可能被在相同的相机中进行裁剪，或者是被相同的图像编辑工具编辑，又或者是在相同的网站上下载。所有可以通过这些信息来猜测可能的编码信息，在检查了大量的图像后得到的信息可以用于进行这些参数的补充。</p><h2 id="JPEG-Encoding-Setting-Statistics"><a href="#JPEG-Encoding-Setting-Statistics" class="headerlink" title="JPEG Encoding Setting Statistics"></a>JPEG Encoding Setting Statistics</h2><p>为了实现可靠的对JPEG编码的统计，编写了一个来自Flickr所有数码相机和模型的图像的列表。为了保证编码能够反映图像捕获设备的设置，而不是由编辑工具重新编辑过的图像，对接口抓取的图像进行了过滤，最后得到767916张图像。而后面为了去掉通过编辑软件编辑的图像，又通过ExIF数据信息筛去了一部分图像，最后剩余460643张图像。</p><p>对图像检查后，有5963套哈夫曼表，而每一套哈夫曼表有四个不同的表用于编码亮度中的AC和DC，以及色度。然而有98.61%的图像的哈夫曼表是同一套，其他的5962套哈夫曼表用于编码其他的6425张图像。而类似得到信息还有 ：子采样方式、图像尺寸、Restart Markers、DCT表信息</p><h2 id="Fragment-Carver"><a href="#Fragment-Carver" class="headerlink" title="Fragment Carver"></a>Fragment Carver</h2><p>为了技术的通用性，考虑得到的图像碎片都没有头部数据或者任何的标记，例如开始或结束扫描标记，该技术的步骤如下：</p><ul><li>在只有部分的比特流中检测字节边界，用于区分被编码的图像数据</li><li>选取一套哈夫曼表用于解码，由于标准的哈夫曼表是较为常用的，所以目前仅考虑选取标准的哈夫曼表</li><li>通过选取的哈夫曼表用于三种可能的MCU结构，如果都不可行的话换下一个可能的比特位开始，直到能够成功解码</li><li>使用常见的DCT表对解码的MCU进行反量化，而这一步骤通过对图像块分析得到宽度</li></ul><h3 id="Decoding-the-Bitstream"><a href="#Decoding-the-Bitstream" class="headerlink" title="Decoding the Bitstream"></a>Decoding the Bitstream</h3><p>在任意一个比特位置开始解码需要两个条件：</p><ul><li>MCU的哪一个组件需要解码，这决定了使用哪一个哈夫曼表来解码</li><li>codeword的对齐</li></ul><p>字节边界查找：由于0xFF作为JPEG图像的第一个标识，在检查到该数据的时候，将其视为开始的标志。为了避免混乱，一个0xFF后面必须跟着0x00，这表明这个0x00是可以忽略的。</p><p>而0xFF01到0xFFCF以及0xFFD8到0xFFFF是不会出现在已编码的数据中的，所以这些字节出现的位置应该排除在字节边界外。</p><p>实现同步：一个解码器如果正确地从任意字节开始解码得到代码字（codeword），则被称为是同步成功的。而哈夫曼编码的自同步属性保证它的弹性较好，在添加、删除比特后也可以解码成功。所以如果比特流中存在错误的话，会导致在解码的数据不正确。而在Fig.7中展示了数据流的部分数据丢失后，解码得到的数据不正确的例子。</p><p>在任何的同步设置下，正确解码数据块的能力依赖于EOB标记的出现。在45w张图像数据中，8x8的数据块有94.11%是在EOB位置结束编码的。尽管EOB标准出现的频率比较高，但是对于解码器来说也可能在没有EOB标志的情况下进入同步。在这样的情况下，和可能解码器会解码到8x8的MCU溢出或者出现非法的代码字的情况下才会停止，这也意味着同步失败。</p><blockquote><p>这里其实也是之前挑战课上个做检测的一个想法：依照提取的哈夫曼表从文件头开始进行解码，如果遇到溢出以及非法的情况说明该处的比特流不正确。但是最重要的不能成功的原因就在于：哈夫曼表的容错性太高了，并不能完全的检测得到错误的边界。</p></blockquote><p>而由于这样的情况出现，解决的方法也就是丢掉当前解码的数据，重新建立同步直到遇到EOB标志。</p><h3 id="Identifying-the-MCU-Structure"><a href="#Identifying-the-MCU-Structure" class="headerlink" title="Identifying the MCU Structure"></a>Identifying the MCU Structure</h3><p>为了得到子采样方式，通过解码尝试三种结构来进行识别。这依赖于正确的子采样方式能够很快地进行同步，并且能够正确地恢复块的数据。</p><p>（待续）</p><h1 id="较为新颖的地方"><a href="#较为新颖的地方" class="headerlink" title="较为新颖的地方"></a>较为新颖的地方</h1><ul><li>在解码后根据MCU的亮度和颜色来对比上一个MCU的边界</li><li>使用不同的方式检测解码师范正确</li><li>检查图片宽度，保证能够恢复后正常显示</li></ul><h1 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h1><p><a href="https://www.researchgate.net/publication/275044127_Carving_Orphaned_JPEG_File_Fragments">Carving Orphaned JPEG File Fragments</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;接前面JPEG编码</summary>
      
    
    
    
    <category term="Research" scheme="http://decision01.com/categories/Research/"/>
    
    
    <category term="research" scheme="http://decision01.com/tags/research/"/>
    
    <category term="binary" scheme="http://decision01.com/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>WPF窗口置底</title>
    <link href="http://decision01.com/post/7bdd625.html"/>
    <id>http://decision01.com/post/7bdd625.html</id>
    <published>2021-10-07T07:43:13.000Z</published>
    <updated>2024-04-08T08:03:49.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>软工项目查许久资料才搞定，stackoverflow上的资料一直没说清楚花了不少时间 = =</p><p>借此水一篇博文，不过好像还需要实现一个让窗口不贴在桌面上的需求，但是这个把父窗口设置成Zero应该就行了</p></div><p>​    </p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>WPF中的应用场景：将窗口钉在桌面上，使用快捷键<code>Win+D</code>显示桌面时不会让窗口隐藏</p><p>在窗口类中引入dll，调用系统api用于查找句柄、设置句柄等操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定窗口的样式</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> UInt64 <span class="title">GetWindowLong</span>(<span class="params">IntPtr hWnd, <span class="built_in">int</span> nIndex</span>)</span>;</span><br><span class="line"><span class="comment">// 设置指定窗口的样式</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">SetWindowLong</span>(<span class="params">IntPtr hWnd, <span class="built_in">int</span> nIndex, UInt64 dwNewLong</span>)</span>;</span><br><span class="line"><span class="comment">// 获取桌面Desktop窗口的Handle</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetDesktopWindow</span>()</span>;</span><br><span class="line"><span class="comment">// 设置窗口的父窗口</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">SetParent</span>(<span class="params">IntPtr hWndChild, IntPtr hWndNewParent</span>)</span>;</span><br><span class="line"><span class="comment">// 查找窗口handle</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">FindWindow</span>(<span class="params"><span class="built_in">string</span> lpWindowClass, <span class="built_in">string</span> lpWindowName</span>)</span>;</span><br><span class="line"><span class="comment">// 查找窗口handle</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">FindWindowEx</span>(<span class="params">IntPtr parentHandle, IntPtr childAfter, <span class="built_in">string</span> className, <span class="built_in">string</span> windowTitle</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后通过窗口的特性来查找正确的桌面窗口</p><blockquote><p>桌面窗口的类名为<code>WorkerW</code>，但是根据这个类名会有重名的窗口，所以需要另外编写函数来进行查找</p><p>可以通过<a href="https://github.com/westoncampbell/SpyPlusPlus">Microsoft Spy++</a>来查看，正确的桌面窗口下至少有一个子窗口，其类名为<code>SHELLDLL_DefView</code></p></blockquote><p>查找正确桌面窗口句柄的函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntPtr <span class="title">SearchDesktopHandle</span>()</span> &#123;</span><br><span class="line">    IntPtr hRoot = GetDesktopWindow();</span><br><span class="line">    IntPtr hShellDll = IntPtr.Zero;</span><br><span class="line">    IntPtr hDesktop = FindWindowEx(hRoot, IntPtr.Zero, <span class="string">&quot;WorkerW&quot;</span>, String.Empty);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        hShellDll = FindWindowEx(hDesktop, IntPtr.Zero, <span class="string">&quot;SHELLDLL_DefView&quot;</span>, String.Empty);</span><br><span class="line">        <span class="keyword">if</span> (hShellDll != IntPtr.Zero) &#123;</span><br><span class="line">            <span class="keyword">return</span> hDesktop;</span><br><span class="line">        &#125;</span><br><span class="line">        hDesktop = FindWindowEx(hRoot, hDesktop, <span class="string">&quot;WorkerW&quot;</span>, String.Empty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IntPtr.Zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还需要把窗口添加一个<code>WS_CHILD</code>的属性，否则调用<code>SetParent</code>函数是没有任何用处的(<strong>注意：具有<code>WS_POPUP</code> 属性的窗口需要将其去掉，否则存在冲突</strong>)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> GWL_STYLE = (<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">const</span> UInt64 WS_CHILD = <span class="number">0x40000000</span>;</span><br><span class="line">IntPtr hWnd = <span class="keyword">new</span> WindowInteropHelper(<span class="keyword">this</span>).Handle;</span><br><span class="line">UInt64 iWindowStyle = GetWindowLong(hWnd, GWL_STYLE);</span><br><span class="line">SetWindowLong(hWnd, GWL_STYLE, (iWindowStyle| WS_CHILD));</span><br></pre></td></tr></table></figure><p>最后设置一下窗口的父窗口即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntPtr desktopHandle = SearchDesktopHandle();</span><br><span class="line">SetParent(hWnd, desktopHandle);</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span>&#123;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> UInt64 <span class="title">GetWindowLong</span>(<span class="params">IntPtr hWnd, <span class="built_in">int</span> nIndex</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">SetWindowLong</span>(<span class="params">IntPtr hWnd, <span class="built_in">int</span> nIndex, UInt64 dwNewLong</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetDesktopWindow</span>()</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">SetParent</span>(<span class="params">IntPtr hWndChild, IntPtr hWndNewParent</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">FindWindow</span>(<span class="params"><span class="built_in">string</span> lpWindowClass, <span class="built_in">string</span> lpWindowName</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">FindWindowEx</span>(<span class="params">IntPtr parentHandle, IntPtr childAfter, <span class="built_in">string</span> className, <span class="built_in">string</span> windowTitle</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntPtr <span class="title">SearchDesktopHandle</span>()</span> &#123;</span><br><span class="line">        IntPtr hRoot = GetDesktopWindow();</span><br><span class="line">        IntPtr hShellDll = IntPtr.Zero;</span><br><span class="line">        IntPtr hDesktop = FindWindowEx(hRoot, IntPtr.Zero, <span class="string">&quot;WorkerW&quot;</span>, String.Empty);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            hShellDll = FindWindowEx(hDesktop, IntPtr.Zero, <span class="string">&quot;SHELLDLL_DefView&quot;</span>, String.Empty);</span><br><span class="line">            <span class="keyword">if</span> (hShellDll != IntPtr.Zero) &#123;</span><br><span class="line">                <span class="keyword">return</span> hDesktop;</span><br><span class="line">            &#125;</span><br><span class="line">            hDesktop = FindWindowEx(hRoot, hDesktop, <span class="string">&quot;WorkerW&quot;</span>, String.Empty);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> IntPtr.Zero;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span> &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MainWindow_onLoaded</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> GWL_STYLE = (<span class="number">-16</span>);</span><br><span class="line">        <span class="keyword">const</span> UInt64 WS_CHILD = <span class="number">0x40000000</span>;</span><br><span class="line">        IntPtr hWnd = <span class="keyword">new</span> WindowInteropHelper(<span class="keyword">this</span>).Handle;</span><br><span class="line">        UInt64 iWindowStyle = GetWindowLong(hWnd, GWL_STYLE);</span><br><span class="line">        SetWindowLong(hWnd, GWL_STYLE, (iWindowStyle| WS_CHILD));</span><br><span class="line"></span><br><span class="line">        IntPtr desktopHandle = Utils.SearchDesktopHandle();</span><br><span class="line">        SetParent(hWnd, desktopHandle);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowlonga?redirectedfrom=MSDN">SetWindowLongA function (winuser.h)</a></p><p><a href="https://blog.csdn.net/clzdl/article/details/3378301">win32 修改窗口属性</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlonga">GetWindowLongA function (winuser.h)</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles">Window Styles</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;软工项目查许久资料</summary>
      
    
    
    
    <category term="Dev" scheme="http://decision01.com/categories/Dev/"/>
    
    
    <category term="c#" scheme="http://decision01.com/tags/c/"/>
    
    <category term="windows UI" scheme="http://decision01.com/tags/windows-UI/"/>
    
  </entry>
  
  <entry>
    <title>JPEG结构及编码解码</title>
    <link href="http://decision01.com/post/e407e7f0.html"/>
    <id>http://decision01.com/post/e407e7f0.html</id>
    <published>2021-03-20T09:07:28.000Z</published>
    <updated>2024-04-08T08:03:49.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>为什么会想到看这个东西呢，因为选了个数据恢复的课不得不了解一下（早知道就应该选水点的实验课了）</p><p>或许后面还会造个轮子玩玩吧。。</p></div><h1 id="JPEG文件格式"><a href="#JPEG文件格式" class="headerlink" title="JPEG文件格式"></a>JPEG文件格式</h1><p>JPEG文件通常以<code>FFD8</code>头部标识，以<code>FFD9</code>作为结束标识，在文件中以FF表示一个段的开头，后跟标识信息表示段的内容，再之后是两字节的数表示段的长度</p><p><img src="https://i.loli.net/2021/03/20/KFY4kLa7u1NBDpQ.png" alt="jpg段信息较为直观的展示，来源见参考文章"></p><h1 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h1><h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h2><p>大多数JPEG算法的实现使用<strong>亮度</strong>和<strong>色度</strong>（YUV编码）而非RGB编码，因为人眼很难观察到高频亮度在很小的区域中的变化。RGB使用3个字节来存储颜色信息，而YUV也使用3个字节来存储，但是每个字节表示的信息和RGB相比是不同的。图片的编码流程如下</p><p><img src="https://i.loli.net/2021/03/20/gvM7U1PpYEDZezr.png" alt="JPEG Encoding process"></p><h2 id="离散变换和量化"><a href="#离散变换和量化" class="headerlink" title="离散变换和量化"></a>离散变换和量化</h2><p>JPEG在处理图像之前将图片划分为8x8的小块来进行处理（这样的小块被称为最小编码单元），在处理的时候需要将像素值的范围进行修改，使得值的范围在$[-127, 128]$之间，未进行处理的范围在$[0, 255]$，使得像素值以0为中心，便于利用离散余弦变换。离散余弦变换把离散的数据变成多个余弦信号的组合。</p><h3 id="二维DCT变换"><a href="#二维DCT变换" class="headerlink" title="二维DCT变换"></a>二维DCT变换</h3><p>二维DCT的变换公式：<br>$$<br>F(u,v) = c(u)c(v)\sum_{i = 0}^{N - 1}\sum_{J = 0}^{N - 1}f(i, j)cos[\frac{(i + 0.5)\pi}{N}]cos[\frac{(j + 0.5)\pi}{N}]<br>$$<br>$$<br>c(x) =<br>\begin{cases}<br>\sqrt{\frac{1}{N}}, x = 0 \\<br>\sqrt{\frac{2}{N}}, x \neq 0 \\<br>\end{cases}<br>$$<br><del>看起来不太看得懂，但是主要注重怎么用就行了</del></p><p>将上面的式子改为矩阵的形式，令$U(i, j) = c(i)cos[\frac{(j + 0.5)\pi}{N}]$，则$F = UAU^T$，DCT矩阵$U$在8x8的方阵中如下<br>$$<br>U=\frac{1}{2}\begin{bmatrix}<br>\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\<br>cos\frac{\pi}{16} &amp; cos\frac{3\pi}{16} &amp; cos\frac{5\pi}{16} &amp; cos\frac{7\pi}{16} &amp; cos\frac{9\pi}{16} &amp; cos\frac{11\pi}{16} &amp; cos\frac{13\pi}{16} &amp; cos\frac{15\pi}{16} \\<br>cos\frac{2\pi}{16} &amp; cos\frac{6\pi}{16} &amp; cos\frac{10\pi}{16} &amp; cos\frac{14\pi}{16} &amp; cos\frac{18\pi}{16} &amp; cos\frac{22\pi}{16} &amp; cos\frac{26\pi}{16} &amp; cos\frac{30\pi}{16} \\<br>cos\frac{3\pi}{16} &amp; cos\frac{9\pi}{16} &amp; cos\frac{15\pi}{16} &amp; cos\frac{21\pi}{16} &amp; cos\frac{27\pi}{16} &amp; cos\frac{33\pi}{16} &amp; cos\frac{39\pi}{16} &amp; cos\frac{45\pi}{16} \\<br>cos\frac{4\pi}{16} &amp; cos\frac{12\pi}{16} &amp; cos\frac{20\pi}{16} &amp; cos\frac{28\pi}{16} &amp; cos\frac{36\pi}{16} &amp; cos\frac{44\pi}{16} &amp; cos\frac{52\pi}{16} &amp; cos\frac{60\pi}{16} \\<br>cos\frac{5\pi}{16} &amp; cos\frac{15\pi}{16} &amp; cos\frac{25\pi}{16} &amp; cos\frac{35\pi}{16} &amp; cos\frac{45\pi}{16} &amp; cos\frac{55\pi}{16} &amp; cos\frac{65\pi}{16} &amp; cos\frac{75\pi}{16} \\<br>cos\frac{6\pi}{16} &amp; cos\frac{18\pi}{16} &amp; cos\frac{30\pi}{16} &amp; cos\frac{42\pi}{16} &amp; cos\frac{54\pi}{16} &amp; cos\frac{66\pi}{16} &amp; cos\frac{78\pi}{16} &amp; cos\frac{90\pi}{16} \\<br>cos\frac{7\pi}{16} &amp; cos\frac{21\pi}{16} &amp; cos\frac{35\pi}{16} &amp; cos\frac{49\pi}{16} &amp; cos\frac{63\pi}{16} &amp; cos\frac{77\pi}{16} &amp; cos\frac{91\pi}{16} &amp; cos\frac{105\pi}{16} \\<br>\end{bmatrix}<br>$$</p><p>通过该矩阵进行相乘即可得到进行DCT处理后的信息矩阵</p><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>在得到DCT矩阵后通过量化表来进行量化，量化的过程很简单，通常是根据压缩的精细度使用不同的量化表，DCT矩阵和量化表矩阵中对应位置的值进行相处得到量化后的矩阵。</p><h2 id="编码-amp-压缩"><a href="#编码-amp-压缩" class="headerlink" title="编码&amp;压缩"></a>编码&amp;压缩</h2><h3 id="Zig-Zag"><a href="#Zig-Zag" class="headerlink" title="Zig-Zag"></a>Zig-Zag</h3><p>在量化完成之后，高频的位置的矩阵信息通常就变成0了，所以为了方便压缩，通过Z形扫描，将这些为0的值连到一起</p><p>例如：<br>$$<br>\begin{bmatrix}<br>15 &amp; 14 &amp; 10 &amp; 9 \\<br>13 &amp; 11 &amp; 8 &amp; 0  \\<br>12 &amp; 0 &amp; 0 &amp; 0   \\<br>0 &amp; 0 &amp; 0 &amp; 0<br>\end{bmatrix}<br>$$<br>在经过扫描后，变成了<br>$$<br>\begin{bmatrix}<br>15 &amp; 14 &amp; 13 &amp; 12 &amp;11 &amp; 10 &amp; 9 &amp; 8 &amp;0 &amp; …… &amp; 0<br>\end{bmatrix}<br>$$</p><h3 id="行程编码和增量编码"><a href="#行程编码和增量编码" class="headerlink" title="行程编码和增量编码"></a>行程编码和增量编码</h3><p>行程编码其实是一种较为容易想出来的压缩编码方式（突然想起来这个好像以前听卡常狂魔wys讲过orz）</p><p>行程编码简单来说就是统计当前信息连续出现多少次，并且记录次数<br>$$<br>\begin{bmatrix}<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0<br>\end{bmatrix}<br>$$<br>在进行编码后就是<br>$$<br>\begin{bmatrix}<br>0 &amp; 8<br>\end{bmatrix}<br>$$<br>没记错的话那个时候听讲座还提到过这个压缩方式被哪家压缩软件的软件公司给申请了专利（？</p><p>然后增量编码是通过与之前的字节进行比较增量变换进行编码的方式</p><p>$$<br>\begin{bmatrix}<br>10 &amp; 11 &amp; 12 &amp; 13 &amp; 10 &amp; 9<br>\end{bmatrix}<br>$$</p><p>在经过编码之后就是<br>$$<br>\begin{bmatrix}<br>10 &amp; 1 &amp; 2 &amp; 3 &amp; 0 &amp; -1<br>\end{bmatrix}<br>$$<br>在JPEG中，DCT系数矩阵中的值都相对于前面的DCT表中的DC值进行了增量编码，这样可以让后面的DC值都能够靠近0，便于后续进行哈夫曼编码。所以如果修改图像的第一个DC系数会导致整个图片发送很大的变动，而修改靠后的DC系数引起的变化比较小。</p><blockquote><p>In JPEG, every DC value in a DCT coefficient matrix is delta encoded relative to the DC value preceding it. This means that if you change the very first DCT coefficient of your image, the whole image will get screwed up but if you modify the first value of the last DCT matrix, only a very tiny part of your image will be affected. This is useful because the first DC value in your image is usually the most varied and by applying the Delta encoding we bring the rest of DC values close to 0 and that results in better compression in the next step of Huffman Encoding.</p><p>​                                                                                        ——《Understanding and Decoding a JPEG Image using Python》</p></blockquote><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>哈夫曼编码的实现这里不细说，JPEG里面通过哈夫曼编码压缩的方式将信息进一步压缩</p><p>在经过DCT变换以及量化后得到的DCT系数矩阵中，第一个数为DC系数，其他的63个为AC系数</p><p>对于亮度和色度需要进行不同的编码，而对应AC系数和DC系数也有不同的编码，所以一般来说一个彩色的JPEG图像中存在4个哈夫曼表</p><p>写一下哈夫曼表在JPEG中的存储形式，随便选了一张图片，哈夫曼表段如下</p><p><img src="https://i.loli.net/2021/03/20/e3QjxO1Eu9VoHfP.png" alt="image-20210320165408508"></p><p>选取中间比较长的一段来进行说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Offset      0  1  2  3  4  5  6  7   8  9 10 11 12 13 14 15</span><br><span class="line"></span><br><span class="line">00000192                                                 FF                  </span><br><span class="line">00000208   C4 00 4B 10 00 02 02 01  03 02 03 06 04 02 07 06   ?K             </span><br><span class="line">00000224   05 03 01 09 00 01 02 11  03 04 12 21 05 31 13 41              ! 1 A</span><br><span class="line">00000240   51 06 22 61 71 81 91 07  14 32 42 52 A1 15 23 43   Q &quot;aq ? 2BR?#C</span><br><span class="line">00000256   B1 C1 D1 E1 33 44 62 72  82 92 16 24 34 53 F1 63   绷厌3Dbr倰 $4S馽</span><br><span class="line">00000272   83 F0 17 93 A2 25 73 C2  E2 45 54 55               凁 摙%s骡ETU</span><br></pre></td></tr></table></figure><p><code>FF C4</code>表示哈夫曼表的开始，<code>00 4B</code>表示长度，随后跟的<code>10</code>表示类型，属于AC表的0号表</p><blockquote><p>哈夫曼表的表类型：</p><p>高4位标识表示该表是AC交流表还是DC直流表，0表示DC，1表示AC</p><p>低4位标识表示该表是0号表还是一号表</p></blockquote><p>主要看深蓝色部分和绿色部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 02 02 01 03 02 03 06 04 02 07 06 05 03 01 09</span><br></pre></td></tr></table></figure><p>每个字节表示对应位数的码字的数量，例如位数为2、3、6、10的码字都有2个，而位数为3、16的码字都有1个等等，总的加起来就算后面剩余部分的长度（哈夫曼树的叶子节点的个数）</p><p>剩余部分根据码字长度表来依次建立，得到哈夫曼编码表，这里写前面一小部分</p><table><thead><tr><th>序号</th><th>码字长度</th><th>码字</th><th>值</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>00</td><td>0x00</td></tr><tr><td>2</td><td>2</td><td>01</td><td>0x01</td></tr><tr><td>3</td><td>3</td><td>100</td><td>0x02</td></tr><tr><td>4</td><td>3</td><td>101</td><td>0x11</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><p>中间码字缺失的，在当前码字加1后，补0到最后进行补足</p><h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><p>(咕咕咕)</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://yasoob.me/posts/understanding-and-writing-jpeg-decoder-in-python/#introduction">Understanding and Decoding a JPEG Image using Python</a></p><p><a href="https://blog.csdn.net/nemoyy/article/details/80896449">理解JPEG图像压缩算法,DCT变换</a></p><p><a href="https://koushtav.me/jpeg/tutorial/c++/decoder/2019/03/02/lets-write-a-simple-jpeg-library-part-2/#define-huffman-table-segment-dht">Let’s Write a Simple JPEG Library, Part-II: The Decoder</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;为什么会想到看这个</summary>
      
    
    
    
    <category term="Wiki" scheme="http://decision01.com/categories/Wiki/"/>
    
    
    <category term="bin" scheme="http://decision01.com/tags/bin/"/>
    
  </entry>
  
  <entry>
    <title>来点mysql—索引</title>
    <link href="http://decision01.com/post/3399997e.html"/>
    <id>http://decision01.com/post/3399997e.html</id>
    <published>2021-03-13T10:59:10.000Z</published>
    <updated>2024-04-08T08:03:49.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><ul><li>本篇博文记录学习mysql的一些笔记（学习数据库+准备面试</li><li>较为抽象的地方不会有很细地记录，可能存在理解不是很精确的地方</li><li>然后之前虽然用过数据库但是sql语句也不太会，还是必须要学的（</li></ul></div>    <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引（是Mysql中也叫做键）是存储引擎中用于快速找到记录的一种数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT first_name FROM sakila.actor WHERE actor_id = 5;</span><br></pre></td></tr></table></figure><p>该语句用于在<code>actor_id</code>列上建立的索引查找值为5的行，然后返回所有包含该值的数据行</p><p>索引分为<strong>单索引</strong>和<strong>组合索引</strong>，单列索引中一个索引只包含一个列，而组合索引中一个索引可以包含多个列（在多个列中创建的单索引并不能提高查询性能）</p><blockquote><p>索引提高了查询速度，但是会降低更新表的速度，因为在更新表的时候也需要对索引文件进行更新</p></blockquote><p>在创建了索引之后，查询会根据语句情况选择使用索引以提高查询效率，快速定位数据，不用扫描表中给定查询的每一行</p><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>M阶的B树，每个节点最多有M个子节点，非叶子节点具有至少$ceil(m/2)$个子节点</p><p>B树的根节点拥有的子节点数量和上限的内部节点相同，如果根节点不是唯一节点，至少有两个子节点</p><p>于是有B树的节点特征：</p><ul><li>$2\le Count_{root}\le M$</li><li>$ceil(M/2) \le Count_{internal} \le M$</li><li>$1\le Count_{Ele_{root}} \le M-1$</li><li>$(ceil(M/2) - 1) \le Count_{Ele_{noroot}} \le M -1$</li></ul><p>B树在进行数据插入、删除的过程中依次检查是否满足条件，自动调整指向子页的指针和指向下一个叶子页的指针来实现树的平衡</p><p>B树索引存在的限制：</p><ul><li>如果不是按照索引的最左列查找，则无法使用索引</li><li>不能跳过索引中的列</li><li>如果查询中有某个列的范围查询，则右边所有列都无法使用索引优化查找</li></ul><h1 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h1><p>哈希索引基于哈希表来实现，只有精确匹配索引中所有列的查询才有效，对于每行数据记录一个哈希码</p><p>哈希索引的查找方式比较快，但是存在限制：</p><ul><li>哈希索引只包含哈希值和行指针，不存储字段值，不能使用索引中的值来避免读取行</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序</li><li>不支持索引匹配查找</li><li>只能支持等值比较查找</li></ul><p>创建自定义哈希索引：在B树的基础上创建一个伪哈希索引，使用哈希值而不是<strong>键本身</strong>来进行索引查找，需要在WHERE子句中使用哈希函数得到对应的哈希值</p><h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>在查询的列不是独立的列的情况下，Mysql就不会使用索引来进行查询，其次索引列不能是表达式的一部分或函数的参数</p><p><a href="https://leetcode-cn.com/problems/big-countries/">Leetcode-0595 大的国家</a></p><p>在这里，对于单列来说，使用OR没有任何的问题，但在涉及到多个列的情况下，如果选择了某个列属性之后，就会对另外一个进行全扫描。简单来说，在InnoDB中使用OR会导致索引失效。</p><p>而索引列不能是表达式的一部分，如下的sql语句无法正常解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure><p>在使用中应该养成简化WHERE条件的习惯：将索引列单独放在比较符号的一侧</p><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>需要索引过长的字符串的情况下，会让索引变得大且慢</p><p>在这一情况下可以索引开始的一部分字符，大大节约索引空间，但是也会降低索引的选择性（不重复的索引值和数据表的记录总数比值）</p><p>而对于BLOB、TEXT、VARCHAR类型的列必须使用前缀索引，Mysql不允许索引这些列的完整长度</p><p>前缀索引的诀窍在于要选择足够长的前缀以保证较高的选择性，但是又不能太长（便于节省空间），前缀应该保证选择性接近索引整个列</p><blockquote><p>决定最适合的前缀长度的方法：</p><p>找到最常见的值的列表，然后和最常见的前缀列表进行比较</p><p>逐渐增加前缀的长度，使得前缀的选择性接近完整列的选择性</p></blockquote><p>假设通过查找得到了最适合的前缀长度，可以添加前缀索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE TABLE_NAME ADD KEY (COLUMN_NAME(PRE_LENGTH));</span><br></pre></td></tr></table></figure><p>ps. mysql无法使用前缀索引做<code>ORDER BY</code>和<code>GROUP BY</code>，也无法做业务覆盖扫描</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在Mysql5.0和更新版本中引入了”索引合并“的策略，一定程度上可以使用表上的多个单列索引来定位指定的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2 FROM table Where col1 = &quot;test1&quot; OR col2 = &quot;test2&quot;; </span><br></pre></td></tr></table></figure><p>该条语句会使用全表查询，而不会使用索引，需要改写为<code>UNION</code>的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2 FROM table WHERE col1 = &quot;test1&quot; </span><br><span class="line">UNION ALL</span><br><span class="line">SELECT col1, col2 FROM table WHERE col2 = &quot;test2&quot;</span><br><span class="line">AND col2 &lt;&gt; 1;</span><br></pre></td></tr></table></figure><p>而在Mysql5.0和更新版本中，可以同时使用两个单列索引进行扫描，并且将结果进行合并，其算法有三个变种：<code>OR</code>条件的联合，<code>AND</code>条件的相交以及结合两种情况的联合及相交</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;ul&gt;
&lt;li&gt;本篇博</summary>
      
    
    
    
    <category term="Wiki" scheme="http://decision01.com/categories/Wiki/"/>
    
    
    <category term="database" scheme="http://decision01.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>2021腾讯暑期实习面经</title>
    <link href="http://decision01.com/post/d2fa7978.html"/>
    <id>http://decision01.com/post/d2fa7978.html</id>
    <published>2021-03-12T08:21:25.000Z</published>
    <updated>2024-04-08T08:03:49.037Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="TEG-一二面"><a href="#TEG-一二面" class="headerlink" title="TEG 一二面"></a>TEG 一二面</h1><h2 id="一面-2021-03-12"><a href="#一面-2021-03-12" class="headerlink" title="一面 2021.03.12"></a>一面 2021.03.12</h2><p>3.10的上午接到第一次电话，但是在上课就挂了，打回去结果是AI</p><p>3.11下午还在摸鱼，然后又打过来了，问第二天下午3点有没有时间，然后冲了（</p><p>头一天接到电话没有问是什么部门的，面试开始的时候面试官自己介绍了一下是TEG的（我怎么还被广州捞了啊</p><p>首先是自我介绍</p><p>结束了之后开始问项目（整个面试过程都在问项目，一点算法都没问），项目是寒假赶工赶出来的<a href="https://github.com/Decision2016/TICBackend">俱乐部Web</a></p><ul><li>Web程序有用户鉴权吗（有，但是只针对管理员）</li><li>你的这个项目使用了Django，那么你知道Django的用户鉴权是怎么实现的你清楚吗（不清楚，没来得及看过）</li><li>怎么存储的用户信息，例如密码，怎么保证安全性，如果让你来设计保存，会怎么进行保存（哈希，加盐）</li><li>加盐的话使用的字符串都是同一个吗（在我构想的加盐方案中是这样）</li><li>加盐是为了防止什么（防止暴力跑彩虹表之类的）</li><li>你的项目里还使用了RSA，主要是用来干什么？（登录认证，balabalabala）</li><li>你使用公钥对用户信息进行加密，但是中间人截取不是也可以用来进行登录（不能，用户一旦登录成功服务器会销毁记录）</li><li>项目用的什么数据库（Postgresql）</li><li>以前用过什么数据库（mysql）</li><li>那我给你一个场景，你写一下sql语句（中间被我打断了，直接说自己对sql语句不熟悉，主要用的是Django里面封装的模型）</li><li>那么你对数据库比较深刻的是些什么（最近看的书里面，才看了三章，随便说了一下四种隔离和MVVC）</li><li>ACID是什么，有了解吗（说了原子性、隔离性、一致性，然后一时忘了持久性）</li><li>说一下你使用的谷歌验证码是什么吧，还有你知道这个东西是什么吗（挑战应答，HMAC）</li><li>你们这个项目会有部署的过程吧，有没有自己进行部署（有，用docker搞了三个容器）</li><li>那么你的代码怎么传到服务器上（scp）</li><li>这里面还有爬虫是吧，能说一下使用爬虫的过程中遇到的困难吗（微信文章反爬，只能selenium渲染抓取，图片使用正则表达式获得链接进行下载保存）</li><li>你使用爬虫应该需要使用到浏览器内核吧，能说一下怎么把他放到容器里面吗（构建镜像的时候直接复制到对应位置）</li><li>三个容器怎么进行通信（使用选项进行连接，但是我忘了是啥选项（<code>docker-compose.yml</code>中的<code>links</code>））</li></ul><p>结束这部分之后问了我线程和进程的区别是什么（经 典 老 问），顺便问了下我觉得容器里面跑的后端是单进程还是多进程（我觉得是单进程）</p><p>然后到了下一个项目，是课设写的文件传输的东西（<a href="https://github.com/Decision2016/Camel-Server">Camel-Server</a>），顺着就开始问计网了</p><ul><li>你能描述一下TCP的结束过程吗（四次挥手）</li><li>那么在挥手过程中会有一方timeout状态，你知道是哪一方吗（不知道）</li><li>说一下tcp和udp的区别（可靠和不可靠，是否建立连接）</li><li>什么情况下需要udp（视频传输服务，实时视频，例如我们现在这样）</li><li>你知道HTTP协议吗，还有HTTPS协议</li><li>经常使用的HTTP协议中的类型是哪些（POST\GET）</li><li>你有熟悉的HTTP头部中的键值对吗（没有）</li><li>能不能简单说一下HTTPS的实现（主要说了没有ssl证书的版本）</li><li>既然用户已经有了服务器的公钥为什么还要发送自己的公钥（因为服务器报文也需要加密（猜的），这里正要说证书版本的被打断了）</li><li>为什么需要证书（防止中间人进行攻击）</li><li>能不能说一下你第一个项目里面可能存在的风险问题（可能存在中间人攻击，但是需要保证一开始进行劫持，否则截获了登录信息也不能用于第二次的登录）</li><li>比如你现在是在宿舍，那么你觉得使用HTTPS协议的情况下，你觉得你们学校的网络管理员能够看到哪些信息（GET请求的url连接中携带的参数信息，其他的不太清楚）</li></ul><p>小程序的项目问了一下我负责做了些什么，但是没有进行深入的问，问了一下有没有使用第三方服务器</p><p>然后开始问安全方面的问题，看到了专业（可是我网安技术真的不行）</p><ul><li>有没有学习过一些网络攻击的技术，例入注入之类的（学过，但是不是特别清楚）</li><li>知不知道sql注入，简单说一下它的原理（没有进行字符串的校验直接放入sql导致的）</li><li>怎么防止sql注入（不太清楚，但是我觉得可以通过屏蔽一些语句符号来达到目的，例入#号）</li><li>但是例如你们填写的表格，就是需要填入#号，这种情况下怎么防止（不清楚）</li></ul><p>结束，等看有没有二面通知了，我自己觉得挺慌的，然后最后觉得也还行，就是不知道面试官对我的印象咋样了（</p><p>说起来写了四个项目但是参加比赛的项目没有问，估计是面试官也不太懂区块链的东西吧hhhhh</p><p>已经尽量回忆了，如果还有忘了没写的会补充×</p><h2 id="二面-2021-03-15"><a href="#二面-2021-03-15" class="headerlink" title="二面 2021.03.15"></a>二面 2021.03.15</h2><p>还是首先自我介绍</p><p>然后问了最近有没有做过什么web项目，然后就说了俱乐部的网站</p><p>面试官问是不是部署了，然后扔了链接过去</p><p>过了一会问是不是纯展示页面，没有登录鉴权之类的（有，只有后台）</p><ul><li>怎么实现的（不清楚，这几天没有查到相关资料，但是大致知道是通过cookies之类的东西来实现）</li><li>用的什么数据库（postgresql）</li><li>有没有了解过mysql（有，最近在看《高性能mysql》）</li><li>那么目前的收获是什么（了解了索引，以及前面一些调试的东西但是没有来得及实现）</li><li>讲一下索引吧，以及一些应用的场景（应用的场景不太清楚，但是知道它的实现，balabalabala）</li><li>那么现在给定一个场景，要实现秒杀功能应该要怎么实现（口胡了加锁之类的，但是实在不知道具体实现啊）</li><li>换一个问法，你觉得需要考虑一些什么（高并发，登录的有效，安全性）</li><li>这几个点应该怎么实现（口胡了一堆，然后忘记怎么说的了）</li><li>对于高并发怎么处理（没怎么接触过，但是我觉得可能需要使用分布式的服务器之类的？）</li><li>有没有了解过一些Web的攻击（sql注入，xss）</li><li>那么对这两种的防范怎么做（sql实在不清楚，xss主要是检查用户输入）</li><li>怎么检查用户输入（不会）</li><li>sql注入的原理知道吗（知道，balabalabala）</li></ul><p>问完高并发就结束了，中间好像也没有问什么问题</p><ul><li>你这边最早什么时候可以过来</li><li>大概能实习多久</li><li>技术栈是go，看你主要使用c++，排斥吗（不排斥，能学）</li><li>有什么需要问我的吗</li></ul><p>然后问了部门是做什么的、自己这次表现怎么样、部门对算法的要求高不高</p><p>之前看到面试邮件里面写了会考察代码能力，然后看了一堆算法，结果一直都是问项目，<del>自己像个小丑</del>（不过也还好）</p><p>最后二面凉了，被wxg捞了，不知道能不能顺利一点（</p><h1 id="WXG"><a href="#WXG" class="headerlink" title="WXG"></a>WXG</h1><h2 id="一面-2021-03-19"><a href="#一面-2021-03-19" class="headerlink" title="一面 2021.03.19"></a>一面 2021.03.19</h2><p>这次没开视频，然后我还问了一下需不需要开视频（</p><p>常规自我介绍。。。</p><p>然后让我讲一下最近的项目（内心：？我不是都写到简历里面了吗</p><p>接着讲了一下俱乐部的展示网站</p><ul><li>你这里面用了爬虫，能说一下怎么做的吗（说了一下selenium但是面试官没听清楚，我确实也念不清楚，就说了是python里面一个控制浏览器内核的包</li><li>你们这个为什么还需要爬取文章啊（答了一下因为俱乐部的活动原因，顺便还聊了一下腾讯俱乐部主要平常干啥。。</li><li>我看你的登录操作用了RSA，你知道RSA是怎么实现的吗（是非对称加密，反问了一下我需不需要讲完整的原理</li><li>这样吧，你告诉我它主要是基于什么问题来实现的（大整数难分解问题</li><li>你们网站的密码是怎么存储的（用了Django中的默认方法，应该是哈希+加盐的方法</li><li>你这个怎么保证的安全性，能说一下吗（公钥加密给服务器</li><li>但是服务器还是能知道用户的口令啊（这个没有考虑过，只考虑了不被第三方拦截</li><li>讲一下你上面这个区块链的项目吧（内心：？合着那边有简历还需要我来自己讲，然后随便讲了一下</li><li>那么这个存储的用处是什么（保证时间戳是正确的没有被篡改啊</li><li>你们这个是用什么语言（前端vue.js，后端Java</li><li>Java里面有一个反射的概念，知道吗（后端不是我写的，平常使用C++，所以不太清楚</li><li>我看你可能接触前端比较多，能说一下HTTP和HTTPS的区别吗（一个加密一个非加密</li><li>那么HTTPS使用的是非对称还是对称（讲了非对称，然后面试官说不对，是使用非对称协商密钥然后使用对称密钥传输</li><li>协商认证是用了什么来实现清楚吗（证书</li><li>能讲一下证书的实现原理吗（讲不清楚，说了一下是客户端进行处理之后传给第三方进行验证</li><li>每一次都需要第三方验证？（不太清楚，面试官说本地会存储证书</li></ul><p>这里记忆可能比较乱，在中间还问了数据库的</p><ul><li>了解mysql吗（了解一点点</li><li>说一下事务型数据库的特性吧（ACID</li><li>现在给100亿条数据，怎么进行查询（这种情况需要建立索引吧</li><li>能讲一下有索引的数据结构吗（B树或者B+树</li><li>那么我们能不能通过哈希来进行查询（有哈希索引</li><li>现在通过哈希索引来进行范围查找，怎么实现（？哈希索引还能范围查找的，可以使用B+树和哈希索引进行组合索引吧</li></ul><p>这里面试官的意思是说不同的索引方式有一定的优缺点，哈希索引的缺点在于不能进行范围查询</p><ul><li>那么为什么不通过别的一些数据结构比如说数组来进行索引（太占用内存了，使用B+树的分页方式可以通过文件IO来进行数据的查找</li></ul><p>然后是C++的部分</p><ul><li>能说一下C++的特性吗（继承、封装、多态</li><li>多态是怎么实现的（使用虚表来进行实现，balabalabala</li><li>你提到了虚函数表，能讲一下虚函数表吗（然后又随便讲了一些虚函数表</li><li>虚函数表里面的函数指针是什么时候定下来的（编译的时候根据虚函数的声明顺序确定</li><li>在C++里面是每个对象有一个虚表还是每个类有一个虚表（<strong>即答：每一个对象</strong></li></ul><p>这里的表达有错了，其实想说的应该是每个对象有一个指向对应的类的虚表指针，然后面试官一直问我函数不是和对象没关系吗，搅了一会我才发现我表达的意思错了，虚表是每个类一份，但是每个对象指向其对应类的虚表</p><p>然后这个时候有另外两个面试官进来了，但是也没问问题就只是看着（慌得一笔</p><ul><li>你用的C++比较多，那么知道智能指针吗（浅显的聊了一些</li><li>C++11里面的move知道吗（不了解</li><li>除了这个你还知道哪些其他的新特性（lambda表达式和遍历方法</li><li>所以其实你对新的特性了解得不是很多对吧（是的，没怎么用到新特性</li></ul><p>大概就是这样，然后让我打开屏幕共享写题（草，终于有一次写代码的面试了？</p><ul><li>写一下最大公约数怎么求吧（用递归很快就写完了，啪的一下，很快啊</li><li>但是我的输入不保证大小怎么办（好说，再套一个函数</li><li>我现在有一个100级的台阶，每次可以走1阶或者2阶，怎么做（啪的一下一个动态规划也出来了啊，想了一下是不是可以用矩阵快速幂，然后当时有点慌了没有把正确的矩阵写出来，就觉得好像是没法优化的</li><li>那么如果有n阶的话，怎么办（100变成n，优化了一下空间，cnmd我怎么还是没有想到这个就是斐波拉契数列可以矩阵快速幂优化</li><li>如果n特别大的情况下怎么做（如果是超过long long表示范围的话需要取模，但是后面下来我才想起来面试官应该是想让我优化时间复杂度</li><li>现在有一个字符串，只有字母和空格，求一下最后一个单词的长度（用了一个标识然后遍历写完了</li><li>解释一下代码</li></ul><p>最后还是经典环节，有没有什么需要反问的，没什么问的就只好问这个岗位是干什么的了，听了面试官的说明后还反问了一下是不是对数据库和分布式要求比较高</p><p><del>许愿二面（</del></p><p>好了又挂了，果然是我太菜了cnm</p><h1 id="企业微信"><a href="#企业微信" class="headerlink" title="企业微信"></a>企业微信</h1><h2 id="一面-2021-03-26"><a href="#一面-2021-03-26" class="headerlink" title="一面 2021.03.26"></a>一面 2021.03.26</h2><p>首先自我介绍</p><p>一上来就给了一个小时写四个题：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/"> 二叉树的层序遍历 II</a>、<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a>、<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></p><p>最后一个是给定一个rand5的函数，通过这个函数得到rand3和rand7</p><p>前两个没什么太大的问题，第三个用优先队列水过去了，但是面试官说考虑一下只用队列能不能实现，当时没有想到双向队列，然后就没优化出来</p><p>最后一个算是脑筋急转弯吧，当时也没转出来，之前水群的时候看到hrdg面试有个类似的题目但是当时查了一下就忘了怎么做</p><p>做法就是使用两个rand5，算一下$(rand5() - 1) * 5 + rand5()$，然后不在范围内的就扔了，直到找到为止</p><p>然后那边有点吵，面试官提示了几次也没有听清楚，就直接开始问一些基础问题了</p><ul><li>C++里面有new函数，那么new和mallco的区别是什么（一个会构造，一个不会构造）</li><li>那么mallco开辟内存空间是在内核的哪个位置（当时想和new应该是不一样的，就猜了一个栈，实际上两个都是在堆上面申请的</li><li>有没有接触过一些高并发的应用场景（没有，内心：我平常我怎么接触到高并发场景啊。。</li><li>线程和进程的区别是什么</li><li>多线程之间进行同步的方式知道吗（互斥，加锁，通信管道</li><li>有没有用过hashmap这种结构（说在C++里面用过unordered_map和map，然后面试官提示前者实际上就是hashmap实现的</li><li>它们两者有什么区别（前面的是hashmap，后面的是红黑树</li><li>那么hashmap怎么解决冲突问题（还好前面看过一点，在冲突的时候建立类似于链表的结构</li><li>你简历里面写到了TCP，能说一下TCP和UDP的区别吗</li><li>那么能讲一下TCP和UDP的应用场景吗</li><li>TCP既然实现可靠传输，那么知道怎么实现的吗（快速重传、ACK序号，这里其实是口胡的（（（（</li><li>能讲一下拥塞控制算法吗（具体算法名记不清了，把实现的流程讲了一遍</li><li>那么拥塞控制和流量控制的区别是什么（拥塞控制查找最大的发送窗口能有多大，而流量控制只是通过发送窗口进行控制</li><li>看你写了SSL，知道SSH协议吗（不太清楚，只是我项目用了OpenSSL进行RSA、AES加密</li><li>那么讲一下对称和非对称加密的区别</li><li>能说一下它们的安全性有什么区别吗（安全性我觉得没有什么区别吧，主要是加密效率的问题</li><li>那换个问法，它们的效率有什么区别（内心：这能叫换一个问法吗。。。。（非对称因为要进行多次乘法运算所以效率对称低</li></ul><p>前面问的好像差不多这些，然后都差不多结束了，让我反问，就问这次面试有什么不足吗</p><p>面试官说最好补一补数据结构算法（听到这句我觉得我半截入土了，前面那些题确实一时没想起来优化方法），然后接触一些高并发的实现，然后到这里又问我接触过socket的东西</p><p>我说接触过，在项目里面用过，然后问了一个什么算法没听过，因为当时只是注重于应用</p><ul><li>那么socket编程有哪些主要的api（创建结构体的构造、bind、listen和客户端的connect，然后关闭ACK延迟等待还有一个函数记不清了（（（（（（草，忘了说accept和send</li><li>能讲一下TCP连接建立过程吗（就讲三次握手对嘛？</li><li>那么连接断开呢？（四次挥手吗？需要讲一下具体过程吗？</li><li>讲一下挥手过程吧（balabalabala，最后等待2MSL</li><li>为什么要等待2MSL（等待的时间没有收到多余的数据包就默认服务端收到了，所以关闭</li><li>就是一个TIME-WAIT的过程对吧（嗯，对</li></ul><p>然后到这里才结束了，其他也没有什么问题能问面试官（因为才一面问人家做啥的有什么用啊呜呜呜呜呜</p><h2 id="二面-2021-03-29"><a href="#二面-2021-03-29" class="headerlink" title="二面 2021.03.29"></a>二面 2021.03.29</h2><p>在马原第一节课接到的电话，然后看到是广州打过来的，有点奇怪，这里还是后面复盘才想清楚的</p><blockquote><p>在三面结束之后和群友们水群的时候学长说leader都是在广州，所以面试是广州那边的电话很正常</p><p>所以说其实后面这两次面试都是企业微信的，只是官问的状态和实际的面试状态没有同步而已。。</p></blockquote><p>打电话过来说是约代码复试，然后觉得有点奇怪我不是上次被WXG挂了吗，但是也没有详细问</p><p>到了下午还没发面试链接，然后傍晚6点过才又打电话问我有没有收到链接。。。</p><p>然后19：30进了面呗，等了10多分钟面试官一直没说话，还在群里吐槽了一下说腾讯的面试官还真守时间</p><p>实在觉得奇怪然后点了一下面呗里面的代码测试。。原来就是选了题等我自己做了对面看</p><p>第一个题还是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a>（你们怎么这么喜欢这个题（（（（（</p><p>然后是一个进制题<a href="https://leetcode-cn.com/problems/excel-sheet-column-number/">Excel表列序号</a>，刚好之前水力扣的时候水了一下，不过没水过也能写</p><p>剩下的两个题是<code>在排序二叉树中查找第五大的数</code>和<code>给定一个字符串，使用逗号进行分割，每个数字的大小都小于1112，输出所有情况</code></p><p>都是毕竟常规的题，比较迷惑的是后面面试官打了电话说看不到代码，提交之后我就没有联系上面试官了。。。</p><p>在面呗里面等了一个多小时就关了，第二天进去看到面试官还在里面挂着</p><p><del>你们腾讯都不下班的吗</del></p><h2 id="三面-2021-03-31"><a href="#三面-2021-03-31" class="headerlink" title="三面 2021.03.31"></a>三面 2021.03.31</h2><p>在早上突然收到的短信，直接给安排了下午下课之后</p><p>然后上来也是直接给两个题（感觉企业微信的都喜欢直接甩题过来？）</p><p>第一题：假设一个直播平台场景，给了直播间管理类<code>LiveMrg</code>的定义，每个直播间有id和热度score，然后会调用函数<code>add(int64_t _id, int64_t _score)</code>添加或修改直播间，以及函数<code>delete</code>进行删除操作，还会调用一个函数查询当前热度最高的100个直播间，返回id和热度列表</p><p>这里一开始想了一下用<code>set</code>，但是发现set不便于进行修改操作，后面就改成了<code>map</code>，然后取最高的使用了一个优先队列，重载了一下比较函数，限制优先队列只能存在100个元素</p><p>第二题：有30w个员工，以及给定一个<code>rand</code>函数会产生$[0, 65535]$之间的数，要求给30w员工进行一个抽奖，抽10w名，保证抽奖算法是公平的</p><p>这个题类似于一面的时候问的<code>rand5()</code>生成<code>rand3()</code>和<code>rand7()</code>，在进制里面做一下手脚就可以，这里我看65535模5为0，所以选了5进制生成一个数，直到得到满足要求的数</p><p>但是在代码写完提交给面试官之后我发现这里其实可以改成一个$O(n)$的洗牌算法，<del>我觉得随机算法可能会比较慢，不过保证概率一样其实也可以</del></p><blockquote><p><strong>插牌法</strong></p><p>从前往后进行扫描，把当前位置的数据随机插入到前面数据的某个位置，然后把选取到的数据与当前数据进行交换，这个算法的时间复杂度和空间复杂度都是$O(n)$的</p></blockquote><p>然后6点过面试官才打电话过来（这个时候我在撕泡面，幸好还没有开始泡</p><p>先问了我第一题是思路，然后给我说优先队列地方为什么每次都要<code>push</code>和<code>pop</code>，一开始没清楚他问的意思，后面提示了一下我才知道如果需要<code>push</code>的元素比堆顶小的话就可以省去，减少时间开销</p><p>然后又问我<code>map</code>是什么结构，可不可以考虑优化一下，才反应过来应该用<code>unordered_map</code>来写，时间复杂度其实我还没看，但是比前者低，这个时候面试官就笑我说怎么一开始没有想到。。。后面讲了一下第二题的思路，然后就开始问简历了</p><ul><li>我看你项目里面有信安大赛一等奖，能说一下这个项目吗（其实问的是前面的文件传输的课设，但是电话里听不清，所以这里我就讲区块链的项目了，面试官好像听的一愣一愣的</li><li>然后后面对面问了我才开始讲文件传输的那个课设</li><li>你是用什么加密的（RSA来进行密钥协商，然后ASE进行文件传输加密</li><li>协商协议是你自己想的吗，还是用了别人的（看了其他的协议然后自己也想了一些添加进去</li><li>那么有没有了解过D&amp;￥&amp;协议（这里重复了很多次我都没听清楚。。。我觉得他在说的是DH协议吧。。这里开始就信号不好了，然后出寝室讲</li><li>TCP协议的三次握手什么（balabalabala，然后第三次是怎么样的突然忘了，就随便水了一下</li><li>你每次发送的seq都是随机的？（第一次发送给对方的都是随机选取的，ack是对方序列号+1</li><li>你怎么这个都讲不清楚，是不是计网课没有好好上，你是不是经常逃课啊（内心：草，电话里不好讲又听不清楚，不过之前讲的时候确实忽略了这些细节</li><li>虚拟内存是怎么实现的（这里开始xjb讲分页和段页还有寻址，没抓住重点</li><li>我知道，我是想问内存没有这么大，那么它是怎么实现的（哦哦哦哦哦，将不需要的页换出到外部的存储空间中</li><li>那么它的目的是什么（内心：你不是都说了是因为内存不够大吗</li><li>有没有什么想问我的（你们是上次微信那个组的吗，然后说是企业微信的，我：？，我还以为你们那边是成都这里的</li><li>不是，企业微信在成都和广州都有，你的意向城市是成都对吧（对，但是如果要去广州也没问题</li></ul><p>然后面试官听到后面“没问题”三个字就以为我没有问题了。。。然后就结束了</p><p>总而言之企业微信后面的两次面试有点迷。。。然后晚上去实验课的时候官问状态变成了复试，实验完了回来变成了HR面（合着你们官问和实际的不统一</p><p>在写这里的时候收到了HR面的通知，但是是在明晚没时间啊草草草草草草草草草草草，只能选协调时间了（千万不要给我选在周五和字节的撞一起（（（其实现在我想把字节的面试咕了，快挂我吧秋梨膏</p><p>希望我不会成为以前看到的面经里面的HR面挂了的人（</p><h2 id="HR面-2021-04-01"><a href="#HR面-2021-04-01" class="headerlink" title="HR面 2021.04.01"></a>HR面 2021.04.01</h2><p>没啥能写的，主要就是聊一下以前做的项目里面的一些分工，还有遇到的比较大的挑战</p><p>整个过程里面还是有点紧张的，在摄像头前面看不出来，其实背一直在抖（（（</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;TEG-一二面&quot;&gt;&lt;a href=&quot;#TEG-一二面&quot; class</summary>
      
    
    
    
    <category term="杂记" scheme="http://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="面经" scheme="http://decision01.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
