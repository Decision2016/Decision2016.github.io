<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decision`s blog</title>
  
  
  <link href="https://decision01.com/atom.xml" rel="self"/>
  
  <link href="https://decision01.com/"/>
  <updated>2025-06-03T06:18:22.988Z</updated>
  <id>https://decision01.com/</id>
  
  <author>
    <name>Decision</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微雪墨水屏简单开发记录</title>
    <link href="https://decision01.com/post/af68713.html"/>
    <id>https://decision01.com/post/af68713.html</id>
    <published>2025-06-03T04:56:00.000Z</published>
    <updated>2025-06-03T06:18:22.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>毕业的事情忙完了开始搭建自己的信息收集渠道，然后电脑桌边上需要一个常量显示即时信息，但是又不需要亮着的玩意儿，那么就只能是墨水屏了。</p></div><p>这篇博文选用的是微雪的 7.5inch HD e-Paper V2 + ESP32 带 WIFI 的开发板来实现信息的渲染，微雪官方提供了对应的 Arduino 开发库和示例程序。</p><p>最开始在某宝看到这个套装还以为 ESP32 提供的 ESP32 WIFI 渲染程序是有一个接口的，可以在装载启动后直接提供一个内网的服务用来发送图片上去渲染。也就是官网的 WIFI 例程：<a href="https://www.waveshare.net/wiki/E-Paper_ESP32_Driver_Board。">https://www.waveshare.net/wiki/E-Paper_ESP32_Driver_Board。</a></p><p>在拿到板子后刷进去才发现，这个例程确实提供了一个网页用来上传图片并且进行采样生成 LCD 图片，但是它没有一个具体的接口，而且一张图片上传渲染完成之后就会关闭服务，所以需要达到自己想要的效果也就只能自己写程序了。示例程序可以用来测试一下板子正不正常，第四步里一种尺寸的板子有不同的型号，也需要正确选择才能正常渲染。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202506031322664.png" alt="img"></p><h1 id="渲染接口"><a href="#渲染接口" class="headerlink" title="渲染接口"></a>渲染接口</h1><p>ESP32 的示例程序里有一个名为 esp32-waveshare-epd 的文件夹，在按照微雪文档里的指示放到 Arduino 文件夹里就可以，这里也没有太多好写的，配置过程不管是官网还是网上也有不少。这个文件夹里包含了一系列的示例程序和开发所需要用到的库（这里好评，不用自己去慢慢学更底层的代码）。</p><p>需要明确的一点是这款墨水屏里长的那一侧为 x 轴，另外一侧为 y 轴，在摆正后以左上角为原点，y 轴向下。摆正的方向的话 7.5 inch 这块板子是排线向下为正，其他的就需要自己测试了。下面的函数调用需要引入 EPD.h 和 DEV_Config.h 文件。</p><p>示例程序里基本上以调用 <code>DEV_Module_Init</code> 开始，这个函数是用来初始化引脚的，只管启动就调</p><p>根据屏幕使用的不同，需要调用屏幕的初始化和清屏函数，通常是下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EPD_7IN5_V2_Init</span>();</span><br><span class="line"><span class="built_in">EPD_7IN5_V2_Clear</span>();</span><br></pre></td></tr></table></figure><p>这两个函数根据使用屏幕的型号不同也存在差异，在 <code>sp32-waveshare-epd\src\utility</code> 中可以根据型号找到对应的 .h 文件查看有哪些函数</p><p>Init 函数在 7.5 inch 这款屏中有四种，对应了后续不同的渲染过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UBYTE <span class="title">EPD_7IN5_V2_Init</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 完全渲染，在后续渲染屏幕的时候整个屏幕会闪烁刷新</span></span><br><span class="line"><span class="function">UBYTE <span class="title">EPD_7IN5_V2_Init_Fast</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 快速渲染，虽然不会闪烁，但是会出现花屏的情况</span></span><br><span class="line"><span class="function">UBYTE <span class="title">EPD_7IN5_V2_Init_Part</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 部分渲染，针对屏幕中的部分区域进行渲染，也不会闪烁，但是时间长了也会花屏</span></span><br><span class="line"><span class="function">UBYTE <span class="title">EPD_7IN5_V2_Init_4Gray</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 没用过，应该是根据灰度显示不同区域的？</span></span><br></pre></td></tr></table></figure><p>清屏也存在两种，分别对应了将整个屏幕刷黑和刷白</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPD_7IN5_V2_Clear</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPD_7IN5_V2_ClearBlack</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后是渲染函数，传入图像数组进行渲染</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPD_7IN5_V2_Display</span><span class="params">(UBYTE *blackimage)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPD_7IN5_V2_Display_Part</span><span class="params">(UBYTE *blackimage,UDOUBLE x_start, UDOUBLE y_start, UDOUBLE x_end, UDOUBLE y_end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPD_7IN5_V2_Display_4Gray</span><span class="params">(<span class="type">const</span> UBYTE *Image)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPD_7IN5_V2_WritePicture_4Gray</span><span class="params">(<span class="type">const</span> UBYTE *Image)</span></span>;</span><br></pre></td></tr></table></figure><p>这几个函数都是传入 byte 类型的图像进行渲染，对图像的绘制由另外一个库来实现。<code>EPD_7IN5_V2_Display_Part</code>函数用于进行部分渲染，部分渲染之前需要调用 <code>EPD_7IN5_V2_Init_Part</code> 函数，否则部分渲染的部分还是会进行闪烁。</p><h1 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h1><p>上面的各种 <code>Display</code> 函数需要传入一个 Image 数组进行渲染，微雪所提供的库里也包含了绘制图像的方法，需要引入 GUI_Paint.h 文件</p><p>在绘制图像之前需要定义这个数组并初始化，通常直接全局声明避免爆栈，也可以参考一下示例程序，这里主要对不同的函数调用说明。这样的话主文件的头部如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UBYTE *BlackImage;</span><br><span class="line">UWORD Imagesize = ((EPD_7IN5B_V2_WIDTH % <span class="number">8</span> == <span class="number">0</span>) ? (EPD_7IN5B_V2_WIDTH / <span class="number">8</span> ) : (EPD_7IN5B_V2_WIDTH / <span class="number">8</span> + <span class="number">1</span>)) * EPD_7IN5B_V2_HEIGHT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEV_Module_Init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((BlackImage = (UBYTE *)<span class="built_in">malloc</span>(Imagesize)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Failed to apply for black memory...\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Paint_NewImage</span>(BlackImage, EPD_7IN5_V2_WIDTH, EPD_7IN5_V2_HEIGHT, <span class="number">0</span>, WHITE);</span><br><span class="line">    <span class="built_in">EPD_7IN5_V2_Init</span>();</span><br><span class="line">    <span class="built_in">EPD_7IN5_V2_Clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Paint_Clear</span>(WHITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Paint_NewImage</code> 传入 BlackImage 用于设定图像，其实可以直接把它理解为一个画板了，后面的所有绘制操作本质上都是在这个画板上实现</p><p><code>Paint_Clear</code> 将画板刷为对应的颜色，还有另外一个 <code>Paint_ClearWindows</code> 在局部刷新的时候用于刷新单独的一个长方形区域</p><p>Paint 还有其他的函数，但是这次开发没有涉及到也就不说明，感兴趣可以探索一下（懒了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_SelectImage</span><span class="params">(UBYTE *image)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_SetRotate</span><span class="params">(UWORD Rotate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_SetMirroring</span><span class="params">(UBYTE mirror)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_SetPixel</span><span class="params">(UWORD Xpoint, UWORD Ypoint, UWORD Color)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_SetScale</span><span class="params">(UBYTE scale)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="点、线、面"><a href="#点、线、面" class="headerlink" title="点、线、面"></a>点、线、面</h3><p>绘制点、线、面有四个函数，分别绘制点、线、长方形和圆形：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawPoint</span><span class="params">(UWORD Xpoint, UWORD Ypoint, UWORD Color, DOT_PIXEL Dot_Pixel, DOT_STYLE Dot_FillWay)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawLine</span><span class="params">(UWORD Xstart, UWORD Ystart, UWORD Xend, UWORD Yend, UWORD Color, DOT_PIXEL Line_width, LINE_STYLE Line_Style)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawRectangle</span><span class="params">(UWORD Xstart, UWORD Ystart, UWORD Xend, UWORD Yend, UWORD Color, DOT_PIXEL Line_width, DRAW_FILL Draw_Fill)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawCircle</span><span class="params">(UWORD X_Center, UWORD Y_Center, UWORD Radius, UWORD Color, DOT_PIXEL Line_width, DRAW_FILL Draw_Fill)</span></span>;</span><br></pre></td></tr></table></figure><p>这些函数里需要传入的有：</p><p>坐标：<code>Xpoint</code>、<code>Ypoint</code> 或者 <code>Xstart</code>、<code>Ystart</code> 这样的字段都是用于指示坐标，直接传入整数，注意不要超过绘制范围，也就是屏幕的像素长宽</p><p>颜色：在墨水屏里就只有 BLACK 和 WHITE 黑白两种选项，其他类型的屏幕里可能会有 RED 这样的红色选项</p><p>画笔粗细：也就是 <code>DOT_PIXEL</code>，可以直接使用定义好的 <code>DOT_PIXEL_1X1</code> 到 <code>DOT_PIXEL_8X8</code>，<code>DOT_PIXEL_DFT</code> 默认为 1x1</p><p>点、线、面里存在不同的是最后一个参数</p><ul><li>在点的绘制里，<code>DOT_STYLE</code> 可选为 <code>DOT_FILL_AROUND</code> 或 <code>DOT_FILL_RIGHTUP</code>，代表的是 1x1 或 2x2 的像素点</li><li>在线的绘制里，<code>LINE_STYLE</code> 可选为 <code>LINE_STYLE_SOLID</code> 或 <code>LINE_STYLE_DOTTED</code> 代表实线和虚线</li><li>在面的绘制里，<code>DRAW_FILL</code> 可选为 <code>DRAW_FILL_EMPTY</code> 或 <code>DRAW_FILL_FULL</code> 代表空心或实心</li></ul><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>微雪的库里自带了一些英文或中文的文字库，如果需要引入其他字体就需要自行构建文字库进行传入绘制，绘制文字的函数有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawChar</span><span class="params">(UWORD Xstart, UWORD Ystart, <span class="type">const</span> <span class="type">char</span> Acsii_Char, sFONT* Font, UWORD Color_Foreground, UWORD Color_Background)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawString_EN</span><span class="params">(UWORD Xstart, UWORD Ystart, <span class="type">const</span> <span class="type">char</span> * pString, sFONT* Font, UWORD Color_Foreground, UWORD Color_Background)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawString_CN</span><span class="params">(UWORD Xstart, UWORD Ystart, <span class="type">const</span> <span class="type">char</span> * pString, cFONT* font, UWORD Color_Foreground, UWORD Color_Background)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawNum</span><span class="params">(UWORD Xpoint, UWORD Ypoint, <span class="type">int32_t</span> Nummber, sFONT* Font, UWORD Color_Foreground, UWORD Color_Background)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paint_DrawTime</span><span class="params">(UWORD Xstart, UWORD Ystart, PAINT_TIME *pTime, sFONT* Font, UWORD Color_Foreground, UWORD Color_Background)</span></span>;</span><br></pre></td></tr></table></figure><p><code>Paint_DrawChar</code>：绘制单个 ascii 字符</p><p><code>Paint_DrawString_EN</code>：绘制英文字符串</p><p><code>Paint_DrawString_CN</code>：绘制中文字符串，也可以混杂英文</p><p><code>Paint_DrawNum</code>：绘制数字</p><p><code>Paint_DrawTime</code>：绘制时间序列</p><p>（Xpoint，Ypoint）和 (Xstart, Ystart) 这样的字样也不用多说，代表坐标，随后的就是字符、字符串或者时间序列</p><blockquote><p>cFONT 和 sFONT 则代表了不同的字体的定义，可以直接看它们的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//ASCII</span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_tFont</span></span><br><span class="line">&gt;&#123;    </span><br><span class="line"> <span class="type">const</span> <span class="type">uint8_t</span> *table;</span><br><span class="line"> <span class="type">uint16_t</span> Width;</span><br><span class="line"> <span class="type">uint16_t</span> Height;</span><br><span class="line"> </span><br><span class="line">&gt;&#125; sFONT;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//GB2312</span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span>                                          <span class="comment">// 汉字字模数据结构</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> index[<span class="number">3</span>];                               <span class="comment">// 汉字内码索引</span></span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> matrix[MAX_HEIGHT_FONT*MAX_WIDTH_FONT/<span class="number">8</span>];  <span class="comment">// 点阵码数据</span></span><br><span class="line">&gt;&#125;CH_CN;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&gt;&#123;    </span><br><span class="line"> <span class="type">const</span> CH_CN *table;</span><br><span class="line"> <span class="type">uint16_t</span> size;</span><br><span class="line"> <span class="type">uint16_t</span> ASCII_Width;</span><br><span class="line"> <span class="type">uint16_t</span> Width;</span><br><span class="line"> <span class="type">uint16_t</span> Height;</span><br><span class="line"> </span><br><span class="line">&gt;&#125;cFONT;</span><br></pre></td></tr></table></figure><p>在不需要使用其他字体的时候可以不用管，直接传入定义好的字体就可以，例如下面就是英文和中文里各种字号的字体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">extern</span> sFONT Font24;</span><br><span class="line">&gt;<span class="keyword">extern</span> sFONT Font20;</span><br><span class="line">&gt;<span class="keyword">extern</span> sFONT Font16;</span><br><span class="line">&gt;<span class="keyword">extern</span> sFONT Font12;</span><br><span class="line">&gt;<span class="keyword">extern</span> sFONT Font8;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">extern</span> cFONT Font12CN;</span><br><span class="line">&gt;<span class="keyword">extern</span> cFONT Font24CN;</span><br></pre></td></tr></table></figure><p>如果需要使用自定义字体，那么需要将它们导出，例如 github 上的 <a href="https://github.com/theHEXstyle/font2bytes">https://github.com/theHEXstyle/font2bytes</a> 是一个将 ASCII 字符导出为字节码的程序，应该也有中文的相关开源库。在导出为字节码后放入到项目目录里引用就可以，例如我用了 Firacode 字体，那么就是先声明一个 external_fonts.h 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">ifndef</span> __EXTERNAL_FONTS_H</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> __EXTERNAL_FONTS_H</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fonts.h&gt;</span><span class="comment">// 这个字体文件是微雪里的，便于调 sFONT 类型</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">extern</span> sFONT FiraBoldFont42;</span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后将转换好的字形文件导入，并把主要的字形类改为对应的名字，在 external_fonts.cpp 文件里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;sFONT FiraBoldFont42 = &#123;</span><br><span class="line">FiraBoldFont42_Table,</span><br><span class="line"><span class="number">26</span>, <span class="comment">/* Width */</span></span><br><span class="line"><span class="number">42</span>, <span class="comment">/* Height */</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><p><code>Color_Foreground</code> 和 <code>Color_Background</code> 字段分别代表了文字的颜色和背景颜色</p><p>在所需要的绘制完成后，通过前面的各种 Display 函数就可以将图像显示在屏幕上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;毕业的事情忙完了开</summary>
      
    
    
    
    <category term="Dev" scheme="https://decision01.com/categories/Dev/"/>
    
    
    <category term="C++" scheme="https://decision01.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>秩父市圣地巡礼 | 未闻花名</title>
    <link href="https://decision01.com/post/90641208.html"/>
    <id>https://decision01.com/post/90641208.html</id>
    <published>2025-04-20T09:08:51.000Z</published>
    <updated>2025-04-21T02:29:56.370Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=31649308&auto=1&height=66"></iframe><div class="admonition note"><p>那朵花，一定还在某处继续绽放着。</p></div><p>如果不是因为在 16 岁的那个夏天点开《未闻花名》这部动漫，或许一辈子也不会知道秩父这座小城，也不会在八年后的初夏来到这里。在那个年纪初看动漫时并没有得到很大的触动，随着年龄的增长反而开始缅怀这样的青春和友情了。在去到秩父市之前已经在日本玩了一周，从福冈一路北上刚到东京。东京也有很多经典动漫的取景地，但是太多太杂，并且在东京又开始感受岛熟悉的大城市的感觉和“班味”，所以并没有在东京逛太多地方。而秩父这样的地方很能满足我对小城市在心理上的偏爱，所以在东京的三天时间单独留了一天来逛一下这座小城。</p><blockquote><p>很有意思的是《未闻花名》最开始就有在动漫里提到秩父，也就是封面图的秩父牛奶，但是刷过很多次也没有留意过地名。</p></blockquote><p>从东京去秩父最方便的就是搭乘电车，在池袋站出发搭乘西武铁路可以经过一次换乘后到秩父，电车的时刻信息可以在雅虎的【换乘案内】应用上查到（iOS 需要日区账号下载，新干线、JR 的交通信息也可以在上面查询）。圣地巡礼也少不了一个地图，最方便的自然就是巡礼地图 anitabi.cn 了，可以查到大部分动漫的取景地信息。</p><p>在巡礼之前查询到的信息都说可能需要一天的时间才能逛完，所以出发得比较早。早上 7 点多从池袋出发，坐了两个小时的电车才到秩父。西武铁路也可以买特急，但是特急列车也只是快了半个小时也就懒得麻烦了。去秩父的路上都没太多人，反而是反方向到东京的车上挤满了上班族（也就是东京所谓的“班味”了）。这次算是在日本比较完整的一次圣地巡礼，基本上就是按照巡礼地图上的信息走了一遍，半天的时间可以逛完。也可以考虑坐公交或者租自行车，笔者纯粹是第一次到日本觉得比较新奇所以能步行都选择步行。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504201930608.jpg" alt="圣地巡礼步行路线"></p><h1 id="羊山公园"><a href="#羊山公园" class="headerlink" title="羊山公园"></a>羊山公园</h1><p>从西武秩父站出来，最近的地点就是羊山公园，也就是动漫OP里波波坐的位置，不过看了很久死活找不到对应的视角。从西武秩父站到公园山顶大概30分钟的时间，要爬的坡也不是特别陡，公园里可以俯瞰秩父市区。当然，也能够看到远处的《未闻花名》里经常出现的旧秩父大桥。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202009700.jpg" alt="DSC06701"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504201952911.jpg" alt="DSC06691"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504201952822.jpg" alt="DSC06705"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504201952269.jpg" alt="DSC06706"></p>          </div><h1 id="秩父神社"><a href="#秩父神社" class="headerlink" title="秩父神社"></a>秩父神社</h1><p>从羊山公园出来后沿大道走可以到秩父神社，也是动漫里出现过的地点。顺路还能经过动漫里出现的一个商店，也是相当还原了。有打卡留念兴趣的话还可以在秩父神社求一个御朱印，不过染上这东西也和吸毒差不多了，每到一个不同地方的神社都想去要一个。</p><blockquote><p>御朱印<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[御朱印發展史，過去也曾被當紀念章？令和誕生的「御黑印」](https://vocus.cc/article/66fe9e5ffd897800013c697d)">[1]</span></a></sup>是日本神社、寺庙的一种参拜证明，不过笔者个人主要是为了每个地方的打卡，有点当作纪念章的意思。在日本旅游这一趟下来集的御朱印有300、500、1000日元的，绝大多数需要 500 日元。通常是在参拜之后受领（但是不信神鬼这些也不是很必要遵守这些，受付处也不会观察到底有没有参拜什么的），需要准备一个御朱印账，在神社、寺庙现场都有，价格1800-3000日元不等，貌似也可以在一些超市买到。受领的时候，一般都是在受付处说「すみません、御朱印をください」然后递本子。有部分神社现在是直接给印好的一张纸，笔者都是尽量要直接写的。</p><p>此外也就是需要避雷一些可能供奉了战犯之类的神社，比如难波八坂神社和靖国神社这种，就算不信神也心理上觉得恶心。</p></blockquote><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202009148.jpg" alt="DSC06718"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202009545.jpg" alt="DSC06719"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202008646.jpg" alt></p>          </div><p>在秩父神社外还能看到印有未闻花名的自动贩卖机和不知道干什么的东西，自动贩卖机上的图片还是神社取景的那一幕。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202031830.jpg" alt="DSC06720"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202057880.jpg" alt="202504202057880"></p>          </div><h1 id="定林寺及周边"><a href="#定林寺及周边" class="headerlink" title="定林寺及周边"></a>定林寺及周边</h1><p>从秩父神社出来后走进小路，在去定林寺的路上能顺路到几个取景地，下面是鸣子走过的路口和动漫里的面码家。沿途还能经过动漫里的仁太家，动漫里的视角是房子背后能看到远处的武甲山，不过在周围观察了许久都没能找到对应的视角。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202037551.jpg" alt="DSC06722"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202039515.jpg" alt="DSC06723"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202102320.jpg" alt></p>          </div><p>随后经过一个路口和动漫里出现过的蓝色自动贩卖机，才能到达动漫里出现次数比较多的定林寺。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202056015.jpg" alt="20250420205358"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202057495.jpg" alt="DSC06724"></p>          </div><p>在这里转入一条小径就能看到定林寺了，寺庙的样子还是和 14 年前出的动漫里面一模一样，甚至还保留了动漫里出现过的小和尚立牌。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202103624.jpg" alt="DSC06726"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202105059.jpg" alt="DSC06729"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202108743.jpg" alt="DSC06732"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202109194.jpg" alt="DSC06736"></p>          </div><p>定林寺的右边也有传统的写字挂牌，旁边还立了一个写有「世界人类和平」的柱子，再加上看到挂牌上来过的人们写下的东西不禁有点感慨。不巧的是出门的时候没带上专门留寺庙御朱印的本子，也就没在这里受领朱印了，不然也可以顺便在这里挂个牌子（但是臭工科生又能写出什么好文字出来呢）。寺庙里只见到了在受付处的两位正在谈笑的和尚，没有其他人，特别安静。索性就在这里歇息了一阵子，坐在椅子上吹吹风发发呆。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202110543.jpg" alt="DSC06740"></p><h1 id="旧秩父大桥"><a href="#旧秩父大桥" class="headerlink" title="旧秩父大桥"></a>旧秩父大桥</h1><p>从定林寺侧面的小路出来后能到附近的一个公园，这个公园也在动漫里出现过，在这个季节里也可以顺便赏一下公园里的花。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202126591.jpg" alt="DSC06747"></p><p>仁太坐过的椅子还保留着原样，不过旁边提示牌上的字已经在时间的消磨下变得无法辨认了。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202125273.jpg" alt="DSC06749"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202128571.jpg" alt="DSC06758"></p>          </div><p>公园里还有一处动漫里出现过的儿童设施，不过动漫里出现过的凉亭可能已经被拆了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202134280.jpg" alt="DSC06834"></p><p>出公园后走很长一段路才能到最后也是动漫里最有标志性的旧秩父大桥，在桥上能够看到远处的工厂，也在动漫里出现过很多次。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202146362.jpg" alt="DSC06801"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202146957.jpg" alt="DSC06776"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202157461.jpg" alt="DSC06792"></p>          </div><p>桥的这边尽头是一个中式餐馆， 不过它的菜名都比较抽象，于是午餐就在它对面的一家餐馆吃了。</p><p>现在日本的很多餐馆也在支持扫码点餐了，时光机理论诚不我欺。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202148883.jpg" alt="DSC06794"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202151553.jpg" alt></p>          </div><p>桥上还有一些印有《未闻花名》井盖，除此之外还有秩父取景的《知晓天空之蓝的人啊》和《心灵想要大声呼喊》的井盖，能保持这么干净说明也是经常有在维护</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202233469.jpg" alt="DSC06778"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202233672.jpg" alt="DSC06775"></p>          </div><p>旧秩父大桥另一边可以有一个台阶下到桥下，这里是动漫电影的背景</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202200608.jpg" alt="DSC06787"></p><p>桥墩下还有粉丝用石头留下的印记，超平和バスタース</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202200428.jpg" alt="DSC06779"></p><h1 id="彩蛋：秘密基地"><a href="#彩蛋：秘密基地" class="headerlink" title="彩蛋：秘密基地"></a>彩蛋：秘密基地</h1><p>除了巡礼地图上标记过的地方之外，不远处的下水道中心的里还有一个蓝色小屋，应该是粉丝们根据秘密基地布置出来的</p><p>下水道中心在晚上 18:30 后关闭，进去后右转再在第一个路口左转一路走就能看到（这里我走错了地方，只能在尽头处的围墙边绕进去）</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202208028.jpg" alt="DSC06830"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202208535.jpg" alt="DSC06828"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202209387.jpg" alt="DSC06808"></p>          </div><p>走进去之后就能看到类似动漫里秘密基地的布置，也有「超平和バスタース」的木牌，还放置了动漫里出现过的面码和仁太的照片</p><p>桌子上还有留言本，大部分是日本本地和中国粉丝的留言</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202210054.jpg" alt="DSC06810"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202209354.jpg" alt="DSC06812"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202209028.jpg" alt="DSC06813"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202210153.jpg" alt="DSC06815"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202213306.jpg" alt="DSC06814"></p>          </div><p>至此也算是完成了《未闻花名》的巡礼，不过也有一些取景地点没去到，但也算是这次日本行程里比较完整的一次圣地巡礼了。</p><p>巡礼的时候走到动漫里出现过的场景总能脑部出主角们出现的样子，也算是和自己过去的青春呼应起来了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202504202236399.jpg" alt="DSC06863"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://vocus.cc/article/66fe9e5ffd897800013c697d">御朱印發展史，過去也曾被當紀念章？令和誕生的「御黑印」</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; margi</summary>
      
    
    
    
    <category term="杂记" scheme="https://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="圣地巡礼" scheme="https://decision01.com/tags/%E5%9C%A3%E5%9C%B0%E5%B7%A1%E7%A4%BC/"/>
    
  </entry>
  
  <entry>
    <title>Solidity 编程优化策略</title>
    <link href="https://decision01.com/post/d7134320.html"/>
    <id>https://decision01.com/post/d7134320.html</id>
    <published>2024-12-11T08:55:37.000Z</published>
    <updated>2024-12-24T15:00:37.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>深入学习一点 Solidity 的优化方法，不然很多时候书到用时方恨少，主要内容来源于 <a href="https://snappify.com/view/f9a681c7-834c-467e-b34d-5ad443a893f2">The Optimization Iceberg</a></p><p>还没完全写完，有空了再补充（挖坑）</p></div><h1 id="数据存放原理"><a href="#数据存放原理" class="headerlink" title="数据存放原理"></a>数据存放原理</h1><p>在 EVM 中，存放数据的位置有 stack、calldata、memory、storage、code 和 log</p><ul><li>stack：即运行时栈，用于保存 EVM 指令的输入和输出数据。stack 的最大深度为 1024，在运行的时候只能访问栈顶的 16 个元素<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[深入了解 Solidity - 堆栈](https://learnblockchain.cn/article/5420)">[1]</span></a></sup>，每个元素的长度为 256 bits;</li><li>calldata<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ EVM Calldata - LearnEVM.com](https://learnevm.com/chapters/fn/calldata)">[3]</span></a></sup>：函数调用的输入，对应的是交易的 data 域。在正确调用合约时，calldata 的前 8 个字节用于指定函数，后跟的数据用于存放调用参数；</li><li>memory：临时的数据存放区域，在函数运行期间存放数据，在函数结束运行后销毁。在运行前 memory 是空的，每一次需要使用 memory 时会进行扩容，如果访问 memory 的数据超出页面大小，它会自动增大 32 字节，扩容需要耗费 gas<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[EVM Memory](https://favourajaye.hashnode.dev/evm-memory)">[2]</span></a></sup>；</li><li>storage：用于对数据进行持久化的存储，它以数据槽（slot）为单位进行数据的存放，每个 slot 长度为 256 bits，每个合约下可以使用最多 $2^{256}$ 个 slot<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is Smart Contract Storage Layout?](https://docs.alchemy.com/docs/smart-contract-storage-layout)">[4]</span></a></sup>；</li></ul><p>code 和 log 分别用于在特定区域存放合约代码和日志，log 只能在合约外通过 API 读取</p><h1 id="类型优化"><a href="#类型优化" class="headerlink" title="类型优化"></a>类型优化</h1><h2 id="变量打包"><a href="#变量打包" class="headerlink" title="变量打包"></a>变量打包</h2><p>EVM 中合约的属性变量被存放在 storage 中，属性变量被存放在 storage 的每个 slot 中。如果独立地声明每个属性变量，它们都会被依次存放在独立的 slot 下。读取或写入时 EVM 会通过 SLOAD 或 SSTORE 两种字节码实现<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[The Optimization Iceberg](https://snappify.com/view/f9a681c7-834c-467e-b34d-5ad443a893f2)">[5]</span></a></sup>：</p><ul><li>SLOAD：加载 slot 中的数据，在一笔交易内首次加载花费 2100 gas，后续加载每一次花费 100 gas；</li><li>SSTORE：如果涉及到之前未使用的 slot，首次存储花费 20000 gas，首次存储时候花费 2200 gas（SLOAD 加载对应 slot + 修改的费用），后续每一次修改花费 100 gas；</li></ul><p>通过将长度之和不大于 256 bits 的变量打包到一个 slot 下，可以有效地降低 SSTORE 带来的 gas 开销</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract BadPacking &#123;</span><br><span class="line">uint8 public var0;</span><br><span class="line">uint256 public var1;</span><br><span class="line">uint16 public var2;</span><br><span class="line"></span><br><span class="line">function set() public &#123;</span><br><span class="line">var0 = 1;</span><br><span class="line">var1 = 3;</span><br><span class="line">var2 = 55;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的合约中，<code>var0</code> 和 <code>var2</code> 可以打包在一起来减少一个 slot 的开销，手动打包是将它们放在一个结构体下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Data &#123;</span><br><span class="line">uint8 public var0;</span><br><span class="line">    uint16 public var2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Packing &#123;</span><br><span class="line">Data public data;</span><br><span class="line">uint256 public var1;</span><br><span class="line"></span><br><span class="line">function set() public &#123;</span><br><span class="line">data.var0 = 1;</span><br><span class="line">        data.var2 = 55;</span><br><span class="line">var1 = 3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样声明的 Data 类结构体可以直接被存放在一个 slot 下，从而节省 slot 声明时的开销，也可以直接调整顺序，开启优化后 solidity 编译器会尝试进行优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract BadPacking &#123;</span><br><span class="line">uint8 public var0;</span><br><span class="line">    uint16 public var2;</span><br><span class="line">uint256 public var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><p>常量与变量体现在合约函数的编写和调用中</p><ol><li>在合约函数中，声明一个固定不变的值是常量类型，它就主要被硬编码在合约的 bytecode 中，而不用从 storage 中通过 SLOAD 加载；</li><li>在调用函数时，通过 calldata 声明是一个常量，就不需要将数据存放到 memory 中来开辟内存；</li></ol><h3 id="函数内声明"><a href="#函数内声明" class="headerlink" title="函数内声明"></a>函数内声明</h3><p>通过 <code>constant</code> 关键字来声明常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract Constant&#123;</span><br><span class="line">uint256 public constant c = 0x30000000000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用时声明"><a href="#调用时声明" class="headerlink" title="调用时声明"></a>调用时声明</h3><p>通过 <code>calldata</code> 声明传入的参数不再被修改，如果使用 <code>memory</code> 则涉及到 SLOAD 和 SSTORE，需要更多的 gas 开销</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Calldata &#123;</span><br><span class="line">string public s;</span><br><span class="line">function f(string calldata input) external &#123;</span><br><span class="line">s = input;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>读取 storage 中的数据时，首次读取消费 2100 gas，后续每一次读取需要 100 gas。而从 memory 中读取所消耗的 gas 会小很多，所以在必要时可以将数据先读取到 memory 后，再使用 memory 中的数据作为变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Cached &#123;</span><br><span class="line">uint256 public a = 10;</span><br><span class="line"></span><br><span class="line">function f(uint256 input) external returns (uint256) &#123;</span><br><span class="line">uint256 i = 0;</span><br><span class="line">uint256 res = 0;</span><br><span class="line">// 这里将 a 加载到 memory</span><br><span class="line">uint256 aCached = a;</span><br><span class="line"></span><br><span class="line">for (i; i &lt; aCached; i++) &#123;</span><br><span class="line">res += input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p><strong>i++ &amp; ++i</strong>：在进行自增时通常会使用 <code>++</code> 操作符，这里的原理和 C 语言里比较相似（沟槽的 C 语言还在追我），也是通过 <code>++i</code> 自增的时候不会生成临时变量，所以它的 gas 开销会更低一点</p><p><strong>unchecked</strong>：solidity 0.8 后添加了溢出检查，但并不是每次的检查都是有必要的，可以通过 unchecked 来声明一段代码不进行溢出检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Uncheck &#123;</span><br><span class="line">function add(uint256 a, uint 256 b) public returns(uint256) &#123;</span><br><span class="line">unchecked &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较符号</strong>：使用 <code>&gt;</code> 或 <code>&lt;</code> 的比较符时需要在栈内通过 SWAP 来实现，而使用 <code>==</code> 或 <code>!=</code> 时则没有这样的操作，所以可以进行替换来节省gas</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (i; i != n; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>短路操作</strong>：一种在其他语言力也很常见的优化方法，在进行布尔运算的时候，如果是 <code>||</code> 运算，尽量将可能为真的条件放在前面，这样第一个条件命中就会直接判断为真。如果是 <code>&amp;&amp;</code> 运算，尽量将可能为假的条件放在前面，第一个条件不命中时判断为假。</p><p><strong>数据类型声明</strong>：在非必要的情况下都直接使用 <code>uint256</code>，而不是较短的 <code>uint8</code> 或 <code>uint32</code> 之类，这是因为 EVM 对进行掩码计算，以保证数据类型在范围内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DUP</span><br><span class="line">PUSH 0xff</span><br><span class="line">AND</span><br></pre></td></tr></table></figure><p><strong>位运算</strong>：同样是常见的优化方法，对于2的整数倍的乘法或除法，可以直接使用位运算来节省 gas；</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnblockchain.cn/article/5420">深入了解 Solidity - 堆栈</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://favourajaye.hashnode.dev/evm-memory">EVM Memory</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnevm.com/chapters/fn/calldata"> EVM Calldata - LearnEVM.com</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.alchemy.com/docs/smart-contract-storage-layout">What is Smart Contract Storage Layout?</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://snappify.com/view/f9a681c7-834c-467e-b34d-5ad443a893f2">The Optimization Iceberg</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;深入学习一点 So</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="solidity" scheme="https://decision01.com/tags/solidity/"/>
    
    <category term="ethereum" scheme="https://decision01.com/tags/ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Golang 插件技术</title>
    <link href="https://decision01.com/post/8191bc14.html"/>
    <id>https://decision01.com/post/8191bc14.html</id>
    <published>2024-10-25T08:25:34.000Z</published>
    <updated>2024-12-24T15:01:54.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>应用程序中的插件功能可以通过 4 个基本概念来描述<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Fundamental concepts of plugin infrastructures](https://eli.thegreenplace.net/2012/08/07/fundamental-concepts-of-plugin-infrastructures)">[1]</span></a></sup>：</p><ol><li>Discovery（发现）：用于正在运行的程序找出它可以使用哪些插件的机制，需要给应用程序指定查看什么位置（工作路径）以及需要查找什么；</li><li>Registration（注册）：用于插件告知应用程序 - <em>I’m here, ready to do work</em> 的一种机制，将插件载入到应用程序中；</li><li>Hooks（挂载点）：插件可以将自身”附加”到应用程序的位置，<strong>表明它可以获取信息并参与流的范围</strong>，挂载点的确切性很大程度上取决于应用程序的设计。这个过程时插件注册自己的功能到应用程序，再由应用程序调用插件的方法（应用程序 -&gt; 插件）；</li><li>Extension API（扩展 API）：应用程序需要公开插件可以使用的 API，用于授予它们对应用程序的访问、调用权限。这个过程是应用程序提供一些方法给插件，插件再运行时进行调用（插件 -&gt; 应用程序）；</li></ol></blockquote><p>Golang 中的插件可以根据实现方式划分为三种：编译时插件、运行时插件、远程调用插件</p><p>远程调用插件通常通过 IPC、RPC 或 TCP 通信的方式来实现，插件作为一个独立的进程在本地或者远程运行，相比于编译时插件和运行时插件，这种插件的运行效率会低两个数量级</p><p>示例代码仓库：<a href="https://github.com/Decision2016/go-plugins-example">https://github.com/Decision2016/go-plugins-example</a></p><ul><li>caller：插件的调用代码</li><li>implement：插件的实现代码</li><li>interfaces：插件接口定义，部分插件不需要定义接口</li></ul><h2 id="编译时插件"><a href="#编译时插件" class="headerlink" title="编译时插件"></a>编译时插件</h2><p>编译时插件是通过在编写代码时选用插件包的方式来实现插件的调用，这样的插件包是具有一定规范的，一个例子是 <code>database/sql</code> 包的调用，可以参考 <a href="https://eli.thegreenplace.net/2019/design-patterns-in-gos-databasesql-package/">Design patterns in Go’s database/sql package</a> 的介绍</p><p>这样的模式是在主程序中提供调用插件包的函数，同时插件包需要满足调用规范（Hooks），编译时插件对应的四个基本概念：</p><ol><li>Discovery：直接通过 <code>import</code> 的方式来导入插件包，插件在自身的 <code>init</code> 函数中执行注册；</li><li>Registration：插件被编译到主应用程序中，所以它可以直接从插件的调用注册函数；</li><li>Hooks：插件包中实现应用程序（主程序）中所提供的接口，主程序可以调用这些接口来完成挂载；</li><li>Extension API：编译时插件被编译为二进制，所以只能被主程序通过 <code>import</code> 的方式来使用插件包；</li></ol><p>编译时插件本质上是一个通过调用接口类来实现功能的方式，插件包需要实现接口所提供的方法。这种插件的实现方式并不能很好提高程序的扩展性，在每一次需要更换插件的时候都需要修改代码并重新编译。如果需要在应用程序中载入较多的插件，那么这些插件也会作为程序的一部分编码到输出的二进制程序中</p><h2 id="运行时插件"><a href="#运行时插件" class="headerlink" title="运行时插件"></a>运行时插件</h2><p>与编译时插件不同，运行时插件是没有被编译到主程序的二进制文件，由应用程序在运行过程中加载，在编译语言下通常可以通过共享库的方式来实现</p><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>Golang 在 1.8 版本开始提供了一个 <code>plugin</code> 包用于提供插件功能，它实现了插件的加载和符号解析功能用于支持插件的实现</p><p>首先将它对应到插件的四个基本概念下：</p><ol><li>Discovery：<code>plugin</code> 提供了 <code>plugin.Open(path string)</code> 方法加载指定路径下的插件，那么在实现的时候就可以指定目录，并尝试从中通过 <code>Open</code> 方法加载目录下的 .so 文件来加载插件；</li><li>Registration：所有的插件都需要实现一个初始化函数，用于在主程序载入插件后进行插件的初始化以完成注册；</li><li>Hooks：插件内部可以通过初始化时传入的相关对象，例如一个插件的管理器 <code>PluginManager</code>，提供一个方法用于将插件的方法注册到应用程序；</li><li>Extension API：应用程序可以在初始化插件时将自身的一些对象或函数传入到插件内部，插件调用这些方法获取信息或实现功能；</li></ol><p>具体地，Golang 下的插件通过定义 <code>interface</code> 来定义插件的接口，在一个 <code>package main</code> 中实现接口方法来实现一个插件。但是目前的插件功能只支持在 Linux、FreeBSD 和 MacOS 上运行，暂时不支持 Windows 系统上执行</p><p>例如定义一个插件接口，可以将字符串转换为不同的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IConverter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 传入一个字符串，返回另外一种格式的字符串</span></span><br><span class="line">    Run(<span class="type">string</span>) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一种插件的实现，将字符串转换为 hex 形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HexConverter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *HexConverter)</span></span> Run(s <span class="type">string</span>) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> hex.EncodeToString([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，一定要是大写，否则在载入插件后找不到暴露出的对象</span></span><br><span class="line"><span class="keyword">var</span> Converter HexConverter</span><br></pre></td></tr></table></figure><p>然后对 package 进行编译，在正常的编译指令下添加 <code>-buildmode=plugin</code>，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=plugin -o hex.so</span><br></pre></td></tr></table></figure><p>在主程序中可以载入该 .so 文件来加载插件，并且执行对应的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p, err := plugin.Open(<span class="string">&quot;hex.so&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">symbol, err := p.Lookup(<span class="string">&quot;Converter&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := symbol.(IConverter)</span><br><span class="line">hexString :=c.Run(<span class="string">&quot;test plugin&quot;</span>)</span><br><span class="line">fmt.Println(hexString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plugin</code> 作为一个共享库插件实现，可以提供比较灵活的插件功能。但是它所存在的限制是：</p><ul><li>只能在类 Linux 系统下使用，不能提供很强的适配；</li><li>插件和主程序的编译版本必须一致以保证安全性，如果不一致则不能正确地载入插件；</li></ul><h3 id="wazero"><a href="#wazero" class="headerlink" title="wazero"></a>wazero</h3><p>wazero 是一个用 Golang 运行 WebAssembly 模块（Wasm）的运行时，它不需要其他的依赖就可以运行 Wasm 模块（零依赖）</p><blockquote><p>Wasm 是一种偏汇编的编程语言，它被设计用于提供比 JavaScript 更快的编译和执行。开发者可以通过熟悉的编译语言编译为 Wasm 模块， 再由虚拟机引擎在浏览器中执行模块。</p></blockquote><p>在 Golang 下，可以将插件编译为 Wasm 模块，然后再运行时引入模块以执行功能，它可以提供类似于原生 <code>plugin</code> 所提供的功能。相比 <code>plugin</code> 来说，<code>wazero</code> 所提供的功能较为灵活，它不需要指定 Golang 的版本，甚至可以不指定使用 Golang 语言。但是在实际的使用下，整个 Wasm 模块是单独在其虚拟运行环境下运行，所以一些传参和读取的操作需要编写代码来手动完成。同样地，以实现一个字符串转换的插件为例</p><p>首先需要下载 tinygo 和 binaryen：</p><ul><li><a href="https://tinygo.org/getting-started/install/">https://tinygo.org/getting-started/install/</a></li><li><a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a></li></ul><p>在配置环境变量后，在运行之前还需要指定环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set TINYGOROOT=&lt;tingygo 解压后所在目录&gt;</span><br><span class="line">set set WASMOPT=&lt;binaryen 解压目录下的/bin/wasm-opt 路径&gt;</span><br></pre></td></tr></table></figure><p>插件的实现，需要在插件内部通过读取指针内存的方式来读取参数，然后调用函数。返回值以返回指针的方式来完成<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[TinyGo allocation example](https://github.com/tetratelabs/wazero/tree/main/examples/allocation/tinygo)">[4]</span></a></sup>，注意注释 <code>//export convert</code> 是一个注解，TinyGo 通过这个注释来暴露函数</p><p>这里还可以参考官方示例：<a href="https://github.com/tetratelabs/wazero/tree/main/examples/allocation/tinygo">https://github.com/tetratelabs/wazero/tree/main/examples/allocation/tinygo</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hex.EncodeToString([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export convert</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">convert</span><span class="params">(ptr, size <span class="type">uint32</span>)</span></span> (ptrSize <span class="type">uint64</span>) &#123;</span><br><span class="line">s := ptrToString(ptr, size)</span><br><span class="line">result := convert(s)</span><br><span class="line"></span><br><span class="line">p, size := stringToPtr(result)</span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint64</span>(p) &lt;&lt; <span class="type">uint64</span>(<span class="number">32</span>)) | <span class="type">uint64</span>(size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ptrToString</span><span class="params">(ptr <span class="type">uint32</span>, size <span class="type">uint32</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.String((*<span class="type">byte</span>)(unsafe.Pointer(<span class="type">uintptr</span>(ptr))), size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringToPtr</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">uint32</span>, <span class="type">uint32</span>) &#123;</span><br><span class="line">ptr := unsafe.Pointer(unsafe.StringData(s))</span><br><span class="line"><span class="keyword">return</span> <span class="type">uint32</span>(<span class="type">uintptr</span>(ptr)), <span class="type">uint32</span>(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该插件（这里是 Windows 下的执行指令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> GOOS=js</span><br><span class="line"><span class="built_in">set</span> GOARCH=wasm</span><br><span class="line">tinygo build -o wasm.wasm -scheduler=none --no-debug -target=wasi main.go</span><br></pre></td></tr></table></figure><p>然后在调用代码中，使用 <code>wazero.NewRuntime</code> 初始化 Wasm 运行环境，并读取上插件的字节码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取插件字节码</span></span><br><span class="line">wasmBytes, err := os.ReadFile(<span class="string">&quot;wasm.wasm&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx := context.Background()</span><br><span class="line"><span class="comment">// 初始化 Wasm 运行环境</span></span><br><span class="line">r := wazero.NewRuntime(ctx)</span><br><span class="line"><span class="keyword">defer</span> r.Close(ctx)</span><br><span class="line"></span><br><span class="line">wasi_snapshot_preview1.MustInstantiate(ctx, r)</span><br><span class="line"><span class="comment">// 载入插件字节码</span></span><br><span class="line">mod, err := r.Instantiate(ctx, wasmBytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在载入的 Wasm 模块中查找字符串的方式可以查询到所要调用的函数，这里得到暴露出的 <code>convert</code> 函数和默认暴露的内存分配与释放函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn := mod.ExportedFunction(<span class="string">&quot;convert&quot;</span>)</span><br><span class="line">malloc := mod.ExportedFunction(<span class="string">&quot;malloc&quot;</span>)</span><br><span class="line">free := mod.ExportedFunction(<span class="string">&quot;free&quot;</span>)</span><br></pre></td></tr></table></figure><p>下面定义需要传入的参数，并在 Wasm 虚拟环境中开辟内存空间以传入参数和调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的参数及分配内存空间</span></span><br><span class="line">param := <span class="string">&quot;wasm&quot;</span></span><br><span class="line">results, err := malloc.Call(ctx, <span class="type">uint64</span>(<span class="built_in">len</span>(param)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配内存空间的返回值，分别是内存指针和长度</span></span><br><span class="line">paramPtr, paramSize := results[<span class="number">0</span>], <span class="type">uint64</span>(<span class="built_in">len</span>(param))</span><br><span class="line"><span class="keyword">defer</span> free.Call(ctx, paramPtr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数写入到 Wasm 的内存</span></span><br><span class="line"><span class="keyword">if</span> !mod.Memory().Write(<span class="type">uint32</span>(paramPtr), []<span class="type">byte</span>(param)) &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;write memory pointer %d failed&quot;</span>, paramPtr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">res, err := fn.Call(ctx, paramPtr, paramSize)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resPtr := <span class="type">uint32</span>(res[<span class="number">0</span>] &gt;&gt; <span class="number">32</span>)</span><br><span class="line">resSize := <span class="type">uint32</span>(res[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> resString, ok := mod.Memory().Read(resPtr, resSize); !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;read memory pointer %d failed&quot;</span>, resPtr))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="type">string</span>(resString))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面插件中，函数的返回值是一个 64 bits 的无符号整数（函数 <code>stringToPtr</code> 的返回值），它将内存指针和长度压缩在一起，前 32 bits 是长度，后 32 bits 是内存指针，所以需要解析后在内存指针中读取返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resPtr := <span class="type">uint32</span>(res[<span class="number">0</span>] &gt;&gt; <span class="number">32</span>)</span><br><span class="line">resSize := <span class="type">uint32</span>(res[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> resString, ok := mod.Memory().Read(resPtr, resSize); !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;read memory pointer %d failed&quot;</span>, resPtr))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="type">string</span>(resString))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="远程调用插件"><a href="#远程调用插件" class="headerlink" title="远程调用插件"></a>远程调用插件</h2><p>远程调用插件的实现很对得上它的名字，即通过远程调用的方法来实现，例如另外一个名为 <code>go-plugin</code> 的包基于 gRPC 的方式来完成插件的实现。插件作为一个独立的进程在本地或远程运行，相比于上面两种插件，远程调用插件与主程序的耦合度更低，但是带来的是额外的通信开销，所以这种插件的运行速度是明显不如前两种实现的。</p><p>（待续）</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://eli.thegreenplace.net/2012/08/07/fundamental-concepts-of-plugin-infrastructures">Fundamental concepts of plugin infrastructures</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/uberswe/go-plugin-benchmark">Benchmark comparing the go plugin package to other plugin implementations - Github</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://eli.thegreenplace.net/2019/design-patterns-in-gos-databasesql-package/">Design patterns in Go's database/sql package</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/tetratelabs/wazero/tree/main/examples/allocation/tinygo">TinyGo allocation example</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;应用程序中的插件功能可以通过 4 个基本概念来描述</summary>
      
    
    
    
    <category term="Dev" scheme="https://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="https://decision01.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>部分签名交易</title>
    <link href="https://decision01.com/post/c085945e.html"/>
    <id>https://decision01.com/post/c085945e.html</id>
    <published>2024-10-03T08:01:33.000Z</published>
    <updated>2025-06-03T06:18:22.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>部分签名交易（Partially Signed Bitcoin Transaction, PSBT）是在 (BIP-174)[<a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki]">https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki]</a> 中提出的一种交易格式，它使得用户可以对交易中的一部分输入进行签名，最后和其他用户的输入一起组成新的交易。这种交易格式的应用在于：</p><ul><li>离线钱包签名：观察签名进行交易的构造，随后由冷钱包完成签名，最后再广播到节点上，从而保证冷钱包的安全性；</li><li>多方交易：多个签名者之间传输交易，最后组成新的交易；</li><li>NFT 市场：现有的铭文协议中，通常使用 PSBT 来构建买卖双方的交易，由 Dex 完成组装后完成双方的交易；</li></ul><h1 id="PSBT-规范"><a href="#PSBT-规范" class="headerlink" title="PSBT 规范"></a>PSBT 规范</h1><p>PSBT 的格式由一系列的键值对映射组成，键值对由 0x00 作为终止符，其二进制下的å格式如下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[BIP-174 - Bitcoin Wiki](https://en.bitcoin.it/wiki/BIP_0174)">[1]</span></a></sup>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;psbt&gt; := &lt;magic&gt; &lt;global-map&gt; &lt;input-map&gt;* &lt;output-map&gt;*</span><br></pre></td></tr></table></figure><p>依次对应每个值，有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;magic&gt; := 0x70 0x73 0x62 0x74 0xFF// &quot;PSBT&quot; 的 ASCII + 0xFF 结尾</span><br><span class="line">&lt;global-map&gt; := &lt;keypair&gt;* 0x00// 一系列的键值对 keypair + 0x00 结尾</span><br><span class="line">&lt;input-map&gt; := &lt;keypair&gt;* 0x00</span><br><span class="line">&lt;output-map&gt; := &lt;keypair&gt;* 0x00</span><br></pre></td></tr></table></figure><p>而键值对的组成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keypair&gt; := &lt;key&gt; &lt;value&gt;// key-value</span><br><span class="line">&lt;key&gt; := &lt;keylen&gt; &lt;keytype&gt; &lt;keydata&gt;// keylen 是 keytype + keydata 的长度</span><br><span class="line">&lt;value&gt; := &lt;valuelen&gt; &lt;valuedata&gt;// valuelen 是 valuedata 的长度</span><br></pre></td></tr></table></figure><p>全局键值对、输入键值对、输出键值对定义了多种键类型（keytype），具体可参考 <a href="https://en.bitcoin.it/wiki/BIP_0174">BIP-174 - Bitcoin Wiki</a></p><p>在所有签名者完成签名后，需要将所有的 PSBT 组合为一个 PSBT，完成该功能的角色被称为 Combiner，它最终会输出一个 PSBT，交由 Input Finalizer 进行处理</p><h1 id="签名与签名类型"><a href="#签名与签名类型" class="headerlink" title="签名与签名类型"></a>签名与签名类型</h1><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>在 Bitcoin 中，签名是 DER 格式的 ECDSA 签名，其签名以 0x30 标识符开头，在 DER 中表明这是一个组合的结构，然后跟一个表示结构长度的字节。这个组合结构就是 ECDSA 签名下的签名输出 $\sigma=(r,s)$</p><p>具体地，它的编码格式如下图所示<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Signature - Learn me a bitcoin](https://learnmeabitcoin.com/technical/keys/signature/)">[2]</span></a></sup>，签名的格式实际上是对签名最终输出的 $(r,s)$ 进行二进制序列化</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202410051844725.png" alt="A diagram showing how convert a raw signature to DER encoding."></p><p>签名的过程根据 Pay-To 方式的不同划分为两种，分别用于非 Sigwit 交易和 Sigwit 交易，详见 <a href="https://learnmeabitcoin.com/technical/keys/signature/">Signature - Learn me a bitcoin</a> 的 Legacy Algorithm 和 Segwit Algorithm 两种算法。Segwit 算法在 BIP-143 中被提出，它将交易数据划分为单独可重用的各个部分，便于加快交易的验证流程。</p><p>在 DER 签名的最后还有除签名本身之外的长为一个字节的 SIGHASH 字段，它用于标识签名的类型。</p><h2 id="签名类型"><a href="#签名类型" class="headerlink" title="签名类型"></a>签名类型</h2><blockquote><p>以下内容需要分别对 Legacy 和 Segwit 签名算法中的“交易数据哈希 - Step.4”和“原像构造 - Step.1”过程有一定的了解才便于理解</p></blockquote><p>在构造 Bitcoin 交易的过程中，签名必然需要针对某一交易进行签名，可以使用 $\sigma \leftarrow Sign(pk, m)$ 来表示这一过程，对交易数据进行哈希和构造原像就是为了得到这里的 $m$</p><p>构造哈希和原像的过程会得到一个待签名的消息 $m$，签名类型用于指定这个消息 $m$ 所关联的输入和输出，签名类型在签名完成后追加在 DER 格式的签名的最后作为签名的一部分。在 bitcoin 的代码库(<a href="https://github.com/bitcoin/bitcoin/blob/56f69360dc98bd68704f19646a84d045788d199e/src/script/interpreter.h#L21">bitcoin/src/script/interpreter.h</a>)中定义了签名类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    SIGHASH_ALL = <span class="number">1</span>,</span><br><span class="line">    SIGHASH_NONE = <span class="number">2</span>,</span><br><span class="line">    SIGHASH_SINGLE = <span class="number">3</span>,</span><br><span class="line">    SIGHASH_ANYONECANPAY = <span class="number">0x80</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前三种 <code>SIGHASH_ALL</code>、<code>SIGHASH_NONE</code>和<code>SIGHASH_SINGLE</code> 指定关联了交易中的所有输入，分别指定不同的输出</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202410131648417.png" alt="image-20241013164852332"></p><p>上图展示了前三种签名类型所关联的输入、输出，这三种签名类型都会和所有的输入关联，不同在于关联的输出。左侧和右侧分别代表了交易的输入和输出，红色的是当前待签名的输入，黄线则是签名所关联的输入或输出</p><ul><li><code>SIGHASH_ALL</code>：关联所有的输入和输出，这是面向消费者钱包的默认签名类型；</li><li><code>SIGHASH_NONE</code>：仅关联所有的输入，但是和任何的输出都没有关系；</li><li><code>SIGHASH_SINGLE</code>：关联所有的输入，同时关联一个和当前输入所在位置一样的输出，例如图中红色表示待签名的输入，那么关联的输出是对应位置上的输出；</li></ul><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202410131716032.png" alt="image-20241013171531988">    </p><p><code>SIGHASH_ANYONECANPAY</code> 和前面的三种签名类型一起使用（在位运算中通过按位或的方式来连接），但是它只用于指定当前签名的输入，这是部分签名实现所需要的基础</p><ul><li><code>SIGHASH_ALL|SIGHASH_ANYONECANPAY</code>：关联该输入的同时关联所有的输出，即在同意输出的情况下加入一笔交易；</li><li><code>SIGHASH_NONE|SIGHASH_ANYONECANPAY</code>：仅关联当前的交易输入，是一种极不安全的签名类型。这代表输入可以被纳入到任何的交易，即允许这笔输入的比特币被任何人使用，可以被用作燃烧证明；</li><li><code>SIGHASH_SINGLE|SIGHASH_ANYONECANPAY</code>：关联输入本身和对应位置上的输出，这是一种常用的部分签名交易。现在常被用于比特币上的交换协议中。例如在 Ordinals 协议下，输入中携带了一个 NFT 资产，那么需要交易的情况下可以指定该输入，并指定一个输出，要求在这个输出下向自己的地址发送一定数量的 btc。这样的部分签名就可以用于实现交易市场，这也是目前的大部分交易市场实现的原理；</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/BIP_0174">BIP-174 - Bitcoin Wiki</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnmeabitcoin.com/technical/keys/signature/">Signature - Learn me a bitcoin</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/BIP_0143">BIP-143 - Bitcoin Wiki</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;部分签名交易（Partially Signed Bitcoin Transa</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="bitcoin" scheme="https://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>P2P 网络自引导技术</title>
    <link href="https://decision01.com/post/b699c560.html"/>
    <id>https://decision01.com/post/b699c560.html</id>
    <published>2024-09-10T05:18:02.000Z</published>
    <updated>2024-12-24T15:02:44.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>毕业设计相关的内容查了一些论文，好像也没有什么太多的发展，基本上都是2009年左右的内容了，算是稍微整理一下。</p><p>自主引导问题：端到端网络（Peer-to-Peer, P2P）网络通常需要一个或一组引导（Bootstrap）节点。在 P2P 网络中，引导也是唯一一个中心化的任务，新节点需要依赖引导节点的帮助来发现其他的节点并建立连接。现有的 P2P 系统会在软件内置一个引导节点列表，新节点在启动时通过这个引导节点列表依次去请求加入网络。那么，是否存在一种技术，使得运行同一个 P2P 服务的节点可以直接发现其他同类节点，而不需要引导的帮助。</p></div><h1 id="随机地址探测"><a href="#随机地址探测" class="headerlink" title="随机地址探测"></a>随机地址探测</h1><p>一种暴力的地址探测方法<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Decentralized Bootstrapping of P2P Systems: A Practical View](https://networking.ifip.org/2009/Website/proceedings/networking/1569173039.pdf)">[1]</span></a></sup>，即在固定端口下随机抽取 IP 地址进行探测，运行了同样 P2P 应用的主机会进行响应</p><p>但是这样的方法只能适用于规模较大的 P2P 网络，例如 BitTorrent</p><h1 id="基于-IPv6-的随机地址探测"><a href="#基于-IPv6-的随机地址探测" class="headerlink" title="基于 IPv6 的随机地址探测"></a>基于 IPv6 的随机地址探测</h1><h2 id="IPv6-简介"><a href="#IPv6-简介" class="headerlink" title="IPv6 简介"></a>IPv6 简介</h2><p>IPv6 地址<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A Generic, Self-Organizing, and Distributed Bootstrap Service for Peer-to-Peer Networks](https://link.springer.com/chapter/10.1007/978-3-540-74917-2_7)">[3]</span></a></sup><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[IPv6 - Wikipedia](https://en.wikipedia.org/wiki/IPv6)">[7]</span></a></sup>的长度为 128 bits，在实际使用的时候写为 16 进制的字符串，每 32 bits 作为一个分组，以冒号作为分隔符</p><p>即每个 IPv6 的地址的通用格式为 <code>x:x:x:x:x:x:x:x</code>，每个 <code>x</code> 表示一个长度为 4 的十六进制字符串</p><blockquote><p>表示规则：</p><ol><li><p>忽略前导 0：在每个分组内，如果字符串具有前导 0 则忽略；</p></li><li><p>双冒号：在一个地址中，可以使用双冒号 <code>::</code> 代替一个或多个分组都是 0 的连续字符串。在一个地址中，双冒号只能使用一次，通常使用它来表示最长的连续为 0 的多个分组，其他为 0 的分组则直接使用 0 写出；例如：</p><p> <code>2001:0db8:0000:0000:ab00:0000:0000:0000</code> =&gt; <code>2001:db8:0:0:ab00::</code></p></li></ol></blockquote><p>地址类型：单播地址、组播地址、任播地址</p><ul><li>单播：用于唯一标识支持 IPv6 点设备上的接口；</li><li>组播：将单个 IPv6 数据包发送到多个目的地；</li><li>任播：任播地址是可分配到多个设备的 IPv6 的任播地址，发送到这类地址的数据包会被路由到最近的拥有该地址的设备；</li></ul><h3 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h3><p>全局单播地址（Global Unicast Address，GUA）类似于公有 IPv4 地址，具有全局唯一性，它的格式为：</p><p><code>|------ Global Routing Prefix (n bits) ------|------ Subnet-ID  (64-n) bits ------|------ Interface ID (64 bits) ------|</code></p><ul><li>全局路由前缀（Global Routing Prefix）是网络提供商分配给客户、站点的前缀，通常 n=48，以前 48 bits 为前缀；</li><li>子网 ID（Subnet-ID）用于确认组织内部的子网；</li><li>接口 ID（Interface ID）相当于 IPv6 的主机部分，使用“接口 ID”作为名称是由于一个主机可能存在多个接口；</li></ul><h2 id="随机地址探测-1"><a href="#随机地址探测-1" class="headerlink" title="随机地址探测"></a>随机地址探测</h2><p>通过 IPv6 的地址格式，可以使得随机地址探测相比在 IPv4 下具备更高的效率<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Decentralized and Autonomous Bootstrapping for IPv6-based Peer-to-Peer Networks](https://www.researchgate.net/profile/Christoph-Mayer-9/publication/257305170_Efficient_In-band_Service_Announcement_Through_IPv6_Address_Encoding/links/54ad55900cf2213c5fe3be2d/Efficient-In-band-Service-Announcement-Through-IPv6-Address-Encoding.pdf)">[2]</span></a></sup></p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202409061604399.png" alt="image-20240906160425653" style="zoom:50%;"><p>定义一个 P2P 网络具备唯一的名称为 $s$，以及哈希函数 $h(s) \rightarrow x$ 可以将任意字符串 $s$ 进行映射得到 $x \in (0, 2^{64})$</p><p>地址探测过程：</p><ol><li>应用启动时，计算得到应用的 P2P 网络的 id 信息 $x \leftarrow h(s)$，得到目标地址格式为 $a = pre|sid|x$；</li><li>节点向多个全局路由前缀的最多 $c$ 个子网下的节点发送 UDP 探测包，依次改变 $pre$ 的值，然后探测最多 $c$ 次，保持 $x$ 不变，直到接收到响应；</li><li>接收到响应后可以与目标主机通过特定的协议进行握手；</li></ol><p>对于每一个这样的主机，在完成握手后设置自身的 IPv6 为同样的格式 $a = pre|sid|x$；，以 $x$ 作为接口 ID；</p><p>如果设置失败（通过邻居发现机制发现子网下具有相同的 IP），说明当前子网下存在运行相同 P2P 应用的程序（也可能是小几率的碰撞），则以子网下的地址作为引导节点接入到 P2P 网络；</p><p>如果节点的 IP 设置成功，则启动一个 UDP 服务以接收其他节点的引导请求；</p><h1 id="单一引导网络"><a href="#单一引导网络" class="headerlink" title="单一引导网络"></a>单一引导网络</h1><p>另外一种自引导点方式是构建一个“引导网络”用于节点的引导，Michael 等人<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A Generic, Self-Organizing, and Distributed Bootstrap Service for Peer-to-Peer Networks](https://link.springer.com/chapter/10.1007/978-3-540-74917-2_7)">[3]</span></a></sup>提出的方案中包含了两个模块分别用于<strong>引导网络的初始化</strong>和<strong>提供引导信息</strong></p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202409091711294.png" alt="image-20240909171126247" style="zoom:50%;"><ul><li>BootstrapManager：负责进行 P2P 引导网络的初始化；</li><li>BootstrapStorage：通过分布式存储的方式来存放引导信息，降低所有节点的存储开销；</li><li>BootstrapCache：存放某个 P2P 网络的路由缓存，简化网络的引导过程；</li></ul><p>另外一种单一引导网络是 Universal Ring<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[One Ring to Rule them All: Service Discovery and Binding in Structured Peer-to-Peer Overlay Networks](https://dl.acm.org/doi/abs/10.1145/1133373.1133399)">[6]</span></a></sup>，同样是构建一个 P2P 网络用来引导其他应用的网络，但是多了一个要求：在加入引导网络的时候需要一个类似 SSL 证书发放的机制来给节点发放证书，用于验证节点的身份，更具体的内容就没有看了。</p><h1 id="基于区块链的引导"><a href="#基于区块链的引导" class="headerlink" title="基于区块链的引导"></a>基于区块链的引导</h1><p>基于区块链的引导方式是单一引导网络的一种引申，公有链作为一种可提供公开读取服务的分布式网络，那么也可以将它用于实现 P2P 节点的引导</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202409091416049.png" alt="image-20240909141603762"></p><p>DIBDApp<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Decentralizing indexing and bootstrapping for online applications](https://ietresearch.onlinelibrary.wiley.com/doi/full/10.1049/blc2.12001)">[5]</span></a></sup> 就是一种基于区块链的分布式文件框架，它提供基于区块链的自引导方式，同时提供文件的上传、下载、浏览功能，算是一种 BitTorrent 和 EVM 区块链的结合。</p><p>自引导功能的实现：</p><ol><li>在区块链上部署名为 BootstrapTracker 的智能合约，其地址作为应用的标识符。智能合约提供 <code>join</code> 和 <code>get_node</code> 两种方法，分别用于表示加入应用网络和读取引导节点信息；</li><li>服务启动时调用 <code>get_node</code> 方法得到已注册的引导节点信息；</li><li>服务内嵌 BitTorrent 客户端，通过引导节点信息加入到 P2P 网络；</li><li>如果以引导节点的身份加入，那么当前节点也调用 <code>bootstrap</code> 方法注册自己的信息；</li></ol><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://networking.ifip.org/2009/Website/proceedings/networking/1569173039.pdf">Decentralized Bootstrapping of P2P Systems: A Practical View</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.researchgate.net/profile/Christoph-Mayer-9/publication/257305170_Efficient_In-band_Service_Announcement_Through_IPv6_Address_Encoding/links/54ad55900cf2213c5fe3be2d/Efficient-In-band-Service-Announcement-Through-IPv6-Address-Encoding.pdf">Decentralized and Autonomous Bootstrapping for IPv6-based Peer-to-Peer Networks</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://link.springer.com/chapter/10.1007/978-3-540-74917-2_7">A Generic, Self-Organizing, and Distributed Bootstrap Service for Peer-to-Peer Networks</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-IPv6/">计算机网络原理 • IPv6 编址</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://ietresearch.onlinelibrary.wiley.com/doi/full/10.1049/blc2.12001">Decentralizing indexing and bootstrapping for online applications</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://dl.acm.org/doi/abs/10.1145/1133373.1133399">One Ring to Rule them All: Service Discovery and Binding in Structured Peer-to-Peer Overlay Networks</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/IPv6">IPv6 - Wikipedia</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;毕业设计相关的内容</summary>
      
    
    
    
    <category term="Research" scheme="https://decision01.com/categories/Research/"/>
    
    
    <category term="network" scheme="https://decision01.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>甘孜州五日游记</title>
    <link href="https://decision01.com/post/b5ca29f5.html"/>
    <id>https://decision01.com/post/b5ca29f5.html</id>
    <published>2024-06-17T14:43:31.000Z</published>
    <updated>2025-06-03T06:18:22.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition info"><p class="admonition-title">锲子</p><p>这篇游记本来是没有打算写的，过去两周后的现在还是觉得比较值得回味，所以就简单地记录一下。</p><p>原本预想的是把五一的假期挪到五月底跟着研三的师兄们出去玩，结果去新疆的师兄们行程太长，其他的师兄也没动静，就变成了笔者自己规划的一趟反穿川西小环线。</p><p>在临出发之前问了一下在华科的学长有没有想法，所以这一趟行程就是两人一车。</p></div><p>笔者前面几次环线的规划都只是用高德地图画一下路书，然后查查途径点的店，做个收藏点就完了</p><p>这一次尝试着用 notion 来规划，发现它的整合功能还是强大很多，也算是趁着这个机会入门</p><blockquote><p>分享一下行程规划的工具：</p><ul><li>Google XML 路线绘制与导出：<a href="https://www.google.com/maps/d/">My Maps - Google Map</a></li><li>高度图生成：导入 XML 路径文件到 Google Earth 后可以生成高度信息（这个便于看一路上的海拔信息，特别是在川西这种海拔落差比较大的地方很实用）</li><li>路书绘制：高德地图</li><li>整体行程信息汇总：Notion</li><li>天气、云图观测：Windy</li></ul></blockquote><p>通常的小环线攻略是三天的行程：成都-小金/丹巴、小金-塔公-新都桥、新都桥-折多山-泸定-成都</p><p>考虑到是头一次走这个路线，就把行程反了过来，然后时间长度从三天放到了五天，让行程不是那么紧迫。从最近两年走环线的经验来看，川西、大西北这些地广人稀的环线的收费景点都大差不差，风景都在路上。所以一天计划 200 公里的行程，在路上的时间六七个小时，多留时间边走边玩是最好的。</p><h1 id="Day-01：成都-—-泸定"><a href="#Day-01：成都-—-泸定" class="headerlink" title="Day.01：成都 — 泸定"></a>Day.01：成都 — 泸定</h1><p>🛣️ 车程 176 公里（成都 - 泸定，3 小时 47 分）</p><p>为了避开早高峰，第一天早上六点半就赶去成都东站。凌晨的时候还下了不小的雨，出发前也在担心到了川西会不会也是一样的天气，一直在 Windy 观察最近那几天川西的云层变化。去东站的路上也是零零星星有着不间断的小雨，有着些许不安也还是冒雨出发了。接到学长的时候已经是八点多了，尽管早上从龙湖过去比较早，也还是在出城的时候赶上了早高峰。从东站直接导航到泸定，沿途四个小时的车程有一个小时是在绕城高速内堵着。从成都到雅安的一路上一直在下雨，沿途经过新津、浦江过了雅安后雨势才开始变小，直到穿过一段长隧道走出盆地的“盆口”到了泸定，才觉得天比成都亮了许多。</p><p>泸定已经属于甘孜州境内，下高速后到加油站发现加油还需要查身份证，或许是因为一些宗教管制方面的原因？第一天选择在泸定落脚主要出于地质方面的考虑，在查攻略的时候同时查了一下过去在泸定的地震震中大多数时候离海螺沟比较近。虽然海螺沟作为后续的途经点，但从这样的层面来看也不太适合住宿（很难运气背到刚好遇到地震）。另外也没有选择直接到康巴，因为第二天选择了从海螺沟绕一下而不是按照常规的攻略直接到新都桥。</p><p>泸定县算是从南边进川西的一个必经地，大多数路线都会选择从成都到泸定，然后再开始分出不同的路到其他地方。它也和其他在高山峡谷地貌下的县城一样，整个县城依山而建，宽大的河流从城中心穿过，整个城市根据峡谷的走向呈现一个长条形。穿过泸定的河流正是“大渡桥横铁索寒”中的大渡河，这里能稍微逛一下的就只有长征纪念馆和不远处的泸定桥（10r 走一次单程）。</p><div class="admonition note"><p>川西这样的藏区能看的离不开两类：红色历史和藏传佛教。所以也正如前面所说的，风景都在路上，中途的景点都是暂歇点。</p></div><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406192336618.jpeg" alt="飞夺泸定桥纪念碑"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406192336932.jpeg" alt="纪念馆内雕塑"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406192333325.jpeg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406192336774.jpeg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406192336065.jpeg" alt></p>          </div><p>一个小插曲是泸定的酒店电视里内置了一个定制的安卓系统，不能投屏也不能登录账号，最后还是花了 20r 买了一天的播放权才能看。</p><h1 id="Day-02：泸定-—-新都桥"><a href="#Day-02：泸定-—-新都桥" class="headerlink" title="Day.02：泸定 — 新都桥"></a>Day.02：泸定 — 新都桥</h1><p>🛣️ 车程 235 公里（泸定 - 海螺沟 - 康定 - 红海子 - 新都桥，5 小时 30 分）</p><p>这一天按照计划正常地出发，上一次每一天都不在计划之内的行程还历历在目。留出来的时间比较多，所以觉得直接从泸定上高速到康定，然后转到新都桥太乏味。所以选择了从泸定先到海螺沟，翻过雅家梗垭口再到康定。海螺沟内有一个名为磨西古镇的小镇子，在这里可以短暂停留参观一下教员在长征路上的故居和附近的天主教堂。古镇的话按理说会有一条古街之类的可以逛，然而现在所谓的很多古街都比较商业化，就没有再考虑在这个镇子上多逛一下。</p><blockquote><p>海螺沟的名字由来：在没有查阅资料之前，因为看过了附近的地质博物馆，所以我还以为是这个地方发现过海螺化石而得名。然而资料上有两种不同的说法（摘自百度百科）：</p><ul><li>明代时，<a href="https://baike.baidu.com/item/唐东杰布法王/15727846?fromModule=lemma_inlink">唐东杰布法王</a>在泸定帮助工匠完成泸定桥13根铁索链的架设，后取道海螺沟翻越雪山，夜宿海螺沟冰川巨石岩穴下。早晚在石穴前念经，面向贡嘎雪山跪拜，吹海螺引来禽鸟动物听他念经。法王离去后，曾托梦给他的弟子，说贡嘎山神已经以他的随身海螺命名他经过的那条深沟为“海螺沟”。</li><li>探险家、登山者站在冰瀑布4300米处，居高临下，目力所及范围内纵观海螺沟冰川，整个弧拱构造清晰明快、对称，加上细碎有序、呈辐射状张性裂隙的点缀，巨大的冰体形状像一只海螺，便有了海螺沟冰川的称呼。</li></ul></blockquote><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231025191.jpg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023128.jpg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231027178.jpeg" alt></p>          </div><p>经过康定到新都桥有两条路可以选，常规的是直接从新都桥翻过折多山再到新都桥，绕一下路则是从康定直接往北走，经过康定机场后再走小路到新都桥。在海螺沟参观完教员故居后发现时间还比较早，所以直接导航第二条路经过红海子后再到达新都桥。从海螺沟出发后经过红石公园 —— 河道中的石头呈现红色而得名，石头表面的红色来源于附着的一种地衣藻类。不过因为前两年地震，能看到的天然红石已经所剩无几，基本上只能看到白色的石头堆。此后在翻过雅家埂垭口后，经过康定市。在到达市区的时候是中午，而出发前的攻略没有计划在这里停留，也就没有查能吃的店，其次考虑到停车位不好找就没有在这里停留。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023151.jpg" alt></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231335660.jpg" alt><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023247.jpg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023168.jpg" alt></p>          </div><p>红海子是康定机场附近的一个高原湖泊，海拔约 4200 米，又叫加呷腊。被称为“红”的原因也没有确切来源，有说法是在夏天湖中会生长着红色的草，也有说法是对面的雪山在晚霞时分倒映在水中而显出红色。进入需要每人 15r 的清洁费，然后经过一段炮弹坑之后到湖边。湖泊正对笔架山雪峰，天气好的时候还能看到不远处的雅拉雪山。不过当天在红海子的天气并不是特别好，也只能拍到正对面的笔架山。附近还有另外一个早已听闻的湖泊 —— 木格措，学校里的户外协会偶尔会有去那边的露营活动，不过我苦恼于置办户外装备的麻烦就没有露营过，或许以后会有机会吧。</p><blockquote><p>在这样的高原地区，有雪山的地方通常会有由于雪山消融而产生的湖泊，它们通常会被称为海子、措。</p></blockquote><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023187.jpg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406230011498.jpg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406230011928.jpg" alt></p>          </div><p>海拔 4200 米的湖泊边上风还是比较大的，所幸穿的衣服防风还是比较可以，拉上拉链后走了一段时间就适应了温度。让我没有想到的是学长在这个湖边上没有一点高反的样子，甚至还甩开我之后很快地到了远处的山丘上（我：你这样显得我买氧气瓶很蠢）。简单地参观之后时间接近下午两点，我们就在车背后的小角落里搭起桌子随便吃点自热食品。可惜这个地方天气不好而且风大，不然就有机会搭个天幕在湖边坐一会，想来也会很惬意。从红海子出发不到 10 公里后翻过雅拉山口，驶过一小段有着“薄雾”的路之后霎时一片开阔，在山口处的云雾被大风吹散。到这里，终于迎来了川西的一片晴空。山口下正好也有停车的地方，下车后才感受到这里的风力之大。下到下面的草坡里不到一分钟的时间被风吹得发抖，所以草草地拍了几张照片后就回到了车里，继续行驶到新都桥。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023229.jpg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023211.jpg" alt></p>          </div><p>从雅拉山口出来，在省道 434 行驶一段路后直接转入小路。还好的是这条小路上没有什么车经过，不然会车不太方便，在驶过一二十公里后进到一条双车道的路上。随后转入 318 国道，到达新都桥。到达新都桥的时候是傍晚六点，天色还特别明朗。不过民宿正对面的贡嘎雪山被云挡住了并不能看得很清楚，于是原来爬到民宿背后的观景台的计划就取消了。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231106030.jpeg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231023265.jpg" alt></p>          </div><h1 id="Day-03：新都桥-—-丹巴"><a href="#Day-03：新都桥-—-丹巴" class="headerlink" title="Day.03：新都桥 — 丹巴"></a>Day.03：新都桥 — 丹巴</h1><p>🛣️ 车程 207 公里（新都桥 - 塔公 - 八郎生都 - 木雅大寺 - 丹巴，4 小时 33 分）</p><p>这一天开始往后的行程就较为单调了，没有太多的景点，在到达高原之后的风景都在路上。从新都桥出发后一个小时的路程就到了塔公草原，因为塔公草原的风评不是太好，所以我们短暂停留后就往八郎生都的观景台去。在塔公草原出发一公里左右就转进小路，途径姑弄村到八郎生都。塔公到观景台这一段路算是这一程最为惬意的一段，路旁有一条清澈的小河和大片的草原，后视镜里还能时不时看到雅拉雪山。在进观景台的卡口买了门票后，进到最后三公里非铺装路。路途上有一些低洼如果不注意还容易挂到底盘，这个时候突然庆幸当时多花了几百块装了底盘装甲。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231408356.jpeg" alt><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231416538.jpg" alt="SONY ILCE-6000｜210mm｜F/8｜ISO 100｜1/640s"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231416053.jpg" alt="SONY ILCE-6000｜210mm｜F/6.3｜ISO 200｜1/2500s"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231416827.jpg" alt="SONY ILCE-6000｜119mm｜F/8｜ISO 100｜1/800s"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231414782.jpeg" alt="芝士土拨鼠"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231409726.jpeg" alt></p>          </div><p>在这边停留了大概一个小时后也觉得差不多了，回到塔公吃午饭。选了一家之前看好的有一些藏餐的“尼泊尔餐厅“，在塔公寺门口位置也比较好找，到现在还在想什么时候抽个周末再去一趟塔公草原吃一吃他家的咖喱饭。吃完午饭后随便逛了一下塔公寺，又驱车到了木雅大寺。这两年出去这些寺庙也逛得大差不差，所以在木雅大寺只稍作停留拍了一两张照片就继续前往丹巴了。翻过一个垭口后基本上就是长下坡路段，途中还经过了雅拉雪山观景台，貌似在从雅拉山口出来后一直在绕着雅拉雪山转。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202406231433605.jpg" alt></p><h1 id="Day-04-05：丹巴-—-都江堰-—-成都"><a href="#Day-04-05：丹巴-—-都江堰-—-成都" class="headerlink" title="Day.04 - 05：丹巴 — 都江堰 — 成都"></a>Day.04 - 05：丹巴 — 都江堰 — 成都</h1><p>🛣️ 车程 273 + 93 公里（丹巴 - 四姑娘山 - 都江堰，5 小时 50 分）</p><p>后面基本上就是返程回成都了，早早地从丹巴出发，中午到达四姑娘山。相比于去年7月底的时候，这次能看到不少的雪。</p><p>（待补图）</p><p>在双桥沟转了两三个小时后继续往回走，Day. 05 回成都之前又去了一趟映秀。或许以后从川西回来如果有时间都会在映秀稍作停留看看，而且在这里总能在不同的季节买到不错的水果。</p><p>后面这一段是在临近8月底写的，假期里刚绕了一圈川北、青海和甘肃，回过头来发现五、六月中旬之间是去川西比较好的窗口期，这个时间大多数雪山还能看到雪，也不是川西的雨季，也能很好地避开人群、车流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition info&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="杂记" scheme="https://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="游记" scheme="https://decision01.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>新时代淘金：数字货币牛熊一轮游</title>
    <link href="https://decision01.com/post/58adb9d4.html"/>
    <id>https://decision01.com/post/58adb9d4.html</id>
    <published>2024-05-21T16:02:50.000Z</published>
    <updated>2024-05-27T17:11:39.267Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="155b662229f2d9c18020397faff07e1d5d5ad2ca3b1d7836d8df5dcf1a42d915">0515815a90f71d2e69c573efde1c8119e11756a259a45a05da84968fe21b60f5ebb9d9e79c495841ecd37137e644752b95910b7ad710a4a1a30f4e9bd9e53449e2f0849a09ddde8725219cc521b247b6f79d99004148cc4fbc3b90ac2df3385eb30d4523ed1fb5a6544da48a70173f5aab4911f735bd3ef107e6e575d611b2477cdbcf313b4961092aa37143fa78a913415ef2fd905878b6a86726b1186d14f5cd9bd94db842bcaf7639dd9f6d3c62c86be384a2dcef6f5709fcfe7bedc5c396828ff6f118a41a355b62560e472d857db6098d1193fa438546a994f08cf3ca40c641597a592a7a06d2d639f7680e30b30c05c19ba720c0edb164ea5196c0becb1e77142fa9b55150d5b1840e38a7c177eebf1da7b36c9a331dd8e2700e729a8e0391235abecf513622bb04a5fb11a73ed1e13d9e65d407b34e308824581a01e1da66ed294eee13679c989da72022412b74d9f2a323b61373f8a7ed09aa564338dd4cb9b95314f434ec001163c512f8f73691a661ef8eb72353e76b2f42f9929d81026752e493149add1cfe80365e0141a9c249da5b79c8220db45cadaaa153681dd72145f4916877766ea9e84d515000a37eecdc6c6ef910bf45abe7b029e9e22679a44db64c337ae3519c7db72cbd77cb371c42e31c89de957d3f39aa802a9e53b13dfbabaecf6d73fb6b5ec4d9b41c4dff6cec5b96d49468b0718eaa578adc237969c5838dee91e8e99f9fe5593f6c48fa7fd8a0614ad8f7a8c58bbaaad1c97810cfa82d2c39d1b9567f10d25e446f7f6a1886dd984910f09f634a8952861c7e642af633356af048f5db241e228c2a26fab601d1f6f22e039ed02dd2c1f0906e04e41eb747ac5db25952d334d7cf9eb34373ad45461f5c5d20b58b66620c9ebe6f7f7cd09cc7c2d969b42f881552e56061e8aa97d1703091f69f6ab1eb7e4b72d409bc7ac5502b37d694f5770a0a756041e986f2fc6f6aa4581086ee3bf26173a913f5edf2d17aea4bb45c6a75067d22816b3a82467ad04d9f861cea61ea0a5589f589087f9834957eddb726f3145d786fb1d4ce5d087a19db466a4fb9ff04ecbb286e6a7c9f2558352f335e84c12fa32878ce38fb6fdfbc88879c4a24422f48cf609e7a046d6d640523576346475495c9964bcba844a161e5e69cc3f1f91720495ce40f5ffd3dacfa3a621a9e0605fa2e5d1f8bfcb5e5acb2fec6871d46ba2d5c9ff6bbba9c6c9026c7e8ef046612aa500709e9a90c047edbce0a7cecf543177694c35697db1d961f5fa27e0bc14c296e572719ab731c6ffb4cd94996381046019d49e31cf62428f226a03cd60c6a20b0863dc755c79e2abfa180a9d9f84f3e3846b20b67b1ae13c5c1827f1eda9fe160011dc1a806d923c1a43f1a447da82bfece5088b22c11b073b96a3a1c5724d5cd7befdc9d0e4d87e117282b1f4a7e76c2223f84e04e0bbcd0b02f5c59267daae5396fa294df0d0b96996b9639a6987e3e10828b536b462653692209375e7d7733df90dfaa9140b803d5612e2e7219864596926ea75a7721279e88a58aac43fd4c4a8fdce4f1fc1d570745123d82a4f9ae645303862b20d2c231794fa7609c32686c7a6b118630b5b78af51daf2837013471da2d012d20472460cf5ff0d79281ec5fa4cb52c7aff281dc690b4606b4073d742eada12abbad41f5e113aa8b47421fc2625696180310c73cf30726b310586f7494605d326da472b565c63ca7bc5628f677a888efa98bd4d22a1281452d212d1b68f003d66d67f71b153a3f5baa1c744221861f9d299ceab020c2fac67a806006c825e8fecbf30b111fac745a69c6da5f6afb67ea300994c2471e574dedb4fecf01d3742f699d0c6d2d9f080c4738e7082f1b737fa60e76ca757c30c5e0a2b0fd6e742e4cb04600e125a642dd168bf3d07303cba26213f3c89316430c78ba3d9285101e4b20ccb2fe6ee6f8edd9dcaf7aad15a8dfda7dc92b49c5eee9757f797f8597fab3a7f9997c4fa5587b7ab22bd0bfce6749d811b917bf78d19c0475f36afe8cf38663a5a25dd46d926de3a683c5fa54be3968e78a8bdb742b95d415c664c0b2faf64b050bebe45f57161a2a0751b11288cc0db465ea6582cf8a5109750edfe2ecaf7a1ac7c76f947eeb4c346e24f2e83547a60157849235091d8727d1de7ff65c66cc4154832f579cca1396c6da696687deebc66c3fd794f31e3ea79c1a311b1fc9b7ed82b2d0be637845580dd7790c198387a0ae5a968ff4ea337bfebc28b0d310caacf1beb47d2d4ce28c7b3253bdc878bec8b905c787dc050d186b29bf7bb96f83d794cb8d4140d5a3523a25a63b22517c3c1956ccb6f15655d98d20c2942420a71303405a7a810e48237c06e6c1793db72bb57d1d06bae9757ce38765c45cec5dc7ba776f0f21f2c44ae004a251637520429fcd9f99845e1670c76d3e83ccdbca80406d193c6fd75653c35d2c72b4270c80b1a988da083172531df56bba305e19972caeb209da5c76b9256340e8057918c60b2ff31978c05581ab8d26303407270ee94ed3544d61cba42b6b1162fe83d0b729bec3960f592540e32734279e8cd90108efe93ce81c787939f0643901cc06d94e0c2e146aa55c93be84fecfc12f74e0cdca8c378e3519b9ce6d78403f94236ff7ecd44e4e679c3658e6a0ca21850421c9ef8e80c1094a538293b7fe4896d8514cbd3ae14d769f034383c13123adc98188ea3f600381163603a480878a832c9dc3957af719ee5fe5989c07c1e3f549215483967bed8b77f5d0024ccdf94e2056d0c359458cde5494aedd9a3276928b74f57ffafc8131c85ca5e4da132c3f6bc39c454751a425a6062969fc3d63b51d1f5a78d4fdddee7c2cdf0f0f93ad584460299582dfc0a72dd4b7ee7f2bba6472935557daa01fac8e125ad01982484bff489480640972d0bd6436e1c0a32cd74f5a12687cc2435ed160d3a83a239ef0927ce459a188ed778442fdff39ff13a301e7f9b082362001425e444d6a221ee017394d8c68e69378b5695a2cd1f9f03da2bc8b4691b3b28685b7aee61bf8ed99ec2c4a4350971c9eb681a64a6e99bd83d782862e322aff2e95508966772e927235c226981bfe6d77296f6f9ccc962aaa63cef1a7112678ca5e711a823e3e3fd03131d21701893e8189ddbbb331e3ac7b2c7941a8f39ea0818cc711fe2a1dd814d5697bdd461cd522f1ac2fb3e742f29f53fec03e3a7c50d4eb05d731ac9a49ae6d59d3c4fae542c1dabb448a2b34d9d69d27089378e8b44399cdb178228f00856878f3b89a4af30b1da324fdc3ecaff3fe3d6bde745696b1c7306660bc611ed4026230add910ebe40e37b3a7efcba9429e3b238613c7f5c5ac2549863b299dad749126e5a9cd72553b5f16ce585e7896ea4189554793b267359d8d92548918d6c124890d3b31e724fa21d0f25407ed88521094ffdb59da5144c2f83b413af07adb16b6f4b669a976ee6954c1d2609eb037de4d742ec3310b2ee016e1a3609e08feb268840c285bf2cc40886555be853a752353768c4dfe3730ff0996796d4ba6abdc3f9e5730d314245434d271809c7e02a3023ff37964169aa43032d1f034dc561f9bea65668b0b3279e5cfd1192ec9681bf8651dcbddb516932192b244bb00060b0afd2547274a2b39351544965d78a21534bc03c7ba115a696415713a029427441347470546d8e9c551d1f7cb18ce942fd64fdc5c6b9bf9aeed34b0148f6937c06ea9877be4a7f8a4f4692f4ab546bf309e0a6a5e057e4bc7cf430f03653ed089513efff806a8783e1591aa7aa09d6ee6a8425cf189d8115c6cb551347ccb9637425857ecf7cb96273aea2afc19eb959f880948e8010635df23d40e6e958a8412daf2953e87d30c03eef513759beab8221978e0c50a37bd3d5b0d7b1b5f15bfda5401e938f32089c4b0fbaa17f43cb1eb9bebedd3309cd48f7c4fb4a2aefb4bb75d13abbd168b9e29db8aac2612819d9c7efe0e498f8277795c1050742c678d02926c3f2e663802f17a238e1ef3bfbf8fe8b4abbaf0bf114e3a737a7e032f8e18867005b0f36b8250712376ddd067289e638ab57d66b83ea89a37f2d1123e37753b83c0092af2ef5b9b2bb06aa90daef1e5ebdf56c0a53716b07922982106d47425f173a7f9a8772a1d94e4c691754c3f7fd6dd9d3f9da0796325faf40b590342d18d59ffe792628edbd33056574667fa31df6185207656ef860e1730f161ad648847459518f57a5f085992cb66ce62c9eaba0ff13e0c6cb9ffb410b3765e57463c43d0a6b960a8165b9f89863f48ab7d045835d40408e1c4e30362b69cadfa5bf7a6b21983c5178c0d858df1ce2c82a7c509485a05e599325eb749a34a194b59242a883f075166f4b84eade6b7d16a95cefc794f57a33e90001ed86fafdda82cacdbda7a6d0b25f5d0284593438affb6abc249f4d90565ac8f215406b99d6359e7bafb1c5146ec718dd5272421c8763125e01e975ae4608b0f973975e9abc84ba4c4dd95ee9246ab628cd09d62d497a299f4228972417f3934aaba5f473697473e6d95d57b74f5b409b04e7cc8b1a8b42bc63e5a0368254209f7852c48f0b9dcc20e63397dec03f1d58cbbe07eade892ea0f2563d2be29bcd5c3ff8aa3850f09259452be446257291dfebeaa8e139c0acc49cede7229543aed5d535306199962cfab354aee4adee5fdd45aa0d0a2748a81e820c2392a74809d338b0e10923a60b60ff2dd52b4320a0e78d30fd415094740c12d04d7a2586d034c07b47621255491b7ba2557e29b843aa2abaf07b08d77a16bfe1eb4a05f26bc7183f56f60f457385b69406587f874abaf31f50be1abd2375ea8f3f8dd41d7b0e1990c4c347521bb06d5f0d04c513206be4fffa074dff9f01823fe02e2e450bc7ce385f6d4dcfa303f16c3ad6e39ba866065acaef98bb9584482d89beb703c78e45d81c75e4df6abae97006f0fee8f3471703888fdbf55d8966b95c1b2736b83f81a367ee1435fc74cfe96bd885f8468cf9283699e7819167735b3fb1d808e5c270116c4cc8b97845cf77e59108f3f6fed17fe4e9689fcc08759bc4b64166ecf92d971d87dd1e2d0780efbd1426e0b9e81daf506b828b1f42cd95b34f0a5a3219e9fe39932e86e3bde9026e0ae8eed49d3c3aba7f95c9713433bc83da122e2bb5937d1963a3200250765a08278198c96f7b70accd6378a5971e897a092d3886d7aaa2d1547ed15d2dc4ed53e33f26fd8d7f261b914ad80a0c07ef6d1e7c4c626d8a353a87806f68c769298533ec0f6c4cc24ac5d68ec7de675b070c5345b8d9cedb3a2806cb88b630dee0fe1402494cdc5cb8ffbc1817e34476c8da8adbedcc1138671bf910154212ebba09c26997951fa55c7583c555d4c071ac3648e024479d4304fad061fb0399efbe3c16ea98d6794688288b6cb28d2cdaa317ad3e0302957c6cda479a74999478d8fde34e587150b307789c4823c306142982de5f8e4d1dd8e85e06efeaa7269610ecba5f741592c0ebe0f2a2ec55a4bb8662ff1f19a15cdb3f25a2a02e2ebd5f0d2353cb7406f787f82617b87edb059be4abd892a4c0c018a51c09a103eaf08829bcdfee243762bf454a74ed7d89e369174588f655caadb57f9ef6b331acb48f76c0c3eb301cfa35b893ecbce62768e58378e7e962f92e0b7b46ee1b6c3029a2fd35d1cd489bc604aac3d698a50d6b252c971ed900414f9df6ddf6de8e65ac08125f560537ca99633b17a79a0df5eca7e918f876ff68b1eb7079dba39ff20828f7dc2b412f46d9a19ee66eec696361d4e0e4fdbd49aa23eae5afe456ba138607e2400fd5296cabb434b6e85b0646f4a294a8af42c8704f8471978ff4d472e19b17ed13db619fc296947fe1eb0fc95f68d8ba01d4bc0cfae02888505bb1e3211320eee6045e99f4ee5e5bd601ec32db85968be20d2364dddb0e77239a855e7f100ce7a16eb6205ea7381899a15478810f551c3c4ef2d87a63f1babb3d8d37c791cc3a6547241b400108a3ff74ff49513e4990e65ee8e33bfbee5fee536239311bebccd0ddd4af62da8477d0109f363518fc44620dcceb7887a7be9f119a23ab67f784e7610fd65c8f7f14be67cdd74a86c9057612aeb72c17bce5f2d41de18a50d55f96fde3324a6a22fa6b5dafbb26f3ad649f75952b76316caa71f64bd7a9086f9ca93baae17764b4c908cb91883e9379ca00c1ad169442f57620d467b82eca3eb170cddb47b2b8945f6ec17d424a4c4d74d83ba4eb96928fb173a7a67ca2921438593e16ea94d24619a0c48a5e441e2eee07a62c2ed801108d8fad6f346a7042c78f21ab338a644fff01dacf18a4b4bfbdbbeb92eeb1065c694426b5c75445eee3de5426c3bf18ad131fa78db55e561f3615227235419e28e6005385eff24494ffa0a8e4902d55692d473aa1dbbb7123a546f164c6b8315a949e5c160cefb53644e7ba9f0d7b3c2a695e1a956da345ba68e8d16931a175c3ed315a6c6fc009f484763de4e3a0d8cb0adc2b91f88f0b982b37e2f762124d93ca4c3110aa1d32025e81765dea128f0ef618493e966e0b00e9f8b547cd41e833f077e00b9cc9c4988195ecf254628641e7fd05a7d802e55c3534d4d928f69e09f25144a4c8bb368fab0b2527a7664cf41c468cfd713863f3fafd8d41bd9a89b275879e8b9924ab5b53fcdd73bb740e6a8e7d6677a97fe2ea96dbd27e6b8411b7ca158a7c2e591929080797824fadf884fc19d3d4bd723f67042d16c150483dc5e12159b30912dcead475ba359d0bdc4db2c255cd73f9bd57b9de04e7156a1302787fad5582e2bab72ad9a79f71009733ea0fd1702060ac6048702756e10131777b3269f4fb4dea2b6eeb23049d2fb7e945f837430efcf7d30b7ba063d6f3a876c3b1a53e5a56539aeaa57c8b96d4da325c90ee518b7be835e96eed8fe1d36f6e3805d26e590cd05117466da70f5a945ac6ab93a71944d6352ba8a381291f68b786b5f28b5f6a7a400fe906d515bb4b7a5311703ceabca65b17bcacce1705cc3a4d8377a1358d0c7c389caa7a0051d52a739962ad07f6154dfc47eda1f2fe3a2d452720a5cb7ebd8cbcbe653a76abfc8c15c80b35a160656d3498f8913113a8bdb36fea098d76c28b6164a18d7740ff2cfb952e3a3021a6cf303dc17d0095f18bb94748b0d02723bf0ee0057a9a9c81cb8af94eca1fe4798cfbe25fc883d3c8596ca301540a12491a9533a0d8b4c0d47c2c66fdcc40b9d7e5afa3d12a8ee96417ae6f2bb6ae8c3990074af7c3ad0e0e86c4a3f62922770db5eb165ce510ea044d9bc4988aae6cedb5fe12b1b0edd5fbe1b66665f0d499e58a16f7f66efa446011089fe2fed5909c9a7ec0f72a4428f1a487dc09186a6d52d1b178fe36ae6ddb67dcfa9e83c9a596dd0fbb7c14ce36b4f7e2c116bd3831a638aa71712036f9f0df66deb8432148832f6c84d506b1cca8e77e7c234a1a1c966ff840337a7fe2d66ad260ac9087f307f261a332a3cf900d5eadfa9704ce6e7e20ad97ccd7b980973b5d758af8cfbc4a06e78d817c5b394a0a599ceccbf0bc68f1a76f475be4b9a3ff829f57bba2bd87872af8fa05757eae9fe1a2e36aa0b49a138b8275f11d554f339f962c753123542f208c89dd5ce54222a218f2566397a88b8b1bc2dc5d9556ac6be7395dc35c8cce4e3f49b790acd61c42419a7f4cd177dcd3106babbfe81fda5cf62d1fa295dcb1d441c13a406217d2d0cada845ce6fdc39e3913000d6b0f962a89184fa2e1dca7e7bd72fc2515a346bef6ee73ec8a4d47faa423b69707a901cb5a1ed6261bff7e04caf6bb1cef58bff7613849596db9d780716124007d0dd517ac0cf5768f91d0943cb54378d8ec715fa412e647ed8a378017ca683bd00899a45b0dd2053d659bd32a388c88694926731ebb8202f8e542c5fe5d8173d74afcd594e6ebac5776524134c71608cc001e80c023e2b170a0536a5f807db5471291398bbfc846cb06e1ad6932411659e07f13f2c38cd68c62b4128a5fe5b048840960cb75e056d804268dfc27048b9dad1ff560ac0f4fea12e0a8f4a88e36520e3a75d257719649f5b08faf80f189655d1187165cf50a99de6630e148f56c86951548d95e2f464402aba4158fb7a473117d0210ee737913efc0e1b5c98ac2c2380b6ffd980b6fdd0dc7dd4182d686a94b7ca7f50a322de6237411ca7af372383a789cb2bbfa1610820c59d4bab9729f2bd87a277c2ca2c8afa67ba061eeb6bc2f009b5aca12bba880278624604f7df4f23d92450ab5a784e5f601190ef45093d2805b85eb90c8a8164c7bf75c12a3f8a38f4a0a2612c7c8225188773ea59442af8e408ae9342dfa69ab1d6b8820586bad50dbfe0923eed94731b0d12be9dbe259f27ef6be9e41418168bc9fe23e324eac97881bd74443fd9516a2d553636572864536afba985cc24380a5ad2012834b527f39461a1f0bd7a287889066b0eaaec0a7ce27d29141d6aebece637d73900161cd658425830f04d3e529e1bb1365a1a70d4b003a7238ed2ce41bbfab45c07d97c4d4357438ac858e1cc8c962bd328a059c416ec66fb2398f8d6ab1f4f75d73f8cc87f72af50aaacd97b41b47a6dcdf4f834ddcfa3c70aeb23ed2cd8e0cc82751bf6bbc97f65e448a19a47b3c0561e71d00c13c9a587d2edfaeb17109922d3c6a545fa4e51be1a8849c3dd2e81df472e17edb2b9def45d0b34f830705ff67213088324131e7c3eed775124bc52af92699949a1cab3fc7a32b1ca7fa8e516f9046a851e784f1e37d3f55470212e827d027ca99811bcf325116f11a6db66e0481c0efae0c6ef9a9c50f12f69f36c78f3e36115a06ef30ba69d480461afdfbdb736360fcdc630ae9874134f99b5848b2f8994dca4589a7c159fb1493b633b651a8e809d099e3bd4f4e92a9451e5abfc61f020cbce1f004307f0fb0cbc5e6ef75544b8113e0e2401770b89351387725dfa0d024dba33193af62ec2f3995f58c1916f0bf47fce66d14ceb1cd2eb70f1f4682419a32ccada15d6e236c41f588464d32c6a5124557a96fc8e6b7ae0495f4b3434982c94550e9e49442c0c069e24477daf5091d79db4d1223b0fa88d5cbf7d1350e2f7502d5820b9b24470aec252b9d39a36486b1ad65fa2e419b18d2bf4233b5b2db32804aacfdc41de64a548c505dc4998a15c06c9c7569aabfbf5b1f8b229f69057828c78cf545e181ef00677e232a9beb0a5838da96f7fa13dfcf15388352f02f538054792ba47d7a833e9140e681da8e3754cdc858a3d275318cf540933c8a65d059b4f7c2d11f1cdc248a9fc08c12a40870f913ed9ec31c9c9cea871dcf5f7de03c54f6245571030051fa2f6b858f52a8a5180256fb62038d2a7bd952df55c38a5d162c43e1c0ec746d687c57140b4b65d09160c18771fd0f26a78fa8ab135326291ead3e54f3a74ba56fb25952cd23b8a0f2bb8a1ee4b08fe4675eee00bdc5e5eb96e4ed54185291e794c9c829964999b73e6679f6a18263c604bdb8cbce73a0903aea19d62702a2bf2a7217f20de85164732ca7a7ecd3db2c28fbd6bf41ab519f6a0c18f3ac560736c66bb92cb6443bef4e74a287d4b62b961e1b0688322d2f8702fb44f1065e90cdc12c2ede6b91644c3da5cc9387f9d4c4ea5f910054782a2703e24be15707f460aa01105f588ce5d0b86c5a72dbf6c5cf1b4fb1d2254c16a590913b653bfe8d0cbea2d947e3aa4ccf67330b7d332116d7c111c5b18cd142ca5369d6d71bb16dcfc8706724a674fe6d74450200ba37b51440c26d7c90a0ddcc1130c1f094f6e8bfc24427d6927075a176d5c9a4034e2090eb2e2bc5b961b53c9760fd70cf2b17ef51b1fe58df68e052428ec05c5f432214bff3325725cea257bce769b80046958960a2eab52e41966273b1a71734db4f86ec1149a32b6f30e79adeec677b35b0277ceac3876d51b1ce6149a3e44fcbd061d54432b25bd913306adb9d8d62282b40b896800dc5b71baa45c8c576c6c7708c4e1399031980a15ecc773e3b4f50ec2e79a6271d07eacf51c5a30b5d4faa62d5bb5c7a8350faaeed89dc5e5b3e76575a560d2e3b2a2711b9de6c93e2f475f25a5cd41e9618367ae31d97b63b0381999d1fc1509efe52119669a70e338ca0e5bce20eef39e9d81947e2fc45e45e132eb80b6d3d1e3ccb8d2908bc4d344f305f8ad972bacdca7ceba988bdc89d7585e0e51c2382d7fa7ed7fe15782c632b4a8f16cc0d48452f5518c6058b2df0b57939e8e90429fc2f94f75b5e5111425b9a217d11c064a9aaa9f25083ad46c75f662b96cf990d5572bdc78d142c28e3e84639e1bcefa321a758f00d8d9068ed7bcd150e1e6d42f2b42c68ea91a47578a5498ecbdf2632f4277320433111a8ed875f6df710acf7fc2b65fecedbde3d47e57ce3bb9579f6d07a0a416695aecfb8f7d8b13ae0b164c213b08cf14957824cab4851dc1846583a1c84b7d7fd46529141ff280a2a20dc4e14af64bb9b1fae77b93854f94423aa85733460cc4cd2dae93c00ef4df0ec7ddc864622c565f7759e0a21dbcd003b9c1cccdc35b80aef8749ff5a6f88d904796cf8503d66f5821f3b9a0626e1057dbe2b75f0d3eabdaded785adb8954c698eb7280373c8a3124276531ca0f73eb8a786adef98d48d5944c8442b4511ba28e946048dd4742e2e92fde0774bc544a34c388f0af135276eb3686f189ae7a41b1efd019c1e27ca3ec5ded6de8de9da43235c87a80a373ca616690383e806ad854c742971b99d8ecdc0c69ef8db9c615ec401304e04be5cda469fbe45f15434c7ae6a4d0e7ed62cddc857aba9a1b104fb60310b869b80143d6413c9feb5f777d0088e60135684a824a96ba7c75277d60813cd88a86434dca5f6e281e4eb4fe3f7f4146479e2c0d67d0fb15d777e8af1bf008a754c5dbbf262ea3a258cc1e231404a57203d5daab2bca4e9033a974ba0cddea34c82627fbce156ca03b5d304165db39c3d9c7812b3af6af0d7bfac13f39bf70d474ea749f2937bf4a497695ddfbdbf7e531960334b7885928c627d6adb63e3972493b7096ec0b912faeee37296fa243d0f4445a2c22fc9d0581cb734c5af1bdd9196916762caf66523eae94cf745d22fd4e1aba1d649d8f299b6cd79ff4d2ce50b25262e7041050cf7c007cfa44d28058d2b02fbfddf2f2102afa11840edc08de3fdfd4ed79d31694f6e7175829d82af1686c948d880bee321b422879b2c06df56189e41f5194af46ca99e5193340f9c07630a5d7b078398163f28556241b592524d06674ae788408ba320c3f7b2be7b5a8a25b76db7efe97977351ff37918630db463f4a3532de72ecf21830ffb9443d3a212c39a714eaf99a6d6886f59b5e88eac6d453cfce97bac2d7dcb45e9add3a31a568d170b678e8de9504d3be6f6c2bb8ace6286979d1a6416ce461b736123feda05ad4a3a7ca1033d9980a099112a26fc965aa755a20b7115f8a7434a201b558785efbef824939d315936cf0bc573be4eff80f4e47dcdc897a423a10371f8461a902c78bcefbed38f9bd73934c11084fdd3ef5fb5c64f085933bb4144a6015cbaef64403a6052b48fa16982cef84c24e46ac8fb11841121b7b8252dc37ce920709c96dcce0f42487352bbea557fb6728b448e814f38a4df1abd0f2dc5daac758946069ba66cb80b83c282bdb68edb5805ee507d873fff234826a7a6d06ea3524460fe2b92b986f9150fa37bc45c8eaa8653b7886374acb1a3255ac0bb7b8d4bf234d31c038bb0df9b947243c9a840271a648269e7cd900fdbd89b49535539941c09fa3c91364375953e689b32c45b2aa2329adabea1da2929b79d3f978c03ccb93956e719fec2eaaed257917b86db26a40c1035d66aba02c66430e8d4a4c64bec0b1e1906b04f51a318ec3285777c16179f84bd3228a58d5231bd068de4155bb05fd8cbfaea06cd4b96978247726ab2b9ed95f6c8c264cbaab99b3c71ed21e97e0360783f14b39fbeb45be474c55242a00a5d85db0db3ec0e562482742f00c3a6ef9425761f04c89d552de4528c3549e68dd33d52a57d5aa7bb2ea5d037cb0a6a04d941dec713b46333f59a2623ae1b041d3bc91c0c5df8a22559b8c7666a200c18787af29e9a6f8bcea04e88c6aa48ccd75cbdd039ac8c0f63e2384ba9f473cc78a569d52eef88e8dcb0eb59f1121ca9c53060c2e7200da6e2dde8e5be0548154c1f68a595a3388d63bfa5e0d33f5c050f28cafc6def63933ef7af75eea86e79147c637b14f8ac55517197b9f2fccc95e5fe9fd6885fe9035c8848a7321a7977337d581e480129c58f214cbec7198d6f62bab0b2582f660edcdd5750e7d807a522f7e106099f8eff7c169c0fb1d6afef7e5bdd000a784f8249bf623a86652eaed0438003ac5af4345a64ba5d081f5dd4f7f94eae01a5a7dfa81d2e17bc6ec08c7fe28eca1fc3b627c2f613d3698cac0a242f3ff41d150375b391261baedc3738c98bdda7976e2b91a4a20ce684d6ee1add88e1d25c671f36fd5dadf0be6fc33d51be551260a0e788fc63927ae111ab49cf3a8b9e07c5472b85dd8314753c9f927f63174aeb3bf9e2f6f7b1d58a0debf865610fc29d889b6dd283c59ee9e68bda5b86afd86dd7d3a77ead025b99cd1651b87657e4ed8a0c97e7c0f161dac1936c0d9f82d305a3b33e8e514001c616e5d010d22508d1e6006b699cca1d1ceb40900cd7c979ad2bf5a1bc3b390f6d09918480fe520fae6e2553387c55995f864d99cc15009387412ee711d29563b6f57fad016ac4c7f29f7b3ac0636ddeaa00463ec37f54bcd54790197814039a2e960559ed25e3490dd8aa9aeb1e9854ea426aefe409fa40b14981cc921c0e01a9957ee1645187cdf80a86f28b7f9b44f901752f3320377228b743918337ae91d3b1d6f911946a9c30c6691ae74c087ccb059946127ac60fd69e500d55de17879a669737366e969368ea9dbbdf07a89d5657d30be401c440ff3be88f1a6c2376ad310fc39d8a251053e7e12235f6d11de97d786aebdb8bb196b59c3de1578c28e49a8d5868637b9a74fc53e55abb79569e49993e3f22e624f404693241d8c2877296d6ef496183c3de9326e608a07771cf21a98b0df6ab39dffc3c1627c063bcfb20092b52a6a8892895ce82038ce704db4587c9bbcd536349929cbcef4704918949211652b51d809f815cb1c8f7f6e70dafa8d623ec7507749f92f032b31f2df7737c1fe089d2a87f005f5474420a87eab970d29ba72827e1195cb46f56106563cf60deb17f2d7635761601ad4faacef813c9df3c8712b597cedd980432d63ff473f512636f1e7762464d363a99455bbea69867eb40d34d9c4960e6ff293abb5cbf56a48ec79503aad58c9410c98434d2d507acd85e7c93860768d4787d9c359daa2a3bd4c12f9032fc9878eae4eecd1d29031751386c436bd13b1aaf00a401cf2295ae3d560e06350bf74954daab23d65f763131dabdb5b1e8cce567df93a3548f29f306c97910ad997259826b5512aac73afebf00c1c595052f14c46326e716ba0ce16948a737f45d1a2e028b5fe6eebc0e93edad4f0f61463034735ade5da6a89ba94a2aa78bd80a85ecce30124f11e9b544ce3ad04381c4b339ba6409b956d9dca1574e9f518cb66a90a94c0733cd8ef35148a8c51ceae982d8f1b02b237e94dc77b61e6dc5c8653fcde755de672887fc878ff5a7ed62f09c1ce530e985e98c24eeb5a94755c991e3d25ff15304f728ae6e7870e7f83cc26d5da87a08a1662c9b1e78d242387cc1c20efdab54b93e8adb0b05436ce3c512b05038ac2400dc5c9262e60faa8dc22e0d05e90b43159b00aa5ba8a90c6070281055153c7b739299c19dc62ef6e138439cef87667c52f7fec5cf9906db2baf2dd4837bc9c99e244a0b39ca217aa38a5588ae661d346354fc988538770900c9da79c84dfa4515d2614b9854fea30ce6a3260647de47116686757b3c442bdc3ab5a52ced2973c6579cb123ed51d295aa3706251030f2372a87df7b21fdcd20a29074a79bd8f2d79ef9f0f8e6859d232d9225eef403777c68f1214c34bfcb224b49a852b9805ab0b7ef640da523405441e99078b5ee5ade6a9eec3c3fb9154233b42a03c484bd96432ce4210559e3168f72ba0a0b9a3fe0be4e1ee374bef4bac0bc51b89d87b67b0af65a3392c2c29ae2c4dffeb8527cf339d4b19f3d975e113269dfedc34e8260e500ac945edaeb4048e919936e1c04e784beecc7015ff46b1806b11ff1983cd3d281e74a76bc27b738775c29c6e9effb61e0590aed1f8ba05bd3d4a9328bc93973168b5d4a6aa250d2b6897f05d4009ba956d1c4869581958c2c57437a3894c915890097618cdffbb95bca39f11992ccfe4529a3ca75f12bd81a004c0bce92196380fb402e1e762d6d56cd8045e124fa57bfa62d2822cb216226e1f7f11e2b9ff37cf6a0598fd17c1b43c162080c51911d863994997e9d57ee3109ec15dd43a5ebb23cae6ee5be6d271d202cbfdefb7a4995b41050a2a0acb3cab06f566dfb3833984d062398a9dc9d9469225440d03378f0af534478fa5884d705f2511e8826f051166fc8dc675fbcbe86f47645171e9ae1e7dc724b00b140d89d5173f9f9e18213fd8b012897c1861d308ab295fa6da7c5ae78d5505a1cd7d3a60bbebc4a3ad13b7023c6e30518196e9f20d22583478c4e40ff7174cd0071c1f4073b1fbcdc1542b8ab89ecb32c4930be5082a1f03bb35c8b663f174a19ee710c8a4ee4bea388de9e59f0f52ccfa73039570a113a7fe7d0f7937d74ef1a7846f691dfdb0b791261662a9b83f3ec7f1951de72f4d85ad005bcba2a1ccc7f36a0d37aa2c01c010793d2dde66843211b8a09edc0887e5d3d28f6de979f89ce33b5aa0ccbe27b20c7f408efb9a71c6cc03f10e036278c143758f1ea9e9de51f627561a4114dc8af80221b48421a4022a7c15b89a32af0ae40fe184f2dcdf6747bc039b1770b1d88d37e38a35025cd4be9fd02a984ca049136f5d4f8aa496754e24fab41bd280c1b407b5fd73596145556d1951a93408d89551cea44d68951b98d00b7002c7a7c1b2562a2dce0e0b2ff3dd32f94d0917a86f7eb007eede877e345e564d9e32c3d9ed202ed87f05d59d455623c2daa4a2ad05e55eeee9253af5b2b50de118010e8d5297285f02ff54645ff2008b1227769729fb4181264b065d362b568ee09ee422f6851fe92bed8c63d5dc46b255873956d3c588a4a7104d24cd94c3e8af35272007b34ab737d978fe2b9b2213d1d9842006eac83d7a79f42859c41dfb3934471cb6215f1338fd4386b2a67bea35795c0989a1a4736b9835d860f0c38e0d87fb82f39678fb73b13fec17efd422465e6779e14a1ff310fafa63f9f11e68969d7a402611c51d6b61ea141d61c0d9510162099feb9d9ac287eaf7ef0b8b4803edf192c4b3804e1cf832c9e0a30e99a24ba9a7a4a91ba4b3767fd56131a01675c3a29dfa083e56502179e9a56c50de6f8a4660d9f71b88abf76386b420ddf2c4153c3c4ad757f67fb17c1663822b8968676b6c560b2826f72b072615a7803c739ad95f15f406ee3cca3e82bf95422bc3fcc8e16d13c753f76c5b487b17acf0616f70b709626f93dd3532c63518a410e8c4c3d7510870c9b694bb477b87b2a493453f5ee9f2609d64a675d9981f0aaaba30ee70e676e683e411d47e1cf83a0eb6c7fd23d736f32a9bd72ab06bfb86c68654bb6ea44018bfe508e3d69f507794bb3837be1a5732feb32ae96f75e86b879ca96ab3697f4c60071cbf8498cdd0390c8bbb272cf900b239aee9bcd44bed23b503428f3737a9392d033e135b2613877883bba82d00bd13a1d576e7b6901bb3b2afec9c32fecbfc31f4c1cc891e71b6192e6b5a1889948b9caf315960eda2d0b4d57eca41e9d8e09112a39676b9a9884afcec81b53a1c3d69ff045aaa05174b7ddc486507414705e6ed4759ca8bdfde8e239c6b9a1075d63a56f7c8dd288bd7b001d7100359209dc461820c2dfaaef15a88961b20770547438887bfa277558f0834abe0664343a22065543a83fc3e745bd690112b6a1b1be81685e8127442ca1734d757e4f6ac8f65bd00cb2860f205b2cc38e8716c688c04151ac26795d4b7e20db9b15ef6fa9a23efb3550458944f96d02b9916e28b35d3538d5299653e841f6a659e78bf18f9e18093ef0ddfb6b69a65902cef9e1076f619fd74dcb7bdd9411e294e9998e77f99298b44051b309b2cf387ab683377d22953049cc121862829bbdb79a5f6a75e777de988b924d1b5942c4b799c9670c4b2fcb54df30db174f21e4683b155448851b6ae4f42784080ecfacae121eaaa9be3d70cf25e7f7e1b0a66a22f2357e16b9958cbd80303bc30b4fe8bf4d0352c7c48cca6b9d6b87751ab4ffac0cc40ed174e99b21aa66a8dc7eaee65537ceb24a9ddb9c806fab8bc4671a226883dfa2b67ff89c99f152c5cc1d4a12ab5fe7436442c6c25b9971e0017fd13abe72d9c8c467f0c40d33e694682dc7ede400109849baaf160f2f6db43cf2b3b53cbb7d0dd0676e9c42422ab7556c9db9f37ae666ec5e5c5a81eb157a10f611d4a71b1f2edc2398cbae43a8211135ff81e0fe244a927e3298cebf4ba7ce5b09a353e0f5650939f41f3e00a7384a6df17b610b438bf99e292cec1be4151e58bfa9b2033015bbe6b6599506cf58e830649fa1307590ae4f5037da30cffc8755a4563ce853a42fe21bb47e7cf1deb588ef67d17d542836c64ca3ef16182a40d931aacb5ce146086fcb36b25e9d35bff5f7c27812f492415c3f9514433cf94b1b79ef28d48a482a04b6094659f6ddbdc8a9ebcfaa921b3dd998731ccebd79f6c7b1fdd8ccb01f8150669934a2073f4b24436831acb79a8e3e19b94386460710f982c4d9bd544287802da33a9ad55241157937be8018a78f40e50232ebe7df0188d00a8c0868f152bc2cded5cdbfe9c8fb1895abbddd8eadacf5be1ca772743d7d836979954bd941818d604a567d7eb2a60e986920012558855731fce1e8b221c7cebc9db2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Hey, password is required here.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">写在 Bitcoin 第四次减半后，回忆、记录一下经历的上一个牛熊周期</summary>
    
    
    
    <category term="杂记" scheme="https://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="blockchain" scheme="https://decision01.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BIP-340/1：Schnorr 签名与 MAST</title>
    <link href="https://decision01.com/post/b45dd1b1.html"/>
    <id>https://decision01.com/post/b45dd1b1.html</id>
    <published>2024-04-08T16:15:09.000Z</published>
    <updated>2024-12-24T15:00:51.192Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Schnorr-签名"><a href="#Schnorr-签名" class="headerlink" title="Schnorr 签名"></a>Schnorr 签名</h1><p>为了简便起见这里都用大整数取模运算下的方式来说明签名、验证过程，签名算法也可以同样地在椭圆曲线上实现</p><h2 id="签名及验证"><a href="#签名及验证" class="headerlink" title="签名及验证"></a>签名及验证</h2><p>Schnorr 签名的单一签名过程较为简单，它涉及到的函数只有哈希函数 $H$ 将消息映射为一个大整数，同时所有的运算在群 $G_p$ 下完成，$p$ 是一个大素数，$G_p$ 的生成元是 $g$​</p><p><strong>签名流程</strong></p><p>Schnorr 签名方随机选取一个大整数 $x \in G_p$ 作为私钥，在群 $G_p$ 上运算 $y=g^x$ 作为它的公钥，同时签名方为消息 $m$ 进行签名</p><ul><li>签名方选取随机数 $r \in G_p$，计算 $R = g^r$</li><li>签名方计算哈希值 $e = H(y||m)$</li><li>通过 $r$ 和 $h$，计算 $s=r+ex$</li><li>最后得到签名为 $\sigma = (R,s)$​</li></ul><p>这个过程表示为 $\sigma \leftarrow Sign(x,m,r,pp)$，$pp$ 是公开参数，包括群的相关信息以及哈希函数</p><p><strong>签名验证</strong></p><p>在签名验证方，它所具备的公开信息有签名方的公钥 $y=g^x$，签名消息 $m$ 以及签名 $\sigma=(R,s)$，因此验证方可以通过验证下列等式是否成立来验证签名的有效性<br>$$<br>g^s \overset{\text{?}}{=} R \cdot y^e<br>$$<br>在这个等式中，$e = H(y||m)$ 可以通过公开的参数来得到，将它展开，实际上是在验证<br>$$<br>g^{r+ex} \overset{\text{?}}{=} g^r \cdot (g^x)^e<br>$$<br>在正确的私钥和签名过程下，这个等式是必然成立的，如果签名私钥不对或签名运行过程有误，该等式无法成立</p><p>这个过程表示为 $\{0,1\} \leftarrow Verify(y,m,\theta,pp)$</p><h2 id="签名聚合"><a href="#签名聚合" class="headerlink" title="签名聚合"></a>签名聚合</h2><p>签名聚合依赖于 Schnorr 签名的可加性，考虑两个签名者对同一条消息 $m$ 进行签名，得到</p><p>$$<br>\begin{split}<br>\sigma_1 \leftarrow Sign(x_1,m,r_1,pp) \\\<br>\sigma_2 \leftarrow Sign(x_2,m,r_2,pp)<br>\end{split}<br>$$</p><p> 根据签名流程，$\sigma$ 实际上是两个数值 $\sigma = (g^r,s)$​，所以有</p><p>$$<br>\begin{split}<br>(R_1,s_1) = (g^{r_1}, r_1+ex_1) \\\<br>(R_2,s_2) = (g^{r_2}, r_2+ex_2)<br>\end{split}<br>$$</p><p>对 $R$ 进行相乘，$s$ 进行相加，可以得到聚合签名，它在形式上为 $\sigma_{12} \leftarrow Sign((x_1+x_2),m,(r_1+r_2),pp)$，即下列等式</p><p>$$<br>\sigma_{12} = (g^{r_1+r_2},(r_1+r_2) + e(x_1+x_2))<br>$$</p><div class="admonition warning"><p class="admonition-title">warning</p><p>这样的签名相加方式只是为了展示签名的可加性，以此来达到签名聚合的目的，实际上存在安全问题（密钥抵消攻击<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[比特币中的Schnorr签名](https://zkfold.ing/bitcoin-Schnorr)">[1]</span></a></sup>），不能在实际场景中使用。</p></div><p>基于这样的签名聚合方式，它可以被用于多签交易中，这可以使得多重签名锁定的脚本中不需要包含所有的公钥，进一步保证了交易的隐私性。并且也降低了签名的长度和所需要的参数，在实际的 P2TR 交易中降低了发送者的开销。</p><h2 id="Taproot-地址"><a href="#Taproot-地址" class="headerlink" title="Taproot 地址"></a>Taproot 地址</h2><p>尽管在 <a href="https://decision01.com/post/8a19da7d.html">Bitcoin 支付方式及地址类型</a> 中提到了 taproot 地址的生成、编码方式，但是没有具体涉及到 tweak 公钥的生成是如何实现的，这个公钥基于以下公式<br>$$<br>Q = P + tG<br>$$<br>其中，$Q$ 是 tweak 公钥，$P$ 是椭圆曲线上的公钥，$T=tG$ 代表的是脚本路径映射到椭圆曲线上的点</p><p>在这里，$t = TaggedHash(‘TapTweak’, P||merkleRoot)$，它对公钥和脚本构造形成的 MAST 根哈希值进行进一步的映射，得到一个小于 SECP256K1 曲线的阶的自然数 $t$，然后再将它乘以椭圆曲线的基点 $G$ 映射到椭圆曲线上，得到 $T=tG$</p><p>这个过程可以参考  <a href="https://www.btcstudy.org/2023/04/27/taproot-and-musig2-recap-by-elle-mouton/#Taproot-%E8%BE%93%E5%87%BA">Taproot 及 MuSig2 回顾</a><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot 及 MuSig2 回顾](https://www.btcstudy.org/2023/04/27/taproot-and-musig2-recap-by-elle-mouton/#Taproot-%E8%BE%93%E5%87%BA)">[4]</span></a></sup> 对地址生成过程的说明</p><p>最后这个 tweak 在进行编码后可以得到 taproot 地址，即主网上常见的 bc1p 开头的地址</p><h1 id="默克尔抽象语法树"><a href="#默克尔抽象语法树" class="headerlink" title="默克尔抽象语法树"></a>默克尔抽象语法树</h1><p>如 <a href="https://decision01.com/post/8a19da7d.html">Bitcoin 支付方式及地址类型</a> 中所描述到的，Taproot 升级中将支付到地址哈希和支付到脚本两种方式整合到了一起</p><p>在 Taproot 中，这被称为私钥路径（Key Path）和脚本路径（Script Path），脚本路径中的脚本通过默克尔抽象语法树（Merklized Abstract Syntax Trees, MAST）来实现脚本哈希值的计算，这种方式使得用户只需要给出单一脚本路径上的代码就可以完成完整的验证。而这里要说明的 MAST 的根哈希值，就是 Taproot 地址生成中所需要的 $t$​​，它参与到 tweak 公钥的生成</p><p>在这里，考虑下面的脚本（也是大多数讲解 MAST 的文章引用的脚本，它来源于 <a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[5]</span></a></sup>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_IF</span><br><span class="line">&lt;Alice&#x27;s pubkey&gt; OP_CheckSig</span><br><span class="line">OP_ELSE</span><br><span class="line">&quot;3 months&quot; OP_CSV OP_DROP</span><br><span class="line">2 &lt;Bob&#x27;s pubkey&gt; &lt;Charlie&#x27;s pubkey&gt; 2 OP_CHECKMULTISIG</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>MAST 的一个思想是抽象语法树（Abstract Syntax Trees, AST），AST 通过树状结构来表示源代码，通过分支、函数调用来划分代码的各部分，例如上述脚本的 AST 可以构造为如下的方式</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/1*hopXMeyj-k92AvcRSc7J4A.png" alt="img"></p><p>而 MAST 的另外一个思想则是是 Merkle 树，它以此将内容组织为一个二叉树，然后依次对子节点进行哈希运算，最终得到一个根节点哈希，如果要验证一个元素是否在一颗 Merkle 树中，只需要将这个元素和它沿途路径上的哈希值给出即可。根据这样的特性，Merkle 树也是一种密码累加器，成员证明过程在 <a href="https://decision01.com/post/ae4d471f.html">密码累加器</a> 中进行了简单的描述</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202902204.png" alt="image-20230910202902204"></p><p>结合这两种树状结构，如果以 AST 的方式来划分不同的代码片，然后放入到 Merkle 树的叶子节点的内容中，依次哈希就可以得到一个根哈希值（它就是上面公式中的 $t$）。最后，得到的 Merkle 树就是一个 MAST，在运行脚本代码的时候可以只给出一部分叶子节点上的脚本内容以及对应的成员证明即可（即沿途路径上的子节点哈希值）。</p><p>例如，最初脚本中的 MAST 可以构造为如下结构，Alice 可以使用签名脚本，并给出 Hash 2的值；或者由他的好友 Bob 和 Charlie 在三个月后给出第二个脚本，并且给出 Hash 1 的值就可以使用脚本</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202920105.png" alt="image-20230910202920105"></p><p>对脚本这样的组织方式使得用户可以在解锁的时候不需要像 P2SH 一样在解锁的时候需要填入完整的脚本，只需要给出 MAST 的一部分和其他部分的哈希值即可，很好地保护了隐私性</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zkfold.ing/bitcoin-Schnorr">比特币中的Schnorr签名</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr signature</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2023/04/27/taproot-and-musig2-recap-by-elle-mouton/#Taproot-%E8%BE%93%E5%87%BA">Taproot 及 MuSig2 回顾</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Schnorr-签名&quot;&gt;&lt;a href=&quot;#Schnorr-签名&quot;</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="cryptography" scheme="https://decision01.com/tags/cryptography/"/>
    
    <category term="bitcoin" scheme="https://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin 支付方式及地址类型</title>
    <link href="https://decision01.com/post/8a19da7d.html"/>
    <id>https://decision01.com/post/8a19da7d.html</id>
    <published>2024-04-08T12:16:05.000Z</published>
    <updated>2025-05-26T15:29:14.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition info"><p class="admonition-title">info</p><p>由于 Bitcoin 中的支付类型众多，这也导致地址各式各样，在 btcd 中提供了不同的函数来为公钥生成不同的地址。</p><p>这一篇作为 <a href="https://decision01.com/post/c19159ae.html">btcd：Golang 下的交易构建</a> 的补充，说明各种支付方式和地址类型。</p><p>另外，这篇博文的大部分内容对应 Learn me a bitcoin <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Learn me a bitcoin](https://learnmeabitcoin.com/)">[1]</span></a></sup> 的 <a href="https://learnmeabitcoin.com/technical/script/">Script</a>，所以这篇博文更像一个学习记录</p></div><h1 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h1><p><em>Script is a mini programming language used as a locking mechanism for outputs in bitcoin transactions.</em></p><p>脚本是一种迷你程序语言，用作比特币交易输出的锁定机制。</p><ul><li>在每笔交易的输出上都会由一个<strong>锁定脚本</strong>，它对应了输出中的 $ScriptPubKey$ 字段；</li><li>每笔交易还需要提供对应每个输入的<strong>解锁脚本</strong>，用于在这笔交易中解锁前一笔交易的输出，这对应了输入中的 $ScriptSig$​ 字段；</li></ul><p>锁定脚本和解锁脚本在比特币中体现为二进制形式混合的操作码和数据，并且通过运行时栈来运行，如果<strong>最终栈内的唯一元素</strong>是<code>OP_1</code>或更大的元素，那么脚本就是有效的；</p><p>基于此，一笔有效的交易需要所有输入的有效（每一笔输入的锁定脚本和在该笔交易下的输出脚本所构成的脚本有效）</p><p>脚本语言、EVM 两者存在很大的相似性，都是以字节码的形式在运行时栈中运行。它们最大的区别在于<strong>脚本语言只验证脚本的有效性用于实现支付</strong>，而不会保存程序的状态，也因此 Bitcoin 的脚本语言不能做到像 Ethereum 那样的 DApp。</p><h1 id="支付脚本"><a href="#支付脚本" class="headerlink" title="支付脚本"></a>支付脚本</h1><h2 id="P2PK：支付到公钥"><a href="#P2PK：支付到公钥" class="headerlink" title="P2PK：支付到公钥"></a>P2PK：支付到公钥</h2><p>支付到公钥涉及到两个操作码：</p><ul><li><code>OP_PUSHBYTES</code>：向栈中压入指定字节长度的数据</li><li><code>OP_CHECKSIG</code>：取出栈顶的两条数据，并进行签名校验，如果这两条数据分别是签名<code>sig</code>以及对应的公钥<code>pk</code>，签名正确则返回<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[OP_CHECKSIG - Bitcoin Wiki](https://en.bitcoin.it/wiki/OP_CHECKSIG)">[3]</span></a></sup></li></ul><blockquote><p>签名的格式<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[“可一学院”区块链科普丨OP_CHECKSIG](https://zhuanlan.zhihu.com/p/667783299)">[2]</span></a></sup>为<code>[DER signature][hashtype]</code>，即 DER 编码格式下的签名和哈希类型，DER 编码格式如下，(R,S) 是椭圆曲线下签名后得到的证明<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DER encode - Learn me a bitcoin](https://learnmeabitcoin.com/technical/keys/signature/#der)">[4]</span></a></sup></p><p><img src="https://learnmeabitcoin.com/diagrams/png/keys-signature-der-encoding.png" alt="A diagram showing how convert a raw signature to DER encoding."></p></blockquote><p>P2PK 的锁定脚本和解锁脚本的形式依次为：</p><ul><li>锁定脚本：<code>OP_PUSHBYTES_65 [pk] OP_CHECKSIG</code></li><li>解锁脚本：<code>OP_PUSHBYTES_72 [sig]</code></li><li>完整脚本：<code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_65 [pk] OP_CHECKSIG</code></li></ul><p>其运行过程就是：先把签名和公钥压栈，然后依次取出后调用 <code>OP_CHECKSIG</code> 来验证签名，OP_CHECKSIG 使用公钥 <code>pk</code> 验证签名 <code>sig</code> 是否对应当前的交易</p><p>这里的交易被作为签名时需要的消息，通常签名需要制定消息输入，否则无法满足签名所需要的安全性（算是密码学常识）</p><p>于是 P2PK 交易的锁定脚本只需要公钥即可，锁定脚本中的公钥可以是压缩形式（33 bytes），也可以是未压缩形式（65 bytes）</p><div class="admonition note"><p class="admonition-title">公钥的压缩</p><p>在椭圆曲线密码中，私钥通常是一个大整数 $k$，而公钥则是一个点 $kO$，$O$ 是椭圆曲线上的一个基点</p><p>所以，这就导致公钥实际上是二维坐标系上的一个二维坐标 (x,y)，这就使得正常存储公钥需要存放两个坐标值</p><p>但是根据具体使用的 secp256k1 曲线的公式有 $y^2=x^3 + 7$，只需要知道 $x$ 就可以计算得到 $y$，这就使得通过只存放 $x$ 来压缩公钥成为可能。</p><p>由于平方的存在这使得取值会有两个（在取模下是一个奇数和一个偶数），因此压缩的公钥中需要指定是奇数或是偶数，即前缀中记录0x02（偶数）或0x03（奇数）。</p></div><h2 id="P2PKH：支付到公钥哈希"><a href="#P2PKH：支付到公钥哈希" class="headerlink" title="P2PKH：支付到公钥哈希"></a>P2PKH：支付到公钥哈希</h2><p>支付到公钥的方式需要存放的数据太长，它需要存放完整的公钥信息，于是支付到哈希值这一方法被提出，然而实际上公钥还是需要被包含到交易中，区别在于：P2PK 的公钥在锁定脚本（交易输出）中，P2PKH 的公钥在解锁脚本（交易输入）中。</p><p>支付到公钥哈希涉及的额外操作码：</p><ul><li><code>OP_DUP</code>：取出栈顶的数据，复制一份然后将两份数据都压栈</li><li><code>OP_HASH160</code>：取出栈顶的数据，通过 hash160 计算哈希值后放入栈中</li><li><code>OP_EQUALVERIFY</code>：取出栈顶的两份数据，检查是否相等</li></ul><p>支付到公钥哈希的验证过程和支付到公钥类似，它多出来的步骤是验证解锁脚本中公钥的哈希值和锁定脚本中的哈希值是否相等，然后再验证交易的签名</p><p>P2PKH 的锁定脚本和解锁脚本的形式依次为：</p><ul><li>锁定脚本：<code>OP_DUP OP_HASH160 OP_PUSHBYTES_20 [pkh] OP_EQUALVERIFY OP_CHECKSIG</code></li><li>解锁脚本：<code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_33 [pk]</code> </li><li>完整脚本：<code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_33 [pk] OP_DUP OP_HASH160 OP_PUSHBYTES_20 [pkh] OP_EQUALVERIFY OP_CHECKSIG</code></li></ul><p>完整脚本的除去最后验证签名的部分，都是为了验证公钥的哈希值是否正确</p><p>这种签名方式将交易的手续费从发送者转移到了接收者，因为接收者相比 P2PK 方式需要填入更多的信息，但是减少了发送者的信息长度</p><div class="admonition attention"><p class="admonition-title">attention</p><p>后续都会提到代价转移这一概念，实际上就是越大的交易所需要的手续费越高</p><p>因此，后面的支付方式都在通过降低锁定脚本的大小，然后不得已又使得解锁脚本变大，这个过程中支付的成本就从发送者转移到了接收者</p></div><h2 id="P2SH：支付到脚本哈希"><a href="#P2SH：支付到脚本哈希" class="headerlink" title="P2SH：支付到脚本哈希"></a>P2SH：支付到脚本哈希</h2><p>支付到脚本哈希要求解锁脚本经过哈希后为某个哈希值，它最初被用于多签交易，因为多签交易中需要包含多个钱包的公钥，并且使用 P2PK 方式使得需要存放大量冗余公钥，这使得发送者在锁定时需要消耗较多的手续费（于是同样地，这部分费用被转移到使用者）</p><p>P2SH 的锁定脚本和解锁脚本的形式依次为：</p><ul><li>锁定脚本：<code>OP_HASH160 OP_PUSHBYTES_20 [hash] OP_EQUAL</code></li><li>解锁脚本：没有确定的形式，只需要保证它的哈希值为 <code>hash</code> 即可，这里使用 <code>script</code> 表示</li><li>完整脚本：<code>[args] [script] OP_HASH160 OP_PUSHBYTES_20 [hash] OP_EQUAL</code></li></ul><p>因此，实际上 <code>script</code> 中包含的是完整的脚本代码，同时还有脚本需要的参数 <code>args</code>，在多签交易中，这些参数是签名，这种支付方式完全将交易的代价转移给了发送者</p><p>非多重签名中，<code>args</code> 是压入交易的签名 <code>OP_PUSHBYTES_72 [sig] OP_PUSHBYTES_33 [pk]</code>，<code>script</code> 包含的则是 P2PKH 的后半部分 <code>OP_DUP OP_HASH160 OP_PUSHBYTES_20 [pkh] OP_EQUALVERIFY OP_CHECKSIG</code></p><h2 id="Witness：隔离见证"><a href="#Witness：隔离见证" class="headerlink" title="Witness：隔离见证"></a>Witness：隔离见证</h2><p>BIP 141 提案中提出了<strong>隔离见证（SegWit）</strong>这一技术，见证隔离其实是某种程度上对区块的<strong>扩容</strong>（原来一个区块大小 1M 到现在的一个区块大小 4M），也算是开发者社区中达到的一种奇怪的平衡</p><div class="admonition note"><p class="admonition-title">隔离见证的核心思想</p><p>其核心思想是每笔交易的解锁脚本不再直接存储到交易的 <code>ScriptSig</code> 字段中，而是额外用一个名为 <code>witness</code> 的数组来存放，它们一一对应输入的位置作为解锁脚本。</p><p>此外，bip-141 还为交易提供了虚拟大小（vSize）这一概念，在计算区块大小的时候按照所有交易的虚拟大小总和作为区块大小。而见证隔离交易的虚拟大小为它真实大小的四分之一。这样就间接使得每个区块的大小变为了原来的 4 倍，但是实际上区块的真实大小还是 1 MB（<del>这不是就是在耍流氓吗</del>）。</p><p>此外，节点还可以剔除隔离见证的数据来减小区块的实际数据，它们在存放时和基础的区块是分开的。</p></div><p>见证隔离的锁定脚本形式：</p><ul><li>针对 P2PKH 交易（P2WPKH）：<code>OP_0 OP_PUSHBYTES_20 [pkh]</code></li><li>针对 P2SH 交易（P2WSH）：<code>OP_0 OP_PUSHBYTES_32 [hash]</code></li></ul><p>可以看出，锁定脚本根据类型具有不同的长度，客户端也可以根据长度来区分它们是 P2WPKH 还是 P2WSH</p><p>同时，见证隔离的解锁脚本也跟真实的 P2PKH 和 P2SH 交易不同，它们使用紧凑的字节码来表示数据，不需要操作码。解锁脚本被存放在交易的 <code>witness</code> 字段，并保证 <code>sigScript</code> 字段为空，解锁脚本的格式如下</p><ul><li><p>针对 P2PKH 交易：<code>[sig] [pk]</code></p></li><li><p>针对 P2SH 交易: <code>[args] [script]</code></p><blockquote><p>在这里，args 是后续脚本 script 的参数，因为不能保证所有 script 的参数都是一样的</p></blockquote></li></ul><p>见证隔离中设定了对应的脚本对来运行脚本，以此来达到压缩交易大小的目的</p><p>并且，锁定脚本的 <code>OP_0</code> 操作码对于一个旧的客户端来说，它是一个任何人都可以花费的输出，这就可以很好地兼容新版本客户端的区块和交易</p><h2 id="P2TR：支付到-Taproot"><a href="#P2TR：支付到-Taproot" class="headerlink" title="P2TR：支付到 Taproot"></a>P2TR：支付到 Taproot</h2><p>支付到 Taproot （主根）是版本为 1 的隔离见证，上述的两种隔离见证是版本为 0 的隔离见证</p><p>P2TR 将两种支付方式统一到了一起，通过输出的格式无法知道这个输出是通过签名锁定（Key Path）还是脚本锁定（Script Path）<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot](https://aandds.com/blog/bitcoin-taproot.html)">[5]</span></a></sup></p><p>只有在输出被使用的时候，通过见证信息才知道其锁定形式是签名锁定还是脚本锁定</p><div class="admonition attention"><p class="admonition-title">attention</p><p><del>Taproot 交易也是 Bitcoin 的一个重大升级，这个支付方式设计到 Schnorr 签名和默克尔抽象语法树（Merklized Abstract Syntax Trees, MAST），要讲明白又需要开新的一篇来写了 = =，这里就先放着了，后续开新坑写</del></p><p>这部分内容见 <a href="https://decision01.com/post/b45dd1b1.html">BIP-340/1：Schnorr 签名与 MAST</a></p></div><p>由于是版本为 1 的隔离见证，所以它的锁定脚本为 <code>OP_1 OP_PUSHBYTES_32 [hash]</code>，这里由于统一了两种支付路径，所以哈希值都是 32 bytes</p><p>解锁脚本格式：</p><ul><li>针对 P2PKH 交易：<code>[sig]</code></li><li>针对 P2SH 交易：<code>[args] [script]</code></li></ul><p>于是，在 P2TR 交易中，只能通过 witness 来区分交易类型，如果只有一个元素，说明是 P2PKH 交易，否则是 P2SH 交易</p><h1 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h1><p>在 Bitcoin 中没有 EVM 类区块链的实际意义上的地址，但是是否在所有的 UTxO 类区块链中都是这样还有待考证</p><p>Bitcoin 中常见的转账地址信息实际上是根据脚本类型推算得到，在常规的思维中是先有地址，才可以进行转账。而这也是比较反直觉的一点：<strong>Bitcoin 地址用于给发送方构造正确的输出，而交易中的地址是通过输出中的信息来推算得到</strong></p><p>Bitcoin 交易的输出（Output）结构如下</p><table><thead><tr><th>字段</th><th>描述</th><th>长度</th></tr></thead><tbody><tr><td>$Amount$</td><td>输出中包含的聪有多少</td><td>8 bytes</td></tr><tr><td>$ScriptPubKey Size$</td><td>输出锁定脚本长度</td><td>可选的 2 bytes</td></tr><tr><td>$ScriptPubKey$</td><td>输出中的锁定脚本</td><td>1 - 9 bytes</td></tr></tbody></table><p>在 Mempool 这样的 Bitcoin 浏览器中通常会见到如 bc1q、bc1p 开头的地址，这些地址所对应的是交易的不同支付类型，它们是根据交易输出中的 <code>ScriptPubKey</code> 字段推算得到</p><p>在转账之前，通过用户输入的地址可以判断需要的输出类型，基于此来构建交易中正确的 <code>ScriptPubKey</code> </p><p>综合前面几种不同的支付类型就对应了不同的地址类型，<strong>最为简单的是支付到公钥的交易，其地址就是对方的公钥</strong></p><h2 id="P2PKH"><a href="#P2PKH" class="headerlink" title="P2PKH"></a>P2PKH</h2><p><strong>P2PKH</strong>：支付到公钥的地址通过对公钥进行两次哈希，然后添加校验值后进行 base58 编码的方式得到，这样的地址通常以 1 开头，其生成流程如下图所示</p><p>这个过程也可以描述为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sha = SHA-256(pk)</span><br><span class="line">r = RIPEMD-160(sha)</span><br><span class="line">sum = SHA-256(version + SHA-256(r))</span><br><span class="line">address = base58_check(version + r + sum[:4])</span><br></pre></td></tr></table></figure><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312207185.jpg" alt="Legacy Address"></p><h2 id="P2SH"><a href="#P2SH" class="headerlink" title="P2SH"></a>P2SH</h2><p><strong>P2SH</strong>：支付到脚本哈希的地址针对脚本哈希值来实现编码，对于单一的地址，ScriptHash 是对脚本进行哈希所得的结果。对它们以以下列的方式进行 base58 编码，通常会得到以 3 开头的地址。在实际的应用下，P2SH 的地址是通过对一个 P2WPKH 的锁定脚本进行哈希后生成的，这里的 ScriptHash 所哈希的内容是<code>OP_0 OP_PUSHBYTES_20 [pkh]</code>，这种地址也被称为 P2SH-P2WPKH</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312205969.png" alt="image-20230531220559720"></p><h2 id="P2WPKH-与-Taproot"><a href="#P2WPKH-与-Taproot" class="headerlink" title="P2WPKH 与 Taproot"></a>P2WPKH 与 Taproot</h2><p><strong>SegWit（P2WPKH）与 Taproot（P2TR）地址生成</strong></p><p>隔离见证开始的地址都是比较统一的编码格式，它们的格式为 <code>[readable][separator][bech32]</code>，这类地址也统称为 Bech32 地址</p><ul><li>readable： 人类可读的部分，主网为 <code>bc</code>，测试网为 <code>tb</code></li><li>separator：固定为 <code>1</code> 的分隔符</li><li>bech32：经过 bech32 编码对公钥哈希进行编码得到的结果，并且前面加上版本号 <code>0x00</code> 或 <code>0x01</code></li></ul><blockquote><p>不同的版本号会对应到不同的地址，<code>0x00</code> 对应了 <code>bc1q</code> 类型的地址，<code>0x01</code> 对应了 <code>bc1p</code> 类型的地址</p></blockquote><p>在 P2WPKH 中，最后的 bech32 是对公钥哈希的编码，这是由于此时还没有 Taproot 这样的支付方式来将两种支付路径统一起来</p><p>而在 P2TR 中，不是对公钥哈希的编码，而是将公钥和一些额外的数据进行哈希，得到一个 tweak（详见 <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP-0341</a>），再将它添加到原始公钥上得到新的公钥</p><div class="admonition attention"><p class="admonition-title">attention</p><p>P2TR 中使用的是改进后的 bech32m 编码，这是由于 bech32 编码存在的缺点：如果地址的最后一个字符是 p，那么在 p 之前的位置插入或删除任意数量的字符 q 都不会使校验和失效</p></div><p>地址通常在区块浏览器和钱包这两个场景出现</p><p>在区块浏览器中，地址通常是通过输出中的 ScriptPubKey 判断支付类型后，再按照对应的地址生成格式得到地址</p><p>而在钱包中，则是用户在输入接收方地址后，根据地址判断所需要使用的支付类型，再按照对应的方式构造交易</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/667783299">“可一学院”区块链科普丨OP_CHECKSIG</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/OP_CHECKSIG">OP_CHECKSIG - Bitcoin Wiki</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://learnmeabitcoin.com/technical/keys/signature/#der">DER encode - Learn me a bitcoin</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://aandds.com/blog/bitcoin-taproot.html">Taproot</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition info&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="bitcoin" scheme="https://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>btcd：Golang 下的交易构建</title>
    <link href="https://decision01.com/post/c19159ae.html"/>
    <id>https://decision01.com/post/c19159ae.html</id>
    <published>2024-04-08T06:01:32.000Z</published>
    <updated>2025-05-26T15:33:01.349Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p class="admonition-title">锲子</p><p>参与 Bitcoin 的相关生态难免需要涉及到链上的操作，相比于 Ethereum 这样简单的交易发送机制，Bitcoin 上构建交易则需要一定的编程能力，这篇博文记录一下 Bitcoin 上构建交易的各种姿势。（博文不间断更新）</p></div><p>这篇博文的前置知识：UTxO、交易结构与脚本语言，可以在 <a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a> 学习，另外：</p><ul><li>测试网交易池可视化：<a href="https://mempool.space/testnet">https://mempool.space/testnet</a></li><li>测试代币水龙头：<a href="https://bitcoinfaucet.uo1.net/">https://bitcoinfaucet.uo1.net/</a></li><li>测试私钥生成（主网尽量不要使用）：<a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a> </li></ul><p>golang 下的 Bitcoin 工具库为：<code>github.com/btcsuite/btcd</code></p><h1 id="简单交易的构建"><a href="#简单交易的构建" class="headerlink" title="简单交易的构建"></a>简单交易的构建</h1><h2 id="私钥与地址生成"><a href="#私钥与地址生成" class="headerlink" title="私钥与地址生成"></a>私钥与地址生成</h2><h3 id="私钥生成"><a href="#私钥生成" class="headerlink" title="私钥生成"></a>私钥生成</h3><p>私钥有多种形式，在 Bitcoin 中最为常见的是 WIF （Wallet Import Format）格式的私钥，也有 16 进制的私钥，这些私钥之间是可以相互转换的</p><div class="admonition note"><p>事实上目前的大多数钱包插件都不支持 WIF 格式的私钥导入，只能使用一些软件钱包才能导入。</p></div><p>golang 内可以生成私钥并派生 WIF 格式的私钥，也可以使用在线的 BIP-39 助记词生成（不推荐主网使用）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 博文的代码都默认为测试网</span></span><br><span class="line">cfg := &amp;chaincfg.TestNet3Params</span><br><span class="line"></span><br><span class="line">privateKey, err := btcec.NewPrivateKey()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wif, err := btcutil.NewWIF(privateKey, cfg, <span class="literal">true</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Generated WIF Key: %s&quot;</span>, wif.String())</span><br><span class="line"><span class="comment">// Generated WIF Key: cViUtGHsa6XUxxk2Qht23NKJvEzQq5mJYQVFRsEbB1PmSHMmBs4T</span></span><br></pre></td></tr></table></figure><h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><p>同样，Bitcoin 的地址有多种类型，在之前的博文 <a href="https://decision01.com/post/4f925910.html">BIP、闪电网络与 Trao</a> 中略有提及，如果需要具体了解也可以阅 Learn me a bitcoin 的 <a href="https://learnmeabitcoin.com/technical/script/">Script</a> 小节中的各种地址。</p><p>支付类型和地址相关的内容参见 <a href="https://decision01.com/post/8a19da7d.html">Bitcoin 支付方式及地址类型</a></p><p>目前比较常用的是 Taproot 地址，这是为了支持 Taproot 协议而被提出的地址类型，可以支持不同的 Pay-To 方式</p><p>在代码的实现层面上，通过 WIF 私钥生成地址的代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">taprootAddr, err := btcutil.NewAddressTaproot(</span><br><span class="line">    schnorr.SerializePubKey(</span><br><span class="line">        txscript.ComputeTaprootKeyNoScript(</span><br><span class="line">            wif.PrivKey.PubKey())),</span><br><span class="line">    &amp;chaincfg.TestNet3Params)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Taproot testnet address: %s\n&quot;</span>, taprootAddr.String())</span><br><span class="line"><span class="comment">// Taproot testnet address: tb1p3d3l9m5d0gu9uykqurm4n8xcdmmw9tkhh8srxa32lvth79kz7vysx9jgcr</span></span><br></pre></td></tr></table></figure><p>这里嵌套了四层函数，从内到外依次是</p><ul><li>wif.PrivKey.PubKey()：获取 WIF 密钥对的公钥</li><li>txscript.ComputeTaprootKeyNoScript：通过公钥计算得到一个 Taproot 的 Schnorr 签名公钥，类似一个转换的过程</li><li>schnorr.SerializePubKey：对公钥序列化为字节码</li><li>btcutil.NewAddressTaproot：序列化后的公钥生成 Taproot 地址</li></ul><p><strong>其他类型的地址生成方式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 wif 得到公钥并计算 hash160 值</span></span><br><span class="line">pubkey := wif.PrivKey.PubKey()</span><br><span class="line">pkh := btcutil.Hash160(pubkey.SerializeCompressed())</span><br><span class="line"></span><br><span class="line"><span class="comment">// P2PKH 类型地址</span></span><br><span class="line">pubkeyAddr, _ := btcutil.NewAddressPubKeyHash(pkh, cfg)</span><br><span class="line"><span class="comment">// P2SH-P2WPKH 类型地址：先构建支付脚本，然后对脚本生成地址</span></span><br><span class="line">script, _ := txscript.NewScriptBuilder().</span><br><span class="line">    AddOp(txscript.OP_0).</span><br><span class="line">    AddData(pkh).</span><br><span class="line">    Script()</span><br><span class="line">scriptAddr, _ := btcutil.NewAddressScriptHash(script, cfg)</span><br><span class="line"><span class="comment">// P2WPKH 地址</span></span><br><span class="line">witnessAddr, _ := btcutil.NewAddressWitnessPubKeyHash(pkh, cfg)</span><br></pre></td></tr></table></figure><h2 id="交易构建"><a href="#交易构建" class="headerlink" title="交易构建"></a>交易构建</h2><p>Bitcoin 最为简单的交易即一笔输入和一笔输出的交易，它将一笔输入中的 BTC 转入到另外一个地址</p><p>随机生成转账地址：tb1pvwak065fek4y0mup9p4l7t03ey2nu8as7zgcrlgm9mdfl8gs5rzss490qd</p><div class="admonition note"><p>虽然说是“简单”交易构建，实际上 Taproot 类型的交易算是比较麻烦的交易构建方式，较为简单的应该是 P2PKH 交易的构建。</p></div><p>构建交易之前需要获取地址的可用 UTxO，需要一个函数 <code>GetUnspent(address string)</code> 来得到地址的 UTxO，这里先手动填入然后返回所需要的 UTxO 的信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUnspent</span><span class="params">(address <span class="type">string</span>)</span></span> (*wire.OutPoint, *txscript.MultiPrevOutFetcher)&#123;</span><br><span class="line"><span class="comment">// 交易的哈希值，并且要指定输出位置</span></span><br><span class="line">txHash, _ := chainhash.NewHashFromStr(</span><br><span class="line"><span class="string">&quot;7282d54f485561dd21ba22a971b096eb6d0f45ed2fe6bf8c29d87cee162633b4&quot;</span>)</span><br><span class="line">point := wire.NewOutPoint(txHash, <span class="type">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交易的锁定脚本，对应的是 ScriptPubKey 字段</span></span><br><span class="line">script, _ := hex.DecodeString(<span class="string">&quot;51208b63f2ee8d7a385e12c0e0f7599cd86ef6e2aed7b9e033762afb177f16c2f309&quot;</span>)</span><br><span class="line">output := wire.NewTxOut(<span class="type">int64</span>(<span class="number">1000</span>), script)</span><br><span class="line">fetcher := txscript.NewMultiPrevOutFetcher(<span class="literal">nil</span>)</span><br><span class="line">fetcher.AddPrevOut(*point, output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> point, fetcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是一个输出点（output point）和前置输出获取器（Fetcher）</p><ul><li>输出点记录了 UTxO 所在的交易哈希和输出所在交易的位置（index），后续用于填充交易的输入</li><li>获取器中记录了一个映射关系，即一个输出点对应的输出是什么样的（它输出的数量和锁定脚本）</li></ul><p>此外，发送交易之前要将地址解码并且生成 Taproot 下的 PayToAddress 脚本，该过程的实现代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeTaprootAddress</span><span class="params">(strAddr <span class="type">string</span>, cfg *chaincfg.Params)</span></span> ([]<span class="type">byte</span>, </span><br><span class="line"><span class="type">error</span>) &#123;</span><br><span class="line">taprootAddr, err := btcutil.DecodeAddress(strAddr, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byteAddr, err := txscript.PayToAddrScript(taprootAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> byteAddr, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>至此，可以开始一笔简单交易的构建，相比于在 Ethereum 下一个 Json 就可以完成的操作，在 Bitcoin 则是需要实例化一个空的交易体并手动填充</p><p>新建交易的输入（wire.TxIn）需要三个参数：前一输出点、签名、见证脚本（witness），构建交易时后面两者均先默认为 nil，在签名完成后才进行填充</p><div class="admonition note"><p class="admonition-title">签名和见证脚本</p><p>在通常情况下，见证脚本和签名脚本是独立的，或者说见证脚本就是一种签名，只是它独立在交易体外，并且这一部分数据也可以在很久之后被节点修剪掉。</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 version = 1</span></span><br><span class="line">tx := wire.NewMsgTx(wire.TxVersion)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前一笔交易的输出点作为输入</span></span><br><span class="line">in := wire.NewTxIn(point, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">tx.AddTxIn(in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建输出，支付到指定地址并填充转移多少</span></span><br><span class="line">out := wire.NewTxOut(<span class="type">int64</span>(<span class="number">800</span>), byteAddr)</span><br><span class="line">tx.AddTxOut(out)</span><br></pre></td></tr></table></figure><p>然后需要对交易进行签名，签名是对交易的所有输入进行签名，即需要填入正确的解锁脚本到签名脚本或见证脚本字段中。在 Taproot 交易中，通常需要填入解锁的见证脚本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前一笔交易</span></span><br><span class="line">prevOutput := fetcher.FetchPrevOutput(in.PreviousOutPoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥生成见证脚本</span></span><br><span class="line">witness, _ := txscript.TaprootWitnessSignature(tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher), <span class="number">0</span>, prevOutput.Value,</span><br><span class="line">    prevOutput.PkScript, txscript.SigHashDefault, wif.PrivKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充输入的见证脚本</span></span><br><span class="line">tx.TxIn[<span class="number">0</span>].Witness = witness</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将完成签名的交易转为 hex 形式并输出</span></span><br><span class="line"><span class="keyword">var</span> signedTx bytes.Buffer</span><br><span class="line">tx.Serialize(&amp;signedTx)</span><br><span class="line">finalRawTx := hex.EncodeToString(signedTx.Bytes())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Signed Transaction:\n %s&quot;</span>, finalRawTx)</span><br><span class="line"><span class="comment">// Signed Transaction: 01000000000101b4332616ee7cd8298cbfe62fed450f6deb96b071a922ba21dd6155484fd582720000000000ffffffff01200300000000000022512063bb67ea89cdaa47ef81286bff2df1c9153e1fb0f09181fd1b2eda9f9d10a0c5014011a52fdf6ccdda65359ecc9761b199e132d92bb21be059c6c5fb23e86af7152d429dde23314df0db4bcd52428acffab876b8cca1e19d2788a8382c48141b19bd00000000</span></span><br></pre></td></tr></table></figure><p>本节不设计代码层面的交易发送，简单来说交易的广播就是将它发布到任意一个区块链节点</p><p>所以可以将生成的交易提交到 <a href="https://mempool.space/testnet/tx/push">Broadcast Transaction</a> 即可，演示交易为 <a href="https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f">https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f</a></p><p>本节的完整代码：<a href="https://gist.github.com/Decision2016/18057d0d62b0b5f9716385063fb4c3bc">Simple Bitcoin Transaction - Github Gist</a></p><h1 id="扩展：其他类型的输入、输出以及交易大小"><a href="#扩展：其他类型的输入、输出以及交易大小" class="headerlink" title="扩展：其他类型的输入、输出以及交易大小"></a>扩展：其他类型的输入、输出以及交易大小</h1><h2 id="交易输出"><a href="#交易输出" class="headerlink" title="交易输出"></a>交易输出</h2><p>golang 下的 btcd 提供了统一的方法构建输出脚本，可以通过类似前面 Taproot 交易构建的方法来实现交易输出的设置。当然，也可以根据交易格式手动构建输出，但是比较繁琐且容易出错，这里展示统一的构建方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CommonBuilder)</span></span> AddPayToAddressOutput(value <span class="type">int64</span>, address <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">addr, err := btcutil.DecodeAddress(address, cb.cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lockingScript, err := txscript.PayToAddrScript(addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out := wire.NewTxOut(value, lockingScript)</span><br><span class="line">cb.tx.AddTxOut(out)</span><br><span class="line">cb.outputValue += value</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易输入签名"><a href="#交易输入签名" class="headerlink" title="交易输入签名"></a>交易输入签名</h2><p>针对不同的输入类型，需要通过调用不同的函数来实现交易的签名，从而对 UTxO 进行解锁</p><p>解锁的签名涉及到不同类型的签名，它对应了 HashType 这个字段，通常在签名的最后一个字节，各种类型可以参考 <a href="https://decision01.com/post/c085945e.html">部分签名交易</a></p><p>下面的代码里的 <code>idx</code> 代表的是输入所在交易中的位置，这里的交易设置了输入、输出后但是没有签名，依次遍历输入进行签名</p><h3 id="P2PKH"><a href="#P2PKH" class="headerlink" title="P2PKH"></a>P2PKH</h3><p>P2PKH 类型的输入需要对前一个输出的公钥哈希进行签名，这里可以直接调用 <code>txscript.SignatureScript</code> 函数进行签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sig, err := txscript.SignatureScript(</span><br><span class="line">    tx,<span class="comment">// wire.MsgTX 类型的交易体</span></span><br><span class="line">    idx,<span class="comment">// 交易输入的位置，例如第一个位置是0，依次推导</span></span><br><span class="line">    txOut.PkScript,<span class="comment">// 需要进行签名的脚本，也就是前一个输出的 pubkeyScript</span></span><br><span class="line">    txscript.SigHashAll,<span class="comment">// 交易的签名类型</span></span><br><span class="line">    wif.PrivKey,<span class="comment">// 签名私钥</span></span><br><span class="line">    <span class="literal">true</span>,<span class="comment">// 输出的公钥是否压缩类型</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx.TxIn[idx].SignatureScript = sig</span><br></pre></td></tr></table></figure><h3 id="P2WPKH-P2SH"><a href="#P2WPKH-P2SH" class="headerlink" title="P2WPKH-P2SH"></a>P2WPKH-P2SH</h3><p>这种类型的输入签名没有已经实现的函数，需要构建输入脚本到交易的 signatureScript 并且进行 Witness 签名后填入字段</p><p>构建 Witness 签名可以通过调用 <code>WitnessSignature</code> 方法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建脚本，以解锁输出中锁定的脚本哈希</span></span><br><span class="line">script, err := txscript.NewScriptBuilder().</span><br><span class="line">    AddOp(txscript.OP_0).</span><br><span class="line">    AddData(pkh).</span><br><span class="line">    Script()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对脚本进行签名，这里调用 WitnessSignature 进行签名</span></span><br><span class="line">witness, err := txscript.WitnessSignature(</span><br><span class="line">    tx,<span class="comment">// wire.MsgTX 类型的交易体</span></span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher),<span class="comment">// 这里需要实现一个交易的 fetcher 用于构建哈希</span></span><br><span class="line">    idx,<span class="comment">// 交易输入的位置，例如第一个位置是0，依次推导</span></span><br><span class="line">    txOut.Value,<span class="comment">// 前一个交易输出中携带的 btc 数量，单位为 </span></span><br><span class="line">    script,<span class="comment">// 对前面的脚本进行签名，注意，这里是 P2SH 交易，不是对前面的锁定脚本签名</span></span><br><span class="line">    txscript.SigHashAll,<span class="comment">// 签名类型</span></span><br><span class="line">    wif.PrivKey,<span class="comment">// 签名私钥</span></span><br><span class="line">    <span class="literal">true</span>,<span class="comment">// 是否压缩类型</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要构建新的脚本，将前一个脚本压栈</span></span><br><span class="line">script, err = txscript.NewScriptBuilder().</span><br><span class="line">    AddData(script).</span><br><span class="line">    Script()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx.TxIn[idx].SignatureScript = script</span><br><span class="line">tx.TxIn[idx].Witness = witness</span><br></pre></td></tr></table></figure><h3 id="P2WPKH"><a href="#P2WPKH" class="headerlink" title="P2WPKH"></a>P2WPKH</h3><p>Witness 下的 P2PKH 交易比较简单，直接调用 <code>WitnessSignature</code> 方法来实现签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sig, err := txscript.TaprootWitnessSignature(</span><br><span class="line">    tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher),</span><br><span class="line">    idx,</span><br><span class="line">    txOut.Value,</span><br><span class="line">    txOut.PkScript,</span><br><span class="line">    txscript.SigHashAll,</span><br><span class="line">    wif.PrivKey,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx.TxIn[idx].Witness = sig</span><br></pre></td></tr></table></figure><h3 id="Taproot"><a href="#Taproot" class="headerlink" title="Taproot"></a>Taproot</h3><p>Taproot 的类似前面所说的签名方式，这里直接给代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sig, err := txscript.TaprootWitnessSignature(</span><br><span class="line">    tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher),</span><br><span class="line">    idx,</span><br><span class="line">    txOut.Value,</span><br><span class="line">    txOut.PkScript,</span><br><span class="line">    txscript.SigHashAll,</span><br><span class="line">    wifs.PrivKey,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx.TxIn[idx].Witness = sig</span><br></pre></td></tr></table></figure><h2 id="交易大小"><a href="#交易大小" class="headerlink" title="交易大小"></a>交易大小</h2><p>交易根据不同的交易类型存在不同的计算方式：<a href="https://bitcoinops.org/en/tools/calc-size/">Transaction size calculator</a></p><p>但是，公式并不能很好地计算混合类型的交易，所以 go-btc 下提供了函数计算交易的虚拟大小（但是通过实际的使用发现似乎存在误差，后续还需要看一下）</p><p>这里是编写的工具里一个用于设置交易费用的代码，通过 <code>mempool.GetTxVirtualSize</code> 方法来获取交易大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CommonBuilder)</span></span> SetRefundOutput(refundAddress <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">address, err := btcutil.DecodeAddress(refundAddress, cb.cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lockingScript, err := txscript.PayToAddrScript(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out := wire.NewTxOut(<span class="number">0</span>, lockingScript)</span><br><span class="line">cb.tx.AddTxOut(out)</span><br><span class="line"></span><br><span class="line">vSize := mempool.GetTxVirtualSize(btcutil.NewTx(cb.tx))</span><br><span class="line">fee := <span class="type">float64</span>(vSize) * cb.gasPrice</span><br><span class="line">refund := (cb.inputValue - cb.outputValue) - <span class="type">int64</span>(math.Floor(fee+<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> refund &gt; <span class="number">0</span> &#123;</span><br><span class="line">cb.tx.TxOut[<span class="built_in">len</span>(cb.tx.TxOut)<span class="number">-1</span>].Value = refund</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cb.tx.TxOut = cb.tx.TxOut[:<span class="built_in">len</span>(cb.tx.TxOut)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> refund &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;input value %d &lt; output value %d&quot;</span>, cb.inputValue, cb.outputValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://mahdidarabi.medium.com/create-raw-bitcoin-transaction-and-sign-it-with-golang-96b5e10c30aa">Create Raw Bitcoin Transaction and Sign It With Golang</a></li><li><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="Dev" scheme="https://decision01.com/categories/Dev/"/>
    
    
    <category term="bitcoin" scheme="https://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>go-libp2p 踩坑记</title>
    <link href="https://decision01.com/post/822fd34d.html"/>
    <id>https://decision01.com/post/822fd34d.html</id>
    <published>2023-11-04T09:06:08.000Z</published>
    <updated>2024-12-24T15:01:50.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p>做区块链相关的项目难免会遇到需要构建一个 P2P 网络的时候，去年这个时候在 python 上使用的是一个已经停止维护了很久的 Kademlia 库；在今年转到 go 之后就注意到了 go-libp2p 这个库。go-libp2p 源自于 IPFS，它是用于构建 P2P 网络的模块化网络堆栈和库，功能特别强大，但是坑也特别多，主要的原因还是资料和文档都很少。在使用了一段时间后还是觉得需要写一篇博文来记录，还可以作为以后的一个文档吧。</p></div><p>对于 go-libp2p 的不同模块，可以参考 <a href="https://cloud.tencent.com/developer/article/1988253">长安链P2P网络技术介绍（2）：初识LibP2P</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[长安链P2P网络技术介绍（2）：初识LibP2P](https://cloud.tencent.com/developer/article/1988253)">[1]</span></a></sup>。当然，这是一个很笼统的介绍，而这篇博文也会比较简单（毕竟它所拥有的功能太多了），只会记录笔者所使用到的一些功能：连接建立、流处理、节点发现、消息广播及配置、资源限制；同时，官方的库中也有一些样例可以参考：<a href="https://github.com/libp2p/go-libp2p/tree/master/examples">examples - go-libp2p</a>，这篇博文的完整代码可以在 <a href="https://github.com/Decision2016/libp2p-example">libp2p-example</a> 查看</p><h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><p>先从最简单的 echo 功能开始：两个节点 A 和 B 在建立连接后，节点 A 向节点 B 发送消息 msg，节点 B 也返回消息 msg，可以通过控制台发送消息和打印接收到的消息，这也是 example 中的第一个例子 <a href="https://github.com/libp2p/go-libp2p/tree/master/examples/echo">echo - go-libp2p</a></p><h2 id="节点启动"><a href="#节点启动" class="headerlink" title="节点启动"></a>节点启动</h2><p>在 go-libp2p 中可以使用 <code>func New(opts ...Option) (host.Host, error)</code> 启动一个节点，它会返回一个 <code>Host</code> 对象，通过这个对象可以查询到本地节点的一系列连接信息，也是实现其他功能所需要用到的对象<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[从 go-libp2p 开始](https://www.cnblogs.com/superblockchain/p/14103338.html)">[2]</span></a></sup>。在这里先只考虑使用它来获取这个节点的监听地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/libp2p/go-libp2p&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">host, err := libp2p.New()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create libp2p host failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infoln(<span class="string">&quot;Create new libp2p host, listen addresses: &quot;</span>, host.Addrs())</span><br><span class="line"><span class="keyword">if</span> err := host.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Close host errored.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码展示的是一个节点的创建，并且在创建后打印出节点的监听信息</p><h2 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h2><p>在连接到另外一个节点之前需要知道节点的连接信息，通常连接信息以 multiaddr<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Addressing in libp2p](https://github.com/libp2p/specs/blob/master/addressing/README.md)">[3]</span></a></sup> 的形式出现，它的格式通常是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ip4/127.0.0.1/tcp/31514/p2p/12D3KooWSc8cftoRYqPdKUg3CSfdHngvbMuc8b4xEBBkF66RFGV8</span><br><span class="line"></span><br><span class="line">/[ip 协议类型/ip 地址/传输协议类型/端口/节点 id</span><br></pre></td></tr></table></figure><p>可以在指定监听端口后直接打印节点信息，并且让其他节点连接，例如添加以下的日志输出语句，并且通过传参的方式传入 <code>port</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logrus.Infof(<span class="string">&quot;Node address: /ip4/127.0.0.1/tcp/%v/p2p/%s&quot;</span>, port, host.ID().String())</span><br></pre></td></tr></table></figure><p>在拥有节点的信息后，就可以通过 <code>Connect(ctx context.Context, pi peer.AddrInfo) error</code> 连接到对端节点，对应的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">addrStr := <span class="string">&quot;/ip4/127.0.0.1/tcp/31514/p2p/...&quot;</span></span><br><span class="line"></span><br><span class="line">maddr, err := multiaddr.NewMultiaddr(addrStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Convert address from string failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr, err := peer.AddrInfoFromP2pAddr(maddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Get address info from multiple address failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = host.Connect(ctx, *addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Connect to new node failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合建立节点的代码，引入传参后可以实现一个连接到对端节点的程序，在传入连接信息 <code>peer</code> 时可以连接到对应的节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> help &#123;</span><br><span class="line">flag.Usage()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localMultiAddr, err := multiaddr.NewMultiaddr(</span><br><span class="line">fmt.Sprintf(<span class="string">&quot;/ip4/0.0.0.0/tcp/%d&quot;</span>, port),</span><br><span class="line">)</span><br><span class="line">host, err := libp2p.New(</span><br><span class="line">libp2p.ListenAddrs(localMultiAddr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create libp2p host failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infoln(<span class="string">&quot;Create new libp2p host, listen addresses: &quot;</span>, host.Addrs())</span><br><span class="line">logrus.Infof(<span class="string">&quot;Node address: /ip4/127.0.0.1/tcp/%v/p2p/%s&quot;</span>, port, host.ID().String())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> peerAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">maddr, err := multiaddr.NewMultiaddr(peerAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Convert address from string failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr, err := peer.AddrInfoFromP2pAddr(maddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Get address info from multiple address failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = host.Connect(ctx, *addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Connect to new node failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infof(<span class="string">&quot;Connect to node %s success.&quot;</span>, peerAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> sign := &lt;-c:</span><br><span class="line">logrus.Infof(<span class="string">&quot;Got %s signal. Aborting...&quot;</span>, sign)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := host.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Close host errored.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>传参</strong> 利用 golang 的 flag 包可以接收、解析传入参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">peerAddr <span class="type">string</span></span><br><span class="line">port     <span class="type">int</span></span><br><span class="line">help     <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.StringVar(&amp;peerAddr, <span class="string">&quot;peer&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Peer node address&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">8123</span>, <span class="string">&quot;Node listen port&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;help, <span class="string">&quot;h&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Command help&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag.Usage = usage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usage</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">`Usage: main [--port port] [--peer address]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">flag.PrintDefaults()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>在完成节点的连接后，还需要实现消息的传输才能完成 echo 程序的功能。在 go-libp2p 中具有创建数据流的功能</p><ul><li>发起流的建立者需要通过 <code>NewStream(ctx context.Context, p peer.ID, pids ...protocol.ID) (network.Stream, error)</code> 发起流的建立</li><li>对端需要通过 <code>SetStreamHandler(pid protocol.ID, handler network.StreamHandler)</code> 设置处理流的函数，并且由这个 <code>handler</code> 来进行流的处理</li></ul><h3 id="流处理函数"><a href="#流处理函数" class="headerlink" title="流处理函数"></a>流处理函数</h3><p>在这个例子中，接受流的创建的那一方在接受到消息后在控制台通过日志打印，并且将数据重新写入流返回给发送方，其函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleStream</span><span class="params">(s network.Stream)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf := bufio.NewReader(s)</span><br><span class="line">str, err := buf.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Receive failed, stream routine exit.&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logrus.Infof(<span class="string">&quot;Read from stream: %s&quot;</span>, str[:<span class="built_in">len</span>(str)<span class="number">-1</span>])</span><br><span class="line">_, err = s.Write([]<span class="type">byte</span>(str))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Write to stream failed, routine exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在 <code>main</code>  函数中使用 <code>host.SetStreamHandler(&quot;/echo/1.0.0&quot;, handleStream)</code> 来设置流的处理函数</p><p>在这里 <code>/echo/1.0.0</code> 是指定的协议 id，可以根据不同的需要来进行设定</p><h3 id="发送方函数"><a href="#发送方函数" class="headerlink" title="发送方函数"></a>发送方函数</h3><p><code>NewStream</code> 函数在成功创建流之后会返回一个 <code>Stream</code> 对象，后续可以通过这个对象来收发数据，基于此可以编写一个 <code>sendMessage</code> 的函数作为控制台消息写入协程</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(s network.Stream)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line">buf := bufio.NewReader(s)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := fmt.Scan(&amp;msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Read data from console failed.&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">msg += <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">_, err = s.Write([]<span class="type">byte</span>(msg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Write message to stream failed.&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str, err := buf.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">logrus.Infof(<span class="string">&quot;Read from stream: %s&quot;</span>, str[:<span class="built_in">len</span>(str)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，在 <code>main</code> 函数中连接到对端节点后添加</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream, err := host.NewStream(ctx, addr.ID, <span class="string">&quot;/echo/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create stream failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sendMessage(stream)</span><br></pre></td></tr></table></figure><p>对应于上一段代码，此时的程序在省略掉部分代码后如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">logrus.Infoln(<span class="string">&quot;Create new libp2p host, listen addresses: &quot;</span>, host.Addrs())</span><br><span class="line">logrus.Infof(<span class="string">&quot;Node address: /ip4/127.0.0.1/tcp/%v/p2p/%s&quot;</span>, port, host.ID().String())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> peerAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">logrus.Infof(<span class="string">&quot;Connect to node %s success.&quot;</span>, peerAddr)</span><br><span class="line"></span><br><span class="line">stream, err := host.NewStream(ctx, addr.ID, <span class="string">&quot;/echo/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create stream failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sendMessage(stream)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(s network.Stream)</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleStream</span><span class="params">(s network.Stream)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>至此，实现了一个基于 go-libp2p 完成的节点间通信程序。而需要建立一个 P2P 网络所需要的则是连接到一个节点后能够发现其他节点并且进行通信，以及指定节点 id 来进行通信。所以，下一节的内容则是利用 kademlia 库来进行节点的发现和连接。</p><h1 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h1><p>在 go-libp2p 中实现了多种节点发现协议：Rendezvous、mDNS 和 DHT<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is Discovery & Routing ](https://docs.libp2p.io/concepts/discovery-routing/overview/)">[5]</span></a></sup>，在这里，使用 DHT 来进行节点的发现，对应 go-libp2p 的子模块库是 go-libp2p-kad-dht。对于 Kademlia 协议，可以参考 <a href="https://decision01.com/2022/09/27/Kademlia%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%B9%BF%E6%92%AD%E6%96%B9%E6%B3%95/">Kademlia 协议及广播方法</a> (没写完，可以看看参考文章)此外， go-libp2p-kad-dht 的使用还可以在本文之外参考 <a href="https://ldej.nl/post/building-an-echo-application-with-libp2p/">Building an echo application with libp2p</a><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Building an echo application with libp2p](https://ldej.nl/post/building-an-echo-application-with-libp2p/)">[4]</span></a></sup></p><p>有了节点连接建立的基础后，节点的发现和连接就较为简单了（代码量不大，麻烦的是查阅资料）</p><h2 id="KDHT-实例创建"><a href="#KDHT-实例创建" class="headerlink" title="KDHT 实例创建"></a>KDHT 实例创建</h2><p>使用 go-libp2p-kad-dht 需要创建一个 kdht 实例，在完成 host 的创建后可以传入 <code>host</code> 来建立实例，并且调用 <code>Bootstrap</code> 来启动路由的维护，以下是创建 kdht 实例的代码，传入的参数 <code>bootstrapPeers</code> 是启动节点数组，分两种情况考虑：</p><ul><li>空数组：没有启动节点，自身作为一个启动节点</li><li>非空数组：启动节点列表，依次遍历所有的节点地址并且尝试连接，在建立连接后可以发现其他节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKDHT</span><span class="params">(ctx context.Context, host host.Host, bootstrapPeers []multiaddr.Multiaddr)</span></span> (*dht.IpfsDHT, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> options []dht.Option</span><br><span class="line"><span class="comment">// Start with server mode</span></span><br><span class="line">options = <span class="built_in">append</span>(options, dht.Mode(dht.ModeServer))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create new kad-dht instance</span></span><br><span class="line">kdht, err := dht.New(ctx, host, options...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create new kad-dht instance failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bootstrap the kad-dht instance</span></span><br><span class="line"><span class="keyword">if</span> err = kdht.Bootstrap(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Bootstrap kad-dht failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, peerAddr := <span class="keyword">range</span> bootstrapPeers &#123;</span><br><span class="line">info, _ := peer.AddrInfoFromP2pAddr(peerAddr)</span><br><span class="line"><span class="keyword">if</span> err := host.Connect(ctx, *info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorf(<span class="string">&quot;Errored while connecting to node #%s&quot;</span>, *info)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logrus.Infoln(<span class="string">&quot;Connection established with bootstrap node: %q&quot;</span>, *info)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kdht, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由表查询"><a href="#路由表查询" class="headerlink" title="路由表查询"></a>路由表查询</h2><p>在完成 kad-dht 实例的创建后，可以通过它来进行路由表的查询以发现其他节点</p><p>这个过程的初始化需要以下对象：</p><ul><li>context：上下文，以便同步关闭协程</li><li>host：创建的节点实例，用于发起流的创建</li><li>dht：创建的 kad-dht 实例，用于进行路由表中其他节点的发现</li><li>rendezvous：节点发现”密钥“，被称为”集合点”，节点们通过这个值来查找到对等的节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Discover</span><span class="params">(ctx context.Context, h host.Host, dht *dht.IpfsDHT, rendezvous <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create new discovery object</span></span><br><span class="line"><span class="keyword">var</span> routingDiscovery = routing.NewRoutingDiscovery(dht)</span><br><span class="line">dutil.Advertise(ctx, routingDiscovery, rendezvous)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh per 500ms</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            <span class="comment">// Refresh routing table</span></span><br><span class="line">dht.RefreshRoutingTable()</span><br><span class="line">            <span class="comment">// Find other peers</span></span><br><span class="line">peers, err := routingDiscovery.FindPeers(ctx, rendezvous)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithField(<span class="string">&quot;error&quot;</span>, err).Debugln(<span class="string">&quot;Find peers failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">                <span class="comment">// Check whether is self host</span></span><br><span class="line"><span class="keyword">if</span> p.ID == h.ID() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check connected</span></span><br><span class="line"><span class="keyword">if</span> h.Network().Connectedness(p.ID) != network.Connected &#123;</span><br><span class="line">_, err := h.Network().DialPeer(ctx, p.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithFields(logrus.Fields&#123;</span><br><span class="line"><span class="string">&quot;peerID&quot;</span>: p.ID,</span><br><span class="line"><span class="string">&quot;error&quot;</span>:  err,</span><br><span class="line">&#125;).Debugln(<span class="string">&quot;Connect to node failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">stream, err := h.NewStream(ctx, p.ID, <span class="string">&quot;/echo/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Create new stream failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... some function with stream</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在较老的版本中，rendezvous 是通过 <code>discovery.Advertise(ctx, routingDiscovery, rendezvous)</code> 来“宣布”的，但是在目前的版本下貌似不能生效，需要使用 <code>dutil.Advertise(ctx, routingDiscovery, rendezvous)</code></p><p>而最为关键的也是 ticker 的处理函数，<code>dht.RefreshRoutingTable()</code> 刷新路由表，然后使用 <code>FindPeers</code> 函数在“集合点”发现其他节点；它会返回一个 具有一系列 Peer 的 channel，遍历这个 channel 可以获取到对端节点的信息</p><p>并且在得到节点信息后需要根据节点 id 是否为自身，否则会和本地的节点建立流，以及查询是否以及建立了连接，以便在建立数据流之前建立连接。在完成流的建立后，可以基于这个流来进行节点间的通信。要实现一个可以指定节点 id 发送消息的应用，可以添加其他逻辑代码后实现。</p><h1 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h1><p>消息广播对应的库是 <a href="https://github.com/libp2p/go-libp2p-pubsub">go-libp2p-pubsub</a>，目前所实现的广播路由方式有：1、Gossip 协议<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[一致性算法-Gossip协议详解](https://cloud.tencent.com/developer/article/1662426)">[6]</span></a></sup>；2、 Flood 洪泛协议<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[洪泛路由](https://zh.wikipedia.org/wiki/%E6%B4%AA%E6%B3%9B%E8%B7%AF%E7%94%B1)">[7]</span></a></sup>；3、 随机路由；同时，go-libp2p 的文档中也写了发布/订阅模式的相关原理<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is Publish/Subscribe](https://docs.libp2p.io/concepts/pubsub/overview/)">[8]</span></a></sup>，但是没有涉及到具体的使用；</p><p>消息的广播和订阅涉及到四个函数:</p><ul><li><code>NewGossipSub</code>：创建一个 Gossip 广播对象，go-libp2p 底层会创建流，gossip 所使用的的是其底层建立的流，且创建的对象是一个单例</li><li><code>Join</code>：加入一个 topic，并返回一个 <code>Topic</code> 对象，调用其 <code>Subscribe</code> 函数进行订阅</li><li><code>Subscribe</code>：订阅 topic，返回 <code>Subscription</code> 对象，用于后续接收其他节点广播的消息</li><li><code>Publish</code>：广播消息到某个 topic，向订阅了该 topic 的所有节点发送消息</li></ul><p><strong>注：go-libp2p-pubsub 默认的消息限制为 1M，所以大于 1M 的消息无法广播到其他节点会被直接丢弃</strong></p><p>前三个函数在具体使用时如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">goosip, err := pubsub.NewGossipSub(ctx, h)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Create new gossip subscribe failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topic, err := goosip.Join(<span class="string">&quot;/gossip/1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Join topic /gossip/1.0.0 failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub, err := topic.Subscribe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logrus.WithError(err).Errorln(<span class="string">&quot;Subscribe topic failed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，sub 对象需要一个协程来专门进行处理，协程可以从中取出消息并且进行处理，这个函数通常实现为下面的样子，持续取出消息并且判断是否是自身发出的广播消息，如果是则丢弃，否则进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSub</span><span class="params">(ctx context.Context, sub *pubsub.Subscription, h host.Host)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := sub.Next(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Get data from subscription failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> msg.ReceivedFrom == h.ID() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... do something with msg.Data</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，还需要使用 <code>Publish</code> 进行消息的广播，这也较为简单，可以编写一个函数从 channel 中读出消息并且广播到网络中，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcastMessage</span><span class="params">(msgChan <span class="keyword">chan</span> <span class="type">string</span>, topic *pubsub.Topic)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-msgChan:</span><br><span class="line">err := topic.Publish(context.Background(), []<span class="type">byte</span>(msg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Errorln(<span class="string">&quot;Publish message failed.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go-libp2p-pubsub 在发送时会将它打包到一个定义好的 proto 结构体中，序列化后发送，所以在 <code>handleSub</code> 中还需要通过 <code>msg.Data</code> 获取字节数据</p><h1 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h1><p>最后这里放一些使用时会遇到的配置问题，go-libp2p 中会有许多的自定义配置，但是在文档中都没有一一列举，只能自行查阅代码</p><h3 id="网络资源限制"><a href="#网络资源限制" class="headerlink" title="网络资源限制"></a>网络资源限制</h3><p>资源管理器可以用来限制节点对流的创建、连接的创建所消耗的网络资源，这里需要一个函数来创建一个资源管理器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildResourceManager</span><span class="params">()</span></span> *network.ResourceManager &#123;</span><br><span class="line">scalingLimits := rcmgr.DefaultLimits</span><br><span class="line">libp2p.SetDefaultServiceLimits(&amp;scalingLimits)</span><br><span class="line">scaledDefaultLimits := scalingLimits.AutoScale()</span><br><span class="line"></span><br><span class="line">cfg := rcmgr.PartialLimitConfig&#123;</span><br><span class="line">System: rcmgr.ResourceLimits&#123;</span><br><span class="line"><span class="comment">//Conns: 20,</span></span><br><span class="line">Streams: <span class="number">50</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">limits := cfg.Build(scaledDefaultLimits)</span><br><span class="line">limiter := rcmgr.NewFixedLimiter(limits)</span><br><span class="line">rm, err := rcmgr.NewResourceManager(limiter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorln(<span class="string">&quot;Build resource manager failed.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;rm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里限制了流的最大数量为50，在节点启动前可以创建这样一个资源管理器，并且引入到节点配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host, err := libp2p.New(</span><br><span class="line">    libp2p.ResourceManager(*rm),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更多的配置需要参阅：<a href="https://pkg.go.dev/github.com/srene/go-libp2p/p2p/host/resource-manager">The libp2p Network Resource Manager</a></p><h3 id="广播调整"><a href="#广播调整" class="headerlink" title="广播调整"></a>广播调整</h3><p>正如前面所说，go-libp2p-pubsub 中限制了最大广播数据大小为 1M，在某些场景下是不够的，所以需要进行调整</p><p>这需要在创建 Gossip 对象的时候引入配置，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pubsubMaxSize = <span class="number">1</span> &lt;&lt; <span class="number">22</span> <span class="comment">// 4 MB</span></span><br><span class="line"></span><br><span class="line">gossip, err = pubsub.NewGossipSub(ctx, h,</span><br><span class="line">    pubsub.WithMaxMessageSize(pubsubMaxSize),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过这样的代码可以将广播调整为 4M 内进行广播，其他的配置目前笔者还没有涉及到，在未来涉及到更多的自定义配置时会更新到这里。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1988253">长安链P2P网络技术介绍（2）：初识LibP2P</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/superblockchain/p/14103338.html">从 go-libp2p 开始</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/libp2p/specs/blob/master/addressing/README.md">Addressing in libp2p</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://ldej.nl/post/building-an-echo-application-with-libp2p/">Building an echo application with libp2p</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.libp2p.io/concepts/discovery-routing/overview/">What is Discovery &amp; Routing </a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1662426">一致性算法-Gossip协议详解</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E6%B4%AA%E6%B3%9B%E8%B7%AF%E7%94%B1">洪泛路由</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.libp2p.io/concepts/pubsub/overview/">What is Publish/Subscribe</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p&gt;做区块链相关的项目</summary>
      
    
    
    
    <category term="Dev" scheme="https://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="https://decision01.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 指标监控</title>
    <link href="https://decision01.com/post/cc6b7110.html"/>
    <id>https://decision01.com/post/cc6b7110.html</id>
    <published>2023-08-01T07:57:27.000Z</published>
    <updated>2024-12-24T15:03:00.804Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Prometheus 是由 SoundCloud 开源的监控告警解决方案<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Prometheus学习笔记（1）Prometheus架构简介](https://www.cnblogs.com/linuxk/p/12017580.html)">[3]</span></a></sup>,它可以被用于程序暴露一系列监控指标给外界，用于对程序的性能、运行状态进行监控，并且还提供了监控告警功能。</p><h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p>以下是官方给出的架构图</p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/006tNbRwly1fwcgsn11fej311j0mjadw.jpg" alt="Prometheus 架构图" style="zoom:50%;"><p>在图中，Prometheus 的组成部分有<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Prometheus学习笔记（1）Prometheus架构简介](https://www.cnblogs.com/linuxk/p/12017580.html)">[3]</span></a></sup>：</p><ul><li>Prometheus Server：抓取和存储时间序列化数据</li><li>Exporters：主动拉取数据的插件</li><li>Pushgateway：被动拉取数据的插件</li><li>Altermanager：告警信息发送模块</li><li>Prometheus web UI：界面化，包含结合 Grafana 进行数据展示或告警发送</li></ul><p>其工作逻辑如下<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Prometheus](https://jimmysong.io/kubernetes-handbook/practice/prometheus.html)">[4]</span></a></sup>：</p><ol><li>Prometheus server 定期从静态配置的目标（target）或服务发现的目标中拉取指标（metric）数据；</li><li>拉取数据大于内存缓冲区大小时，将数据持久化到数据库（时序数据库）；</li><li>Prometheus 可以配置规则，用于定时查询数据，在条件触发时将警告推送到配置的 Altermanager；</li><li>Altermanager 受到告警时，可以根据配置，聚合、去重、降噪，最后发送警告；</li><li>可以使用 API、Prometheus Console 或者 Grafana 查询和聚合数据；</li></ol><h1 id="四大指标类型"><a href="#四大指标类型" class="headerlink" title="四大指标类型"></a>四大指标类型</h1><p>这里主要是 Golang 下的 Prometheus 指标，需要其它语言可以根据需求查找<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[程序监控（一）Prometheus的四种类型及golang示例](https://zhuanlan.zhihu.com/p/592560633)">[1]</span></a></sup></p><p>Prometheus 定义了四种不同的指标类型<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Metrics类型](https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-metrics-types)">[2]</span></a></sup>：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）</p><ul><li><p><strong>Counter</strong>：只增不减的计数器</p><p>  Counter Metrics 是<strong>只能递增</strong>的值，可以一用来记录 API 的请求次数、错误码的触发次数，它的接口如下</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter by 1. Use Add to increment it by arbitrary non-negative values.</span></span><br><span class="line">    <span class="comment">// Inc 方法会为计数器 +1</span></span><br><span class="line">Inc()</span><br><span class="line"><span class="comment">// Add adds the given value to the counter. It panics if the value is &lt; 0.</span></span><br><span class="line">    <span class="comment">// 传入一个 value 为计数器添加对应的值，如果小于 0 会报 painc</span></span><br><span class="line">Add(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Gauge</strong>：可增可减的仪表盘</p><p>  Gauge Metrics 侧重于反应系统当前的状态，这样的数据<strong>可增可减</strong>，也可以直接设置，常用于显示当前主机的空闲内容大小、可用的内存大小，其接口如下</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Gauge <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the Gauge to an arbitrary value.</span></span><br><span class="line">    <span class="comment">// 为该指标设置一个值</span></span><br><span class="line">Set(<span class="type">float64</span>)</span><br><span class="line"><span class="comment">// Inc increments the Gauge by 1. Use Add to increment it by arbitrary values.</span></span><br><span class="line">    <span class="comment">// 为该指标增加 1</span></span><br><span class="line">Inc()</span><br><span class="line"><span class="comment">// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary values.</span></span><br><span class="line">    <span class="comment">// 为该指标减少 1</span></span><br><span class="line">Dec()</span><br><span class="line">    <span class="comment">// 为指标增加一个指定值</span></span><br><span class="line"><span class="comment">// Add adds the given value to the Gauge. (The value can be negative, resulting in a decrease of the Gauge.)</span></span><br><span class="line">Add(<span class="type">float64</span>)</span><br><span class="line">    <span class="comment">// 为减去一个指定值</span></span><br><span class="line"><span class="comment">// Sub subtracts the given value from the Gauge. (The value can be negative, resulting in an increase of the Gauge.)</span></span><br><span class="line">Sub(<span class="type">float64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetToCurrentTime sets the Gauge to the current Unix time in seconds.</span></span><br><span class="line">SetToCurrentTime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Histograms</strong>：指定范围的直方图</p><p>  Histograms 是直方图度量类型，测量落在定义的桶中的数据的数据的值，可以用于记录 API 服务的请求耗时在所有桶中的分布情况、或者消费者处理某个事件的好事在所有桶中的分布情况，其接口也比较简单</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Histogram <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observe adds a single observation to the histogram. Observations are</span></span><br><span class="line"><span class="comment">// usually positive or zero. Negative observations are accepted but</span></span><br><span class="line"><span class="comment">// prevent current versions of Prometheus from properly detecting</span></span><br><span class="line"><span class="comment">// counter resets in the sum of observations. (The experimental Native</span></span><br><span class="line"><span class="comment">// Histograms handle negative observations properly.) See</span></span><br><span class="line"><span class="comment">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span></span><br><span class="line"><span class="comment">// for details.</span></span><br><span class="line">    <span class="comment">// 传入一个观察值，这个值通常是大于等于 0 的数，负的值也可以接受</span></span><br><span class="line">    <span class="comment">// 但是导致检测观测值总和中的计时器不能正常重置</span></span><br><span class="line">Observe(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Summary</strong>：分位数下的直方图</p><p>  Summary 和 Histograms 一样是统计直方图数据，但是也存在不一样的地方：</p><ul><li><p>Summary 基于分位数来统计数据，而 Histogram 基于桶来统计数据</p></li><li><p>Histogram 的分位数在 Prometheus 上计算，而 Summary 则是在提供度量数据的应用上来计算，此后再暴露数据到接口外</p></li><li><p>Summary 用于需要计算准确的分位数，但是并不能知道值的精确范围</p><p>它的接口和 Histogram 类似</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Summary <span class="keyword">interface</span> &#123;</span><br><span class="line">Metric</span><br><span class="line">Collector</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observe adds a single observation to the summary. Observations are</span></span><br><span class="line"><span class="comment">// usually positive or zero. Negative observations are accepted but</span></span><br><span class="line"><span class="comment">// prevent current versions of Prometheus from properly detecting</span></span><br><span class="line"><span class="comment">// counter resets in the sum of observations. See</span></span><br><span class="line"><span class="comment">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span></span><br><span class="line"><span class="comment">// for details.</span></span><br><span class="line">Observe(<span class="type">float64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="实时指标监控"><a href="#实时指标监控" class="headerlink" title="实时指标监控"></a>实时指标监控</h1><p>使用 Prometheus 对程序进行监控并且实时观察指标有三个步骤：</p><ul><li>在程序中编写指标监控代码，并且暴露一个http服务便于外界拉取数据；</li><li>安装 Prometheus 服务端，在配置文件下指定需要监控的 http 链接并启动；</li><li>进一步地，如果需要对多个指标同时进行实时的查看，可以安装 Grafana 进行数据的实时监控；</li></ul><h2 id="指标服务及代码"><a href="#指标服务及代码" class="headerlink" title="指标服务及代码"></a>指标服务及代码</h2><p>要对外界暴露指标的服务接口，需要指定端口并启动服务，在 golang 中暴露 mertics 服务的代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中获取端口</span></span><br><span class="line">metricPort := <span class="string">&quot;:&quot;</span> + config.String(<span class="string">&quot;metrics.port&quot;</span>)</span><br><span class="line">http.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line"><span class="comment">// 启动协程进行服务</span></span><br><span class="line"><span class="keyword">go</span> http.ListenAndServe(metricPort, <span class="literal">nil</span>)</span><br><span class="line">log.Infof(<span class="string">&quot;Metric server start on localhost%s&quot;</span>, metricPort)</span><br></pre></td></tr></table></figure><p>此外，还需要注册指标并且对指标进行操作，例如，使用仪表盘来监控一个节点下的交易数量，需要注册一个仪表盘指标</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">poolTransactionsMetric = promauto.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">&quot;core_tx_pool_transactions&quot;</span>,</span><br><span class="line">Help: <span class="string">&quot;Transaction count in memory pool.&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在接收交易时，可以通过调用 <code>Inc</code> 方法来对指标 +1</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poolTransactionsMetric.Inc()</span><br></pre></td></tr></table></figure><p>类似地，可以调用 <code>Dec</code> 方法在打包交易时对指标 -1</p><p>假设暴露的端口是 9090，在完成这些工作后可以访问 <a href="http://localhost:8700/metrics">http://localhost:8700/metrics</a> 得到指标数据，这些指标表现为键值对的形式</p><p>而 Prometheus 的服务端就是根据配置文件，每隔一段时间访问 targets 来获取指标数据并进行解析，并且放入内存、数据库</p><h2 id="Prometheus-安装以及配置"><a href="#Prometheus-安装以及配置" class="headerlink" title="Prometheus 安装以及配置"></a>Prometheus 安装以及配置</h2><p>Prometheus 本身是一个开源项目，所以可以直接安装程序并启动，例如目前最新的已编译好的安装包在 <a href="https://github.com/prometheus/prometheus/releases/tag/v2.46.0">Prometheus 2.46.0</a></p><p>此外，也有 windows 下的安装教程 <a href="https://blog.csdn.net/qq_38362419/article/details/108527506">Windows 安装 prometheus + grafana</a></p><p>以及在安装后需要修改配置文件 <code>prometheus.yml</code>，一个简单的配置文件如下：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">1s</span><span class="comment"># 监控间隔时间，每隔多少时间拉取一次数据</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;prometheus&quot;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="comment"># 监控的目标，这里是一个 ip:port 数组</span></span><br><span class="line">        <span class="string">&quot;localhost:8700&quot;</span>,</span><br><span class="line">        <span class="string">&quot;localhost:8701&quot;</span>,</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure><p>如果配置文件中没有设置端口，默认会使用 9090 端口来暴露 Prometheus 的数据查询服务</p><p>最后，Grafana 的安装和使用不再进行赘述，Grafana 类似一个数据库查询展示工具，它通过拉取 Prometheus 暴露的数据查询服务来得到信息并在前端进行展示，例如对节点的一系列指标监控如下</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/QQ20230703-110943@2x.png" alt="QQ20230703-110943@2x"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/592560633">程序监控（一）Prometheus的四种类型及golang示例</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-metrics-types">Metrics类型</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/linuxk/p/12017580.html">Prometheus学习笔记（1）Prometheus架构简介</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://jimmysong.io/kubernetes-handbook/practice/prometheus.html">Prometheus</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Prometheus 是由 SoundCloud 开源的监控告警解决方案&lt;s</summary>
      
    
    
    
    <category term="Dev" scheme="https://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="https://decision01.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Json Web Token</title>
    <link href="https://decision01.com/post/9f5baac8.html"/>
    <id>https://decision01.com/post/9f5baac8.html</id>
    <published>2023-07-16T13:35:55.000Z</published>
    <updated>2024-04-08T08:03:49.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Json Web Token (JWT) 是一个开放标准（RFC 7519），它符合设计 Restful API 时的<strong>无状态原则</strong>，每一次从客户端向服务器发出的请求都是独立的。</p><p>JWT 由三个部分组成：Header、Payload 和 Signature，它是一个长字符串，每个子串之间不存在换行符，一般的格式是<code>[Header].[Payload].[Signature]</code></p><p>其 <code>Header</code> 承载了两部分信息：类型和所使用的密码算法，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Payload</code> 存放了实际需要传递的数据，JWT 中所规定的 7 个可选用的常规字段如下，负载默认是不会进行加密的，所以<strong>不可以用来存放秘密信息</strong></p><table><thead><tr><th>Field</th><th>Name</th><th>Desc</th></tr></thead><tbody><tr><td>iss</td><td>Issuer</td><td>签发人</td></tr><tr><td>exp</td><td>Expiration Time</td><td>过期时间</td></tr><tr><td>sub</td><td>Subject</td><td>主题</td></tr><tr><td>aud</td><td>Audience</td><td>受众</td></tr><tr><td>nbf</td><td>Not Before</td><td>生效时间</td></tr><tr><td>iat</td><td>Issued At</td><td>签发时间</td></tr><tr><td>jti</td><td>JWT ID</td><td>编号</td></tr></tbody></table><p><code>Signature</code> 是对前面两部分消息的签名，以避免数据被篡改，<strong>签名的密钥只有服务器知道</strong>，使用 <code>Header</code> 指定的签名算法来产生签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAMAC-SHA256(base64(header) + &quot;.&quot; + base64(payload), secret)</span><br></pre></td></tr></table></figure><p>客户端在通过认证后接收服务器返回的 JWT，将其存放在 cookie 或 localStorage 中，此后客户端会在与服务器的交互中都携带 JWT 以表明自身身份</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;Json Web Token (JWT) 是一个开放标准（RFC 7519）</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="cryptography" scheme="https://decision01.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Golang 泛型编程</title>
    <link href="https://decision01.com/post/26091937.html"/>
    <id>https://decision01.com/post/26091937.html</id>
    <published>2023-06-18T08:02:33.000Z</published>
    <updated>2024-12-24T15:01:58.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>这里涉及到要学习泛型是由于工程里面遇到一个问题，<a href="https://github.com/inkeliz/karmem">karmem</a> 下在序列化和反序列化的时候所编写的代码在很大程度上是相似的</p><p>于是解决方案就是为不同的结构体都写对应的序列化和反序列化函数来封装</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeGeneralParams</span><span class="params">(byteParamsData []<span class="type">byte</span>)</span></span> (*common.GeneralParams, <span class="type">error</span>) &#123;</span><br><span class="line">generalParams := <span class="built_in">new</span>(common.GeneralParams)</span><br><span class="line">generalParams.ReadAsRoot(karmem.NewReader(byteParamsData))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generalParams, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样又存在一个问题，每次新增结构体都需要 copy 新的函数为它进行反序列化和序列化，那么就特别麻烦，所以考虑能不能通过泛型实现类似下面的操作</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeKarmemStruct</span>[<span class="title">T</span> <span class="title">KarmemStruct</span>]<span class="params">(byteParamsData []<span class="type">byte</span>)</span></span> (*T, <span class="type">error</span>) &#123;</span><br><span class="line">generalParams := <span class="built_in">new</span>(T)</span><br><span class="line">T.ReadAsRoot(karmem.NewReader(byteParamsData))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generalParams, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将一系列 Karmem 生成的类的反序列化放到一起，现在看完了泛型的一系列东西后貌似无法解决这个问题（？</p></blockquote><h1 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h1><p>在一个简单的实现加法的函数中，函数上写明的 <code>a int, b int</code> 是<strong>形参</strong>（Parameter）列表，只有在调用时传入的值才是<strong>实参</strong>（Argument）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>将形参和实参的概念进行推广，给类型引入类似形参和实参的概念后，就可以有类型形参（Type Paramether） 和类型实参（Type Argument）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 是这里的类型形参，在定义函数时类型补确定，只有在函数被调用时再传入具体的类型，这里被传入的具体类型就是类型实参</p><p>传入类型实参的方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add[T=<span class="type">int</span>](<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><p><strong>问题提出</strong></p><p>考虑一个例子</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a IntSlice = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b IntSlice = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>b</code> 的赋值不能实现，这是由于 <code>IntSlice</code> 的底层类型是 <code>[]int</code>，浮点类的 Slice 不能进行赋值</p><p>如果需要不同类型的切片，可以考虑为每种类型都定义新的类型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Float32Slice []<span class="type">float32</span></span><br></pre></td></tr></table></figure><p><strong>解决方法</strong></p><p>这样为每个不同的成员类型定义新类型的方法<strong>极为繁琐</strong>，所以就要使用到泛型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>|<span class="type">float32</span>|<span class="type">float64</span>] []T</span><br></pre></td></tr></table></figure><ul><li><code>T</code> 是<strong>类型形参（Type Parameter）</strong>，定义 Slice 时其代表的类型不确定，它是一个占位符</li><li><code>int|float32|float64</code> 是<strong>类型约束（Type Constraint）</strong>，用于说明类型形参只能接受哪些类型的实参（有点类似于对形参的类型定义）</li><li><code>T</code> 和 <code>int|float32|float64</code> 构成了<strong>类型形参列表（Type Parameter List）</strong></li></ul><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><p>使用类型形参来替代原有的类型，可以定义一个泛型函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">float32</span>|<span class="title">float64</span>] <span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前实现不同的是这里添加了类型约束，保证函数的类型只能使用这三种类型，使用泛型函数需要传入类型实参</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add[<span class="type">int</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Add[<span class="type">float32</span>](<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>也可以直接传入参数让编译器自行推导类型实参（让编译器推导类型后传入参数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add(1, 2)</span><br><span class="line">Add(1.0, 2.0)</span><br></pre></td></tr></table></figure><p>需要注意的是下面两种情况不能使用泛型函数：</p><ul><li><p>在匿名函数中使用未定义的类型形参（但是可以使用已定义的形参）</p></li><li><p>不支持泛型方法，即 receiver 下不能支持泛型</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A)</span></span> Add[T <span class="type">int</span>|<span class="type">float32</span>|<span class="type">float64</span>](a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但是可以通过 receiver 来使用类型形参</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span></span> Add(a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a A[<span class="type">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="type">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="组合与底层类型"><a href="#组合与底层类型" class="headerlink" title="组合与底层类型"></a>组合与底层类型</h1><p>考虑现在一个泛型类型下有一系列类型的类型约束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>|<span class="type">int8</span>|<span class="type">int16</span>|<span class="type">int32</span>|...|<span class="type">uint32</span>|<span class="type">uint64</span>] []T;</span><br></pre></td></tr></table></figure><p>为了实现对这样的代码进行维护，可以对类型进行分类后把类型约束写入到接口类型中，即可以在类型约束中进行嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span>|<span class="type">int8</span>|<span class="type">int16</span>|<span class="type">int32</span>|<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line"> <span class="type">uint</span>|<span class="type">uint8</span>|<span class="type">uint16</span>|<span class="type">uint32</span>|<span class="type">uint64</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int|Uint] []T</span><br></pre></td></tr></table></figure><p>如果要使得最终的类型定义更为简单，可以在 <code>interface</code> 中进行嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">Int|Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><p>通过 <code>interface</code> 进行嵌套并在类型约束中进行组合的方式，就可以使得后续对代码的维护更为方便。但是这样的方式存在的缺陷是，如果类型约束中包含了一种类型 <code>type1</code>，另外一种类型通过 <code>type1</code> 定义了 <code>type type2 type1</code>，这样的情况下就不能满足类型约束条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]</span><br></pre></td></tr></table></figure><p>这样的代码在第四行是错误的，因为虽然其底层类型是 <code>int</code>，但是它自身并不是 <code>int</code> 类型，不符合类型约束</p><p>于是可以使用 <code>~</code> 来表示类型约束的底层类型，例如 <code>type Slice [T ~int|~float32]</code>，这样只要底层类型满足约束条件即可，使用该符号的限制是</p><ul><li>符号后类型不能是接口</li><li>符号后类型必须为底层类型</li></ul><h1 id="类型集"><a href="#类型集" class="headerlink" title="类型集"></a>类型集</h1><p>在 Go 1.18 之前， Go 官方对接口的定义是：</p><blockquote><p>An interface type specifies a method set called its interface</p></blockquote><p>对于 <code>ReaderWriter</code> 接口，它定义了一个接口，这个集合中包含了 <code>Read</code> 和 <code>Write</code> 两种方法，所有同时定义了这两种方法的类型被称为实现了该接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderdWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err error0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从另外一个角度来看，<code>ReaderWriter</code> 可以是一个类型的集合，所有实现了其包含的两个方法的类型都在接口代表的类型集合中，这样就是一个类型集（Type Set）</p><p>在可以使用接口来简化类型约束后，接口就有了定义类型集的作用，在原来的功能上，它只是定义一系列的方法，所以是方法集</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">Int|Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><p>在这里，类型接口 <code>SliceElement</code> 是一个类型集合，所有满足约束 <code>Int|Uint</code> 的类型都在这一类型集中</p><p><code>type Slice[T SliceElement] []T</code>中，类型约束指定了形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化</p><p>原有的实现某个接口的定义是：<strong>实现了一个接口的所有方法那么就隐式地实现了这个接口</strong></p><p>而现在，如果类型 T 满足下面的条件，那么就说它实现了接口 I:</p><ul><li>T 不是接口时：<strong>类型</strong> T 是接口 I 代表的类型集中的<strong>一个成员</strong></li><li>T 是接口时：T 接口代表的类型集是 I 代表的类型集合的<strong>子集</strong></li></ul><h2 id="基本接口和一般接口"><a href="#基本接口和一般接口" class="headerlink" title="基本接口和一般接口"></a>基本接口和一般接口</h2><p>基本接口：在 Go 1.18 前的方法集，即接口定义中只有方法的接口被称为基本接口</p><p>一般接口：而如果一个接口中不只有方法，还有类型，那么这样的接口就被称为一般接口</p><p><strong>一般接口类型不能用于定义变量，只能用于进行泛型的约束</strong></p><p>到这里该写的也写的差不多了，剩下一些东西可以在 <a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a> 里翻一下，里面写的比较详细</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a></li><li><a href="https://alankrantas.medium.com/%E7%B0%A1%E5%96%AE%E7%8E%A9-go-1-18-%E6%B3%9B%E5%9E%8B-1d09da07b70">https://alankrantas.medium.com/%E7%B0%A1%E5%96%AE%E7%8E%A9-go-1-18-%E6%B3%9B%E5%9E%8B-1d09da07b70</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;这里涉及到要学习泛型是由于工程里面遇到一个问题，&lt;</summary>
      
    
    
    
    <category term="Dev" scheme="https://decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="https://decision01.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>BIP、闪电网络与 Trao</title>
    <link href="https://decision01.com/post/4f925910.html"/>
    <id>https://decision01.com/post/4f925910.html</id>
    <published>2023-05-26T07:19:07.000Z</published>
    <updated>2024-12-24T15:00:54.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="BIP-标准"><a href="#BIP-标准" class="headerlink" title="BIP 标准"></a>BIP 标准</h1><p>比特币改进建议（Bitcoin Improvement Proposal, BIP）是 Amir Taaki 在2001年的 <a href="https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki">BIP-0001</a> 中提出，由 Luke Dash Jr. 在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki">BIP-0002</a> 中对该标准进行了扩展<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[什么是BIP？一分钟搞懂BIP标准](https://www.jinse.com/blockchain/465498.html)">[1]</span></a></sup>。</p><blockquote><p>BIP stands for Bitcoin Improvement Proposal. A BIP is a design document providing information to the Bitcoin community, or describing a new feature for Bitcoin or its processes or environment. The BIP should provide a concise technical specification of the feature and a rationale for the feature.</p><p>BIP 代表比特币改进提案。BIP是向比特币社区提供信息的设计文档，或描述比特币或其流程或环境的新功能。BIP 应提供该功能的简明技术规范和功能的基本原理。</p></blockquote><p>本文主要着重深入对闪电网络和 Trao 资产的研究，于是这里只会提及相关的部分标准。</p><h2 id="地址标准"><a href="#地址标准" class="headerlink" title="地址标准"></a>地址标准</h2><p>截止到今天，比特币区块链有四种不同的地址标准，分别是遗留（Legacy）地址，支付脚本哈希（Pay to Script Hash, P2SH）地址，隔离见证（SegWit）地址，主根（Taproot）地址<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[科普| 比特币地址有哪些？ - BlockBeats](https://m.theblockbeats.info/news/37101)">[2]</span></a></sup>。在本文中，和 Trao 资产最为相关的是最后一种地址 —— Traproot。</p><h3 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h3><p>Legacy 地址也被称为传统地址，它是比特币区块链诞生开始就使用的地址。这样的地址以1开头，其生成流程如下</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312207185.jpg" alt="Legacy(4)"></p><p>依据 <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-0032 (公钥分层推导标准)</a> 和 <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-0044 （派生路径标准）</a>，一个私钥可以对应派生出不同的公钥，由此也可以通过一个私钥管理多个地址。</p><p>由于在这里地址的生成过程中使用到了对公钥的哈希，这样的地址类型也被称为向公钥哈希支付（Pay to Public Key Hash, P2PKH）。这样的交易方式下，发送方需要在发送交易时嵌入 PubKey 脚本以将比特币发送给目标地址<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[比特币升级提案 Taproot 技术解读](https://www.btcstudy.org/2021/09/29/bitcoin-taproot-a-technical-explanation/)">[3]</span></a></sup>。</p><h3 id="P2SH"><a href="#P2SH" class="headerlink" title="P2SH"></a>P2SH</h3><p>P2SH 是另外一种地址类型，它被称为“向脚本支付”，从名称上就已经决定了这样的地址的使用方式和 Legacy 地址的不同，其地址以 3 开头。P2SH 是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP-0016</a> 中被提出，它被提出的动机是：</p><blockquote><p>The purpose of pay-to-script-hash is to move the responsibility for supplying the conditions to redeem a transaction from the sender of the funds to the redeemer.</p><p>The benefit is allowing a sender to fund any arbitrary transaction, no matter how complicated, using a fixed-length 20-byte hash that is short enough to scan from a QR code or easily copied and pasted.</p></blockquote><p>该标准定义了新的交易类型，使得提供花费UTxO所需的条件和责任由发送者转移到了接收者。先说说 BIP-0012：</p><p>而 P2SH 类型的地址是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki">BIP-0013</a> 中提出，在此之前提出的 <a href="https://github.com/bitcoin/bips/blob/master/bip-0012.mediawiki">BIP-0012</a> 中为了实现 P2SH 而尝试将预留的 OP_NOP1 操作码定义为新的 OP_EVAL 操作码，该操作码的功能是从栈顶弹出一个对象，对它反序列化后得到一个脚本代码，然后执行该脚本代码。但是该操作码在实现时没有准确地限制脚本语言运行时的栈的深度，这会导致执行脚本的节点在这里进入死循环，于是这一次软分叉在上线之前被放弃。</p><blockquote><p>O’Connor 在 <a href="https://github.com/bitcoin/bitcoin/issues/729">https://github.com/bitcoin/bitcoin/issues/729</a> 提出了这一漏洞：</p><p>在 OP_EVAL 的处理代码中，有这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">EvalScriptInner</span>(stack, subscript, txTo, nIn, nHashType, pbegincodehash, pendcodehash, nOpCount, nSigOpCount, fStrictOpEval, nRecurseDepth++))</span><br></pre></td></tr></table></figure><p>而 <code>nRecurseDepth++</code> 返回的是变量未递增的值，这会导致执行该操纵码时不会限制递归的深度。</p></blockquote><p>P2SH 类型的地址和 P2PKH 类型的地址生成过程是一样的，不同的地方在于最后进行 Base58-Check 的输入：</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312205969.png" alt="image-20230531220559720"></p><p>P2SH 定义了新的交易输出的类型，它在 scriptPubKey 中定义了新的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OP_HASH160][ScriptHash][OP_EQUAL]</span><br></pre></td></tr></table></figure><p>这使得发送者只需要在输出中指定使用该输出的发送方所提供的脚本需要满足的条件（脚本代码的hash对应），这样就将进行交易时的费用转移到了接收方而不是发送方，具体的实现原理见 <a href="https://learnmeabitcoin.com/technical/p2sh">How does P2SH work? - learn me a bitcoin</a> 以及脚本语言执行过程 <a href="https://learnmeabitcoin.com/technical/script">Script -A mini programming language</a></p><h3 id="SegWit"><a href="#SegWit" class="headerlink" title="SegWit"></a>SegWit</h3><p>SegWit 是隔离见证（Segregated Witness），隔离见证是一系列的 BIP 标准组成的：</p><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-0141 (共识层的隔离见证)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP-0143 (定义了新的交易签名算法，以减少验证时的冗余哈希)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-0144 (在节点层面定义交易的消息和序列化算法)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki">BIP-0145 (为 RPC 接口提供隔离见证的支持)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki">BIP-0147 (交易有效验证的规则更改))</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173 (为隔离见证提供的地址格式)</a></li></ul><p>隔离见证的用意是优化比特币交易和区块结构，将交易的签名（scriptSig）从交易中移到另外一个独立的结构中。</p><p>首先考虑比特币交易中的签名，对于 Pay-to-PubKey-Hash 交易，它的输出中的 scriptPubKey 脚本格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OP_DUP][OP_HASH160][PUBLIC_KEY][OP_EQUALVERIFY][OP_CHECKSIG]</span><br></pre></td></tr></table></figure><p>这部分脚本被称为锁定脚本，结合输入中的 scriptSig 形成一段脚本，由矿工在进行交易打包时进行验证，其具体的过程见<a href="https://learnmeabitcoin.com/technical/p2pkh">How does P2PKH work?</a></p><p>而进行隔离见证后，锁定脚本变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[VERSION][PUBLIC_KEY]</span><br></pre></td></tr></table></figure><p>在具有隔离见证功能的客户端上，只需要将两个值压栈，第一个数字上版本号，而第二个值是锁定脚本，而在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP - 0143</a> 中，规定了隔离见证的输出应该使用压缩公钥的哈希值来进行创建</p><p>同样地，在原有的另外一种交易类型 P2SH 下，锁定脚本中存放的是一个叫脚本的哈希值，尝试花费这笔 UTxO 的使用者需要提供满足哈希值的签名/口令来使用，在隔离见证后，输出的锁定脚本变为如下所示，这里进一步地减少了输出中的数据量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[VERSION] [SCRIPT_HASH]</span><br></pre></td></tr></table></figure><p>而在隔离见证下，交易的结构中多了一个 <code>witness</code> 字段，解锁 UTxO 的解锁脚本被存放在这一字段下</p><p>另外，为了进一步支持隔离见证交易，对于 SigWit 类型的交易的交易费用会进行“打折”，它原来的交易大小不变，但是在隔离见证下引入的“虚拟大小”比正常的交易更低</p><h3 id="Taproot"><a href="#Taproot" class="headerlink" title="Taproot"></a>Taproot</h3><p>Taproot，翻译为中文是“主根”。</p><blockquote><p><em>A taproot is a large, central, and dominant from which other roots sprout laterally.</em></p></blockquote><p>比特币区块链的 Traproot 升级由三个 BIP 标准组成：<a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP-0340 （Schnorr 签名）</a>、<a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP-0341 （Traproot）</a>和<a href="https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki">BIP-0342 （TapScript）</a></p><p>其中，BIP-0340 中引入了 Schnorr 签名，该签名方案的最大好处是可以聚合签名，它能够使得多位签名整合到一起，从而节省空间<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Schnorr签名对比特币有何意义？](https://academy.binance.com/zh/articles/what-do-schnorr-signatures-mean-for-bitcoin)">[7]</span></a></sup>。</p><h4 id="MAST"><a href="#MAST" class="headerlink" title="MAST"></a>MAST</h4><p>BIP-0341 中引入了默克尔抽象语法树（Merklized Abstract Syntax Tree, MAST）<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Merklized Abstract Syntax Tree](https://xiaohuiliu.medium.com/merkelized-abstract-syntax-tree-6a49b2008435)">[15]</span></a></sup><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Merklized Abstract Syntax Tree](https://www.mit.edu/~jlrubin/public/pdfs/858report.pdf)">[16]</span></a></sup><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[17]</span></a></sup>，其目的是隐藏 UTxO 的支出条件，并且减少信息的大小。这是 Taproot 升级的一部分，Taproot 升级将原有的 P2SH（Pay-to-Script-Hash） 和 P2PKH（Pay-to-Public-Key-Hash）结合在一起，使得一笔数输出可以直接通过私钥使用，也可以提供花费输出的脚本和默克尔证明来使用。</p><p>MAST 结合了抽象语义树和默克尔树，默克尔树作为一种在区块链中常见的数据结构，在这里不再进行赘述。而抽象语法树（AST）是一种把程序分割为独立的小块以描述程序的方法，这样会让程序变得容易分析和优化，具体可查阅<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax tree</a>。MAST 结合了 AST 的将程序划分为多个小块的思想，再把程序每个小块进行哈希，利用默克尔哈希树的思想把这些哈希结果构建为默克尔树。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202902204.png" alt="image-20230910202902204"></p><p>考虑这样一个脚本<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[17]</span></a></sup>：Alice 希望可以随时花费她的比特币，但是如果她连续三个月没有花费，那么她的兄弟姐妹 Bob 和 Charlie 就可以花费这笔 UTxO，其脚本实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_IF</span><br><span class="line">&lt;Alice&#x27;s pubkey&gt; OP_CheckSig</span><br><span class="line">OP_ELSE</span><br><span class="line">&quot;3 months&quot; OP_CSV OP_DROP</span><br><span class="line">2 &lt;Bob&#x27;s pubkey&gt; &lt;Charlie&#x27;s pubkey&gt; 2 OP_CHECKMULTISIG</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>在 P2SH 下，这样的脚本是需要在花费时完全暴露在交易中的，Alice 在花费这笔 UTxO 的同时需要提供该脚本，以及包含在其中的 Bob 和 Charlie 的公钥</p><p>而在有了 MAST 后，对该脚本的两个条件进行划分，得到一个简单的 MAST</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202920105.png" alt="image-20230910202920105"></p><p>此时，Alice 在花费的时候只需要选择提供她的公钥验证脚本和 Hash2 作为默克尔证明即可，而不需要暴露 Hash 2 下的具体脚本，这部分信息不会上链。而这样也进一步降低了类似交易的开销，这是很自然的，提供完整的脚本总是比提供脚本的哈希值的数据量少。而这样的结构也给智能合约的实现提供了可能，这样的方式正如 EVM 中的字节码一样，在运行前可以根据输入数据的前4个字节来选取将要调用的函数。不同地方在于，这样的脚本调用需要用户提供具体的脚本，以及默克尔证明来证明脚本是合法的。</p><h1 id="多重签名与PSBT"><a href="#多重签名与PSBT" class="headerlink" title="多重签名与PSBT"></a>多重签名与PSBT</h1><h2 id="多重签名"><a href="#多重签名" class="headerlink" title="多重签名"></a>多重签名</h2><p>多重签名正如其名字一样，一笔交易需要两个或者更多的签名才能生效，多重签名也被称为 <code>n-of-m</code> 交易，指该交易需要 $m$ 个签名者下的至少 $n$ 个签名才能生效</p><p>它的脚本形式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n [PUBLIC_KEY] [PUBLIC_KEY] [PUBLIC_KEY] ... [PUBLIC_KEY] m CHECKMULTISIG</span><br></pre></td></tr></table></figure><p>如果使用 P2PKH 的交易形式来实现多重签名，就需要发送交易的交易方来指定该脚本，并且输入一系列的签名者公钥匙，于是出现了 P2SH 来指定脚本哈希，使得这部分输入输入所产生的开销转移到了使用者</p><h2 id="PSBT"><a href="#PSBT" class="headerlink" title="PSBT"></a>PSBT</h2><p>PSBT 是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP-0174</a> 中所提出的标准，它被用来协助未签名交易（unsigned transactions）的传输</p><p>它可以允许多个签名者并行地对交易进行签名，然后再将交易组装为合成一个完整的 PSBT，目前 Ordinals 相关的交易平台的 Bid 和 Offer 就是利用了 PSBT 来实现</p><p>而 PSBT 也可以被用于实现多重签名</p><h1 id="Ordinals"><a href="#Ordinals" class="headerlink" title="Ordinals"></a>Ordinals</h1><h2 id="序数理论"><a href="#序数理论" class="headerlink" title="序数理论"></a>序数理论</h2><p>序数是一种比特币的编号方案，这是的跟踪和转移单个 sat 成为可能<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[概述 - 序数理论手册](https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu)">[13]</span></a></sup>，它按照每个比特币被挖掘出的顺序以及交易时根据先入先出的规则来进行编号</p><p>序数的表示方式：</p><ul><li>整数符号：<code>2099994106992659</code> 这个序号是根据挖掘聪的顺序分配。</li><li>十进制符号：<code>3891094.16797</code>，第一个数字是挖掘聪的区块高度，第二个数字是区块内聪的偏移量。</li><li>度数符号：<code>3°111094′214″16797‴</code>，具体的度数表示原理见序数理论手册<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[概述 - 序数理论手册](https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu)">[13]</span></a></sup></li><li>百分数符号：<code>99.99971949060254%</code>。以百分比表示聪在比特币供应中的位置。</li><li>名字：<code>satoshi</code>（聪）。使用字符a到z对序号进行编码。</li></ul><h2 id="铭刻"><a href="#铭刻" class="headerlink" title="铭刻"></a>铭刻</h2><p>铭文的铭刻利用了隔离见证后的特性<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[解读比特币Ordinals协议与BRC20标准的原理创新与局限](https://www.odaily.news/post/5187233)">[12]</span></a></sup>，即将见证脚本放入到交易本身之外的一个 <code>witness</code> 字段中，使用隔离见证的交易只需要 20% 的交易费用</p><p>铭文的相关内容被放入到脚本中，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OP_FALSE</span><br><span class="line">OP_IF</span><br><span class="line">OP_PUSH &quot;ord&quot;</span><br><span class="line">OP_1</span><br><span class="line">OP_PUSH &quot;text/plain;charset=utf-8&quot;</span><br><span class="line">OP_0</span><br><span class="line">OP_PUSH &quot;Hello, world!&quot;</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>在这里，<code>OP_1</code> 指示下一次压入包含内容类型，<code>OP_0</code> 指示后续数据压入包含内容本身</p><p>开头的 <code>OP_FALSE</code> 指令入栈后脚步立刻停止，但是由于隔离见证的特性，这部分数据依然在链上存在，所以 Ordinals Inscription 的本质是在比特币上借助这样一个用于不能被执行的脚步来实现一个记账的功能</p><p>所以，<strong>铭文的索引只能高度依赖链下的中心化索引</strong>，这样铭刻的一个铭文在链下会被记录到对应输出的第一个聪上，在 ordinals.com 中可以看到每个聪的相关信息，以及它是否存在铭刻的数据，目前索引这些铭文（Ordinals Inscription）的程序在 <a href="https://github.com/ordinals/ord">https://github.com/ordinals/ord</a> 维护</p><p>例如 <a href="https://ordinals.com/inscription/6fb976ab49dcec017f1e201e84395983204ae1a7c2abf7ced0a85d692e442799i0">inscription#0</a>，它被铭刻在了序数为 1252201400444387 的聪上</p><h1 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h1><p>闪电网络是建立在 Bitcoin 上的 Layer 2 解决方案，其目的是在 Bitcoin 的支付场景下帮助用户节省成本、提高效率。而闪电网络所依赖的思想也很简单，即构建资金池，这样的资金池也被称为交易双方的微支付通道。更具体一点，涉及到两个核心概念：</p><ul><li>Revocable Sequence Maturity Contract（RSMC）：序列到期可撤销合影</li><li>Hashed Timelock Contract（HTLC）：哈希时间锁定合约</li></ul><p>RSMC 假定了交易双方之间存在一个微支付通道，双方先存放一部分资金到这个通道中，初始情况下双方的分配方案就是预先存放的金额。在每一次发生交易时，双方都需要对交易后产生的分配结果进行确认，同时把原有的分配方案作废。这个过程涉及到的概念较多，而且比较巧妙，具体可参阅 <a href="https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2">A Dive into Lightning Network (Part One)</a><sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A Dive into Lightning Network (Part One)]([A Dive into Lightning Network (Part One)](https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2))">[18]</span></a></sup>，而它的作用是在闪电网络中的作用是构建双方之间的支付通道。</p><p>HTLC 是一种带事件的哈希锁定，它要求某一方在一定时间内提交某个哈希值 $h=H(m)$ 的原像 $m$ 以取得使用某一笔 UTxO 使用权。它在闪电网络中被用于构建支付路由，具体的实现过程见 <a href="https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8">Lightning network in depth, part 2: HTLC and payment routing</a><sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Lightning network in depth, part 2: HTLC and payment routing](https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8)">[19]</span></a></sup>。</p><p>闪电网络整合了这两种机制，使得交易可以在闪电网络中的任意两个节点间能够在链下完成。</p><h1 id="Taro"><a href="#Taro" class="headerlink" title="Taro"></a>Taro</h1><p>主根资产（Taproot Assets，后续简称为 Taro）<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What Is Taro in Bitcoin?](https://river.com/learn/what-is-taro-in-bitcoin/)">[20]</span></a></sup><sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot Assets](https://docs.lightning.engineering/the-lightning-network/taproot-assets)">[21]</span></a></sup><sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot Assets: A New Protocol for Multi-Asset Bitcoin and Lightning](https://www.youtube.com/watch?v=-yiTtO_p3Cw)">[22]</span></a></sup>是一种还在提议阶段的协议，它可以实现在 Bitcoin 上发行资产，这样的资产可以通过链上的交易通过比特币网络转移（对 NFT 的交易、转移已经被 Ordinals 实现）。特别地，同质化的 Taro 资产可以在存入闪电通道后在闪电网络上以更低的手续费、更为隐私地转移，类似的还有尝试在闪电网络上运行智能合约的 RGB 协议<sup id="fnref:23"><a href="#fn:23" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A BRIEF INTRODUCTION TO RGB PROTOCOLS](https://bitcoinmagazine.com/guides/a-brief-introduction-to-rgb-protocols)">[23]</span></a></sup>。</p><p>Taro 可以在 Bitcoin 主网或二层的闪电网络上流通。先考虑在 Bitcoin 网络的情况，Taro 是附加在交易上的<strong>哈希化元数据形式</strong>，使用哈希化的目的在于降低交易的占用空间以节省手续费。而这样的<strong>哈希化元数据形式</strong>则是 Taro 的核心，这样的一条哈希值甚至可以代表实际上的几百万次交易，它的原理会在后续进行介绍。</p><p>其次是 Taro 在闪电网络上的情况，使用闪电网络可以让同质化的 Taro 资产实现更快的交易速度，这类似于使用闪电网络可以更快、成本更低地转移比特币。在 Taro 的提议中，闪电网络自身不需要改变，为了实现一笔某种 Taro 资产的交易，只需要整条支付路径的第一条通道和最后一条通道可以识别 Taro 资产即可，而中途的路由通道则是正常的闪电网络转账方法，它们转账等价的比特币，这也导致 Taro 资产通常会在网络的边缘和其他资产交换。下图是 RIVER FINANCIAL 所展示的在闪电网络中实现 Taro 资产转移的过程。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/taro-lightning-network.png" alt="Taro assets exchanged on the Lightning Network"></p><h3 id="资产树"><a href="#资产树" class="headerlink" title="资产树"></a>资产树</h3><p>资产树是 Taro 中的一种两级默克尔树结构，它被用来代表 Taro 资产。第一级是由 Taro 信息作为叶子节点而构成的默克尔树，而第二级则是通过 MS-SMT 构成的表示每个账户所具有的该资产的树，MS-SMT 的思想较为简单，它在默克尔哈希树基于哈希来构成树形结构的同时，每个节点还存放了左右两个子节点的和来实现（进行哈希运算本身也算一种求和），这样的资产树和 MS-SMT 树被用来构建 Taro 的 UTxO。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910203608411.png" alt="image-20230910203608411"></p><p>资产叶（Aseet Leaft）是资产树中的最底层结构，它表现为资产树示意图中的淡蓝色节点，它以 assetScriptKey （assetScriptKey 可以类比 P2SH 交易中对交易脚本的哈希值）作为键。每个资产叶表示 Taro 资产的一个 UTxO，资产叶中包含的可选项可参见 <a href="https://medium.com/nayuta-en/understanding-taproot-assets-protocol-e2dfe3fc1e07">Understanding Taproot Assets Protocol</a>。</p><h3 id="Taro-资产发行"><a href="#Taro-资产发行" class="headerlink" title="Taro 资产发行"></a>Taro 资产发行</h3><p>Taro 资产的发行需要一个标识符，正如 ERC-20 代币的智能合约会拥有一个地址一样，Taro 协议定义了标识符的生成方式：<br>$$<br>ID=SHA256(genesisPoint||assetTag||assetMeta)<br>$$<br>它将铸造资产所使用的交易输出信息、资产标签（例如资产名称的哈希值）以及资产的元数据（图片、链接或文档）进行哈希，从而得到一个标识符。</p><p>Taro 资产的转移脚本可以有类似比特币交易的输入输出，而创建资产的交易不需要包含任何的 Taro 资产的输入，由此可见，Taro 资产沿用了比特币的 UTxO 模型，资产的发行就是发布一笔 Taro 资产的交易，它没有输入，只有输出。</p><p>Taro 的输入和输出是基于资产树来实现的，正如前文所述，资产树的第一级代表了该笔 UTxO* （后面会继续沿用这种写法，<em>表明这样的结构是在 Taro 资产中而非 Bitcoin中）中存放的 Taro 资产有哪些，而 Taro 资产 ID 所对应的 MS-SMT 中所存放的是该笔 UTxO\</em> 输出的 Trao 资产的信息。</p><p>构建一笔 Taro 资产的发行交易如下图所示，以一笔 Bitcoin 的 UTxO 作为输入，输出一笔正常的 Bitcoin UTxO 以及附加的 Taro 资产 A 的 UTxO*。<strong>这样的 UTxO*在 Bitcoin 上表现为一个默克尔根的形式</strong>，而它在链下表现为资产树的形式，资产树中记录了 Taro 资产 A 的 assetId 以及资产 A 对应的 MS-SMT 中的记录。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910203812171.png" alt="image-20230910203812171"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jinse.com/blockchain/465498.html">什么是BIP？一分钟搞懂BIP标准</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://m.theblockbeats.info/news/37101">科普| 比特币地址有哪些？ - BlockBeats</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2021/09/29/bitcoin-taproot-a-technical-explanation/">比特币升级提案 Taproot 技术解读</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://juejin.cn/post/6844903573742944263">译-BIP16:P2SH交易脚本</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2022/04/20/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war/">P2SH 之争：第一次比特币战争不为人知的故事</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://bitcoinmagazine.com/technical/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war">THE BATTLE FOR P2SH: THE UNTOLD STORY OF THE FIRST BITCOIN WAR</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://academy.binance.com/zh/articles/what-do-schnorr-signatures-mean-for-bitcoin">Schnorr签名对比特币有何意义？</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/Segregated_Witness">Segregated Witness</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2021/09/07/what-is-a-bitcoin-merklized-abstract-syntax-tree-mast/">什么是比特币默克尔化抽象语法树？</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2020/08/27/segregated-witness-for-dummies/">详尽解释隔离见证</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.blocktempo.com/segwit-for-dummies-concept-and-case-study/">詳解》比特幣隔離見證 Segwit －工作原理與案例分析</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.odaily.news/post/5187233">解读比特币Ordinals协议与BRC20标准的原理创新与局限</a><a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu">概述 - 序数理论手册</a><a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://newbtcworld.medium.com/understanding-of-tapscript-transaction-structure-5979a7645205">Understanding of Tapscript Transaction Structure Tapscript</a><a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://xiaohuiliu.medium.com/merkelized-abstract-syntax-tree-6a49b2008435">Merklized Abstract Syntax Tree</a><a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.mit.edu/~jlrubin/public/pdfs/858report.pdf">Merklized Abstract Syntax Tree</a><a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[A Dive into Lightning Network (Part One)](<a href="https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2">A Dive into Lightning Network (Part One)</a>)<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8">Lightning network in depth, part 2: HTLC and payment routing</a><a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://river.com/learn/what-is-taro-in-bitcoin/">What Is Taro in Bitcoin?</a><a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.lightning.engineering/the-lightning-network/taproot-assets">Taproot Assets</a><a href="#fnref:21" rev="footnote"> ↩</a></span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.youtube.com/watch?v=-yiTtO_p3Cw">Taproot Assets: A New Protocol for Multi-Asset Bitcoin and Lightning</a><a href="#fnref:22" rev="footnote"> ↩</a></span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://bitcoinmagazine.com/guides/a-brief-introduction-to-rgb-protocols">A BRIEF INTRODUCTION TO RGB PROTOCOLS</a><a href="#fnref:23" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;BIP-标准&quot;&gt;&lt;a href=&quot;#BIP-标准&quot; class=&quot;</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="bitcoin" scheme="https://decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>密码累加器</title>
    <link href="https://decision01.com/post/ae4d471f.html"/>
    <id>https://decision01.com/post/ae4d471f.html</id>
    <published>2023-01-02T14:12:49.000Z</published>
    <updated>2025-06-03T06:18:22.987Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>密码累加器用于高效地证明元素是否存在于集合中，定义：</p><ul><li><p>集合 $X = \{x_1, …,x_n\}$</p></li><li><p>集合的累加值 $acc_X$</p></li><li><p>集合中的元素 $x_i$，对应一个证明 $w_i$</p></li></ul><p>通过证据 $w_i$，可以证明元素 $x_i$ 存在于集合 $X$</p><blockquote><p>累加器的三个性质：正确性、健壮性、不可区分性</p><p>正确性：对于所有诚实生成的密钥、所有诚实计算的累加值和证据，验证算法始终返回 1</p><p>健壮性：指无碰撞性，对于元素 $y\notin X$，很难找到其成员证明，而对于元素 $x_i \in X$，也很难找到其非成员证明</p><p>不可区分性：累加器和持有证明的用户都不会泄露有关累加集合 $X$ 的信息</p></blockquote><h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><ul><li>1993年首次被提出，其最初的构造为<strong>静态累加器</strong>，集合固定不变</li><li>2002年提出了<strong>动态累加器</strong>的概念，可以支持动态添加、删除元素</li><li>2007年，<strong>通用累加器</strong>被提出，可以姐姐成员证明和非成员证明</li></ul><blockquote><p>非通用累加器智能支持元素的成员证明，即证明 $x_i \in X$，无法提供 $y\notin X$ 的证明 $w_y$</p></blockquote><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>一个密码累加器中有三个主体：</p><ul><li>累加器管理员：生成密钥对，创建并发布累加器</li><li>用户：接收累加器管理员提供的证证明，这个证明是它们在累加器系统中的凭证，可以提供给验证方进行验证</li><li>验证方：通过证明 $w$ 和 $acc_X$，验证某个元素在累加器中</li></ul><h2 id="静态累加器"><a href="#静态累加器" class="headerlink" title="静态累加器"></a>静态累加器</h2><p>静态累加器可以描述为四元组 $\Pi=(Gen, Eval, WitCreate, Ver)$，静态累加器不能动态地添加元素</p><p>$Gen(1^\lambda, t) \Rightarrow (sk_{acc}, pk_{acc})$：管理员输入安全参数$\lambda$，累加上限$t$，输出密钥对$(sk_{acc},pk_acc)$，如果没有陷门，陷门信息$sk_{acc} = \varphi$</p><p>$Eval((sk_{acc}, pk_{acc}),X) \Rightarrow acc_X$：管理员计算累加值和辅助信息，输入集合、密钥对，输出一个累加值。并且，公布给用户和验证方，输出辅助信息$aux$发送给用户，用户通过辅助信息更新本地证明</p><p>$WitCreate((sk_{acc},pk_{acc}), x_i, acc_X, aux) \Rightarrow w_i$：创建用户 $x_i$ 的证明，输入密钥对、累加值、元素 $x_i$ 和辅助信息 $aux$，生成证据 $w_i$</p><p>$Ver(pk_{acc}, x_i, w_i,acc_X) \Rightarrow \{0/1\}$：验证方验证元素 $x_i$ 是否在累加器中，如果 $w_i$ 是 $x_i$ 的证据，返回1，否则返回0</p><h2 id="动态累加器"><a href="#动态累加器" class="headerlink" title="动态累加器"></a>动态累加器</h2><p>为了可以支持动态地更新集合 $X$，并且可以有效地更新集合中的证明对静态累加器进行扩展，可以得到动态累加器</p><p>动态累加器<strong>在静态累加器的基础上</strong>添加了一个三元组 $\Pi=(Add, Del, MemWitUp)$</p><p>$Add((sk_{acc},pk_{acc}),acc_X,aux,x) \Rightarrow (acc_{X’},aux’)$：累加器管理员添加元素 $x\notin X$ 到累加器中，并且更新累加值 $acc_x$，这个过程和 $WitCreate$ 较类似，它输出的是 $x$ 加入后的累加值$acc_{X’}$，并且更新辅助信息 $aux$</p><p>$Del((sk_{acc},pk_{acc}),acc_x,x,aux)\Rightarrow(acc_{X’},aux’x)$：与上一个元素类似，输入需要删除的元素 $x$ 和辅助信息，然后输出新的累加值，更新辅助信息</p><p>$MemWitUp((sk_{acc},pk_{acc}), x, w_i, aux) \Rightarrow w_{i’}$：在添加或删除元素后，用户更新元素 $x_i$ 的证明 $w_i$，它输出$x_i$更新后的证明$w_i’$ </p><h2 id="通用累加器"><a href="#通用累加器" class="headerlink" title="通用累加器"></a>通用累加器</h2><p>通用累加器在前面 $WitCreate$ 组件中，添加一个布尔参数 $type$，创建成员证明时 $type=0$，创建非成员证明时 $type=1$。通用累加器可以根据是否可以添加元素进行分类，如果不可动态添加元素称为<strong>通用静态累加器</strong>，如果可以动态添加元素则称为<strong>通用动态累加器</strong></p><p>如果是通用动态累加器，则需要在前面两个累加器的基础上添加 $NonMemWitUp$ 组件，在累加器集合更新时，对非成员证明更新</p><p>$NonMemWitUp((sk_{acc},pk_{acc}),x,w,aux) \Rightarrow u’$：在添加或删除元素 $x$ 时,用户更新非成员元素 $y \notin X$ 的证据$u$ 为 $u’$</p><h1 id="基于-RSA-的累加器"><a href="#基于-RSA-的累加器" class="headerlink" title="基于 RSA 的累加器"></a>基于 RSA 的累加器</h1><h2 id="静态累加器-1"><a href="#静态累加器-1" class="headerlink" title="静态累加器"></a>静态累加器</h2><p>最开始在1993年被提出的静态累加器就是基于 RSA 实现的，其具体构造方案如下</p><p>$Gen(1^\lambda, t) \Rightarrow ((p, q), N)$：输入安全参数，生成累加器的初始值 $g\in Z_n$，输出密钥对，私钥是 RSA 加密中的两个大素数，$N = pq$</p><p>$Eval(pk_{acc}, X) \Rightarrow acc_X$：管理员计算累加值，$acc_X=g^{x_1…x_n}\ mod\ N$，其中$X = \{x_1,…,x_n\}$</p><p>$WitCreate(pk_{acc},x,acc_X) \Rightarrow w_i$：生成用户的证明 $w_i=g^{x_1…x_{i-1}x_{i+1}…x_n}\ mod\ N$</p><p>$VerMem(pk_{acc},x_i,w,acc_X) \Rightarrow \{0/1\}$：验证方判断等式$acc_X=w_i^{x_i} \ mod\ N$ 是否成立来验证元素是否在累加器中</p><h2 id="动态累加器-1"><a href="#动态累加器-1" class="headerlink" title="动态累加器"></a>动态累加器</h2><p>动态累加器利用了 RSA 的陷门来更新累加器，利用陷门信息 $sk_{acc}$ 进行求逆运算，删除信息时需要利用陷门信息更新累加值，更新成员证明时不需要陷门信息</p><p>$Gen(1^\lambda, t) \Rightarrow ((p,q),N)$：和静态累加器一样，生成密钥对</p><p>$Add(acc_X,x,X,pk_{acc}) \Rightarrow acc_X$：添加元素 $x$ 后，更新累加值<br>$$<br>acc_{X’}=acc_{X \cup\{x\}}=acc_X^x \ mod\  N<br>$$<br>$Del(acc_X,x,X,(sk_{acc},pk_{acc}))$：删除元素 $x$ 后更新累加值，删除元素后更新累加值为<br>$$<br>acc_{X’}=acc_{X \textbackslash \{x\}}=acc_{X}^{x^{-1} \ mod\  \varphi(N)} \ mod \ N<br>$$<br>其中，$\varphi$ 是欧拉函数</p><p>$VerMem(acc_X,x,w_i,pk_{acc})$：验证方通过等式 $acc_X =w_i^{x_i}\ mod\ N$ 来判断元素是否在集合中</p><p>$MemWitUp(x,w_i,x_i,pk_{acc},acc_X,acc_{X’})$：用户更新元素 $x_i$ 的证明。</p><p>添加元素 $x\notin X$ 到累加器时，用户更新证明 $w_i’ = w_i^x \ mod\ N$。</p><p>删除元素 $x \neq x_i \in X$ 时，通过扩展欧几里得算法求出 $a,b\in Z$ 使得 $ax_i + bx = 1$，然后从 $x_i$ 的旧证明计算新证明<br>$$<br>w_i’ = w_i^bacc_{X’}^a<br>$$</p><h1 id="Merkle-树累加器"><a href="#Merkle-树累加器" class="headerlink" title="Merkle 树累加器"></a>Merkle 树累加器</h1><p>Merkle 树密码累加器使用了 Merkle 树的性质来提供某个元素存在于集合中的证明</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/merkle.png" alt="Merkle Tree"></p><p>对于上图中的元素 L2，如果要提供它存在于当前集合中的证明，从 L2 开始往上依次得到 <code>Hash(0-0)</code> 和 <code>Hash(1)</code>，这样得到的序列就是一个 Merkle Proof</p><p>在进行验证时，先对 L2 进行哈希得到 <code>Hash(0-1)</code> 然后连接 <code>Hash(0-0)</code> 进行哈希得到 <code>Hash(0)</code>，最后连接 <code>Hash(1)</code> 进行哈希得到 Merkle 根</p><p>这样的验证方式在实际的场景下可以用于进行轻量节点的实现、跨链协议中的锚定技术（已支付证明）以及智能合约中调用权限的证明</p><p>基于 Merkle 哈希树的累加器也可以提供非成员元素证明，具体见<a href="https://d.wanfangdata.com.cn/periodical/xadzkjdx202201008">密码累加器研究进展及应用</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://d.wanfangdata.com.cn/periodical/xadzkjdx202201008">密码累加器研究进展及应用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;密码累加器用于高效地证明元素是否存在于集合中，定义：&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="Research" scheme="https://decision01.com/categories/Research/"/>
    
    
    <category term="cryptography" scheme="https://decision01.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Kademlia协议及广播方法</title>
    <link href="https://decision01.com/post/db10e69d.html"/>
    <id>https://decision01.com/post/db10e69d.html</id>
    <published>2022-09-27T06:57:33.000Z</published>
    <updated>2024-09-10T22:48:20.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Kademlia-协议"><a href="#Kademlia-协议" class="headerlink" title="Kademlia 协议"></a>Kademlia 协议</h1><p>Kademlia<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kademlia: A Peer-to-peer Information System Based on XOR Metric](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)">[1]</span></a></sup>协议是一种分布式散列表(Distributed Hash Table, DHT) 技术。它可以被用来构建 P2P 网络，相比其他的散列表技术，提高了路由的查询速度。</p><p>在 Kademlia 协议中，利用异或来定义了节点之间的<em>距离</em>。这个<em>距离</em>是一个逻辑距离，而不是两个节点实际上的物理距离。在 Kademlia 协议中，每个节点都有一个随机生成的长度为160 bit的ID，而两个节点之间的<em>距离</em>就是把它们的 ID 异或后得到的值。</p><blockquote><p>结合异或本身的性质，可以得到<em>距离</em>的一些特点<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Kademlia协议](https://segmentfault.com/a/1190000023417884)">[2]</span></a></sup>：</p><ul><li>$A \bigotimes B = B \bigotimes A$：A 到 B 和 B 到 A 的距离是一样的</li><li>$A \bigotimes A = 0$：节点自身和自身的距离是0</li><li>$A \bigotimes B &gt; 0$：任意两个不同节点之间的距离大于0</li><li>$(A \bigotimes B) + (B \bigotimes C) \ge (A \bigotimes C)$：A 经过 B 到达 C 的距离大于 A 直接到达 C 的距离</li></ul></blockquote><h2 id="K-bucket"><a href="#K-bucket" class="headerlink" title="K-bucket"></a>K-bucket</h2><p>在 Kademlia 协议中，定义了 K 桶(K-bucket)，这里的 K 表示一个桶的容量。K 桶存储了其他邻居节点的信息，K 桶是每个节点在自己的视图下进行划分得到的。以下图为例，节点11（对应二进制为1011），它存储了包含自己id共16个节点的路由信息，然后将节点 ID 以前缀树的方式进行维护，然后通过以其他节点和自己的最长公共前缀来划分 K 桶，图中的每一个框都是一个 K 桶。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202209271541434.png" alt="kademlia_routing_table_in_tree"></p><p>第 $n$ 个 K 桶理论上维护的节点到当前节点的距离理论上为 $[2^{n -1 }, 2^n)$，但是每个 K 桶是存在容量限制的，距离本地节点较远的节点只维护 K 个。在查询某个节点的时候，可以求出另外一个节点和本地节点的 ID 的最长公共前缀长度来确认节点应该所在的 K 桶，如果节点不在路由表中，则可以去询问 K 桶中的节点。</p><p>在实际的代码实现中，go-lib-p2p-kbucket 使用了最长公共前缀长度来作为 K 桶的序号，查询邻居节点时利用最长公共前缀来定位节点所应该在的 K 桶，然后查找最近的 K 个节点来得到结果。而 python-kademlia 则没有利用这种方式，它将维护的 K 桶并非按照距离/最长公共前缀长度来维护，而是维护每个 K 桶的节点序号范围，在查找邻居的时候交替从目标 K 桶的左右 K 桶获取元素来得到 K 个最近的节点。</p><h2 id="路由表更新机制"><a href="#路由表更新机制" class="headerlink" title="路由表更新机制"></a>路由表更新机制</h2><p>(待续，抽空写)</p><h1 id="广播方法"><a href="#广播方法" class="headerlink" title="广播方法"></a>广播方法</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">Kademlia: A Peer-to-peer Information System Based on XOR Metric</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://segmentfault.com/a/1190000023417884">Kademlia协议</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.wanghaoyi.com/blockchain-p2p-kademlia.html">P2P网络之Kademlia协议</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Kademlia-协议&quot;&gt;&lt;a href=&quot;#Kademlia-协</summary>
      
    
    
    
    <category term="Research" scheme="https://decision01.com/categories/Research/"/>
    
    
    <category term="distributed network" scheme="https://decision01.com/tags/distributed-network/"/>
    
  </entry>
  
  <entry>
    <title>Sundaeswap feature</title>
    <link href="https://decision01.com/post/6ba030b7.html"/>
    <id>https://decision01.com/post/6ba030b7.html</id>
    <published>2022-08-14T03:45:01.000Z</published>
    <updated>2024-12-24T15:03:05.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>这篇是前几个月的Sundaeswap的可搬砖套利的小特性(bug)的记录，目前特性已经被修复，所以也没法用了</strong></p><p>Sundaeswap是Cardano链上上线的第二个去中心化交易所（Decentralized exchange， Dex），由于Cardano使用的UTXO模型的原因，所以它在实现的本质上还是一种挂单交易的方式，不过流动性相比于直接挂单的交易所更好</p><p>在上线前三个月存在一个特性，可以在Sundaeswap的首页查询到一个币种的多个交易池，但是在实际的swap界面上只能默认流动性最高的池子。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208141215809.png" alt="image-20220814121457096"></p><blockquote><p>交易池：放入了不同币种对的一种抽象模型，可以放入一种币种在交易池中换取另外一种币种，现在的去中心化交易所使用的都是一类公式。</p><p>做一个简单的举例，假设人民币比美元是6:1，那么就可以创建一个交易池放入600人民币和100美元，这样其他人就可以在里面交易，而交易池可以得到手续费。如果不按照比例来进行设置，那么其他人就存在一定的套利空间，导致交易池出现损失。</p></blockquote><p>在抓包后可以发现，Sundaeswap进行一次交易要经过下面的一系列操作</p><ul><li>本地根据流动性、滑点、手续费计算得到该笔交易中能够获取到的另外一个币种的<strong>最低限制数量</strong></li><li>将<strong>交易信息</strong>发送到sundaeswap的服务器上，生成一笔未签名的交易的cbor，这里的交易信息包含了地址、输入币种、输出币种以及具体数量信息</li><li>返回本地让本地的钱包进行签名，发送交易到链上</li><li>交易完成，钱包收到目标币种</li><li>如果交易池不能满足最低限制数量，则会在链上一直等待交易可以完成</li></ul><p>在交易信息中还包含了一个重要的字段：目标交易池标识，这里的标识就是一个整形数据，标识从哪个交易池进行交易</p><p><em>如果目标交易池中没有现在需要兑换的币种，那么这笔交易同样会一直卡在链上，直到撤销这笔交易返回代币</em></p><p>在swap页面不能选择交易池，这就会导致默认的交易池价格会一直变动（因为频繁会有人兑换），而其他的交易池价格不会或者很少发生变动（其他人没有发现可以修改json数据来更改交易池）</p><p>于是这就会导致存在多个交易池的币种存在套利空间，在默认交易池出现频繁的价格波动的时候就可以来回薅</p><p>顺便说一下自动做市(Auto Market Maker, AMM)在这种场景下的可套利计算方法</p><p>假设有两个币种A和B，它们有两个交易池在DEX上，在一个交易池中有a个A币种，b个B币种，在另外一个交易池中有c个A币种，d个B币种</p><p>并且a/b和c/d的差距比较大，这种情况下就有可套利空间</p><p>现在我放入x个A币种到第一个交易池中得到y个B币种，再将它放入到第二个交易池中换出A币种</p><p>根据AMM的输出计算公式(白皮书参考：<a href="https://sundaeswap.finance/papers/SundaeSwap-2021-06-01-Fundamentals.pdf">SundaeSwap Fundamentals</a>)，可以得到<br>$$<br>y = b - \frac{ab}{x + a}<br>$$<br>同样，在另外一个交易池中进行兑换，输出z个A币种<br>$$<br>z = c - \frac{cd}{y + d}<br>$$<br>套利空间也就是$z - y$，这里最后化简后得到一个关于x的方程，在之前计算的时候不太好找极大值。然后发现在1w以内对计算机来说计算量也不是很大，就直接用python写程序直接求极大值了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;strong&gt;这篇是前几个月的Sundaeswap的可搬砖套利的小特性(b</summary>
      
    
    
    
    <category term="Wiki" scheme="https://decision01.com/categories/Wiki/"/>
    
    
    <category term="blockchain" scheme="https://decision01.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>毕业行·甘肃</title>
    <link href="https://decision01.com/post/3d984fbf.html"/>
    <id>https://decision01.com/post/3d984fbf.html</id>
    <published>2022-08-10T15:36:23.000Z</published>
    <updated>2025-06-03T06:18:22.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>8月2日（<em>Day.10</em>）中午在机场还车后赶飞机，从西宁飞到敦煌，到敦煌市区的时候是下午4点过。在飞机上可以看到敦煌这边周围都是荒漠隔壁，只有沿着市区发展出来的一片片“绿洲”，这也是甘肃很多市的一种特色。</p><p>在酒店休息整顿后时间还比较充足，于是我们先去鸣沙山。鸣沙山以沙动而响为名，面积有200平方公里。进入景区的门票是55/人，大哥一直好奇为什么售票大厅写的是110，甚至想排队专门去问问。在进了进去后，看到了门口有一个讲解我就知道大哥想要干什么了。在请了讲解后，讲解问了我们进来的票价，才说现在还是按照淡季来收费的，所以是半价票。</p><p>在讲解了前面的一个城楼后，我们又买观光车进月牙泉。<em>我一开始以为沿途有景点，还想先走进去再买票回来。</em>坐在观光车上有一段能够看到成群的骆驼队，在那个点位拍照能够得到很好的效果，可惜的是等我掏出相机的时候已经晚了，就没有拍到。讲解带着转的这一圈感觉没有什么好写的，直接快进到爬沙丘，在爬沙丘之前拍了一下芦苇丛对面的沙丘。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111848134.jpg" alt="20220802-DSC00903"></p><p>上沙丘的有路有两条景区设置的路，放了一些木板在上面以降低压强方便爬上去。我们不想在梯子上一个挨着一个的爬上去就选择了另外一边没有梯子的地方上去。在月牙泉背后拍到的照片里面可以看到人数比较密集的两条上沙丘的路。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111857590.jpg" alt="20220802-DSC00898"></p><p><em>说来在游戏、电视上看到过沙漠，但是第一次面对高耸的沙丘还是让人觉得很震撼的。它如山一样高，是由沙子所堆起来的沙山。</em>鸣沙山应该不算是真正的沙漠，它的底部应该是有坚固的岩石的，所以沙丘也不会是完全由沙子堆砌而成。爬沙丘的时候能够真实地感觉到在沙丘上行走的困难，由于沙子的流动性导致我们每走一步都会后退一点，到了最后我们就真正地是在爬山了，真正意义上的手脚并用地爬上去。上去后拍了两张照片用来拼接，可是下面游客比较多，所以就裁掉了，就凑合着看看。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111855638.jpg" alt="鸣沙山和月牙泉"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111900355.jpg" alt="20220802-DSC00932"></p>          </div><p>在上去之后可以拍背后的一座山丘，感觉调一调可以当个手机背景之类的，总体而言是一种常见的构图，还有竖拍的就懒得现在调整了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208111903169.jpg" alt="鸣沙山沙丘"></p><p>在被大哥拉着体验了ATV后我就没打算回之前那个沙丘了，走下去没多久听到周围的人在说开灯什么的，查了一下月牙泉在晚上的时候会开灯光，然后我就找了个地方坐着。在QQ上让大哥等着，结果没一会他说他已经下去了，我还想着如果他还没下去那我走上去。等了一会应该是9点过的时候，天快黑了就开灯了。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208112314019.jpg" alt="月牙泉"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208112314262.jpg" alt="月牙泉"></p>          </div><p>时间差不多了我就下去了，然后找到大哥坐了观光车回到景区入口。在入口的地方还有一个民俗博物馆，进去后发现是那种以前的人供奉的地方，其实很有贵州这边有些人家里的那种感觉。不过比较阴间的是晚上里面没有开灯，有一个房间里面全是一些供奉的画像，我在外面看了一下就有点不寒而栗。</p><p>8月3日（<em>Day.11</em>）租车往雅丹魔鬼城的方向跑，途中经过玉门关，还计划回来的时候往阳关去一趟。这两个地方都是曾经背过的，但是也只能记住那一句了。春风不度玉门关和西出阳关无故人，而每一句前面的也就记不住了。自驾过去走省道S303往新疆的方向走，雅丹地质公园那边已经很靠近新疆了。从敦煌出发行程160km，这边的省道上面没有什么车，大哥都说这边狗都不来。在原来青甘大环线的行程中我们也只是说可能往玉门关的方向走一下，大哥在来敦煌前几天又说可以去一下魔鬼城，正好空出来一天还租了车那就过去了。</p><p>在S303上没什么车，而且路也比较好，于是大哥心心念念想着换我坐牢的机会就来了。其实在青海那边我也挺想开一段路，但是那边确实路况不太好，车道上面的情况也比较复杂，就算换我开也有一定的风险。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211559842.png" alt="省道S303"></p><p>在省道上面开了快一个小时后到了玉门关，在路边已经能够看到平地上高起来的玉门关遗址，我就说玉门关看完了，我们可以直接走了（不是）。而这边来的人比较少，停车场里面也只有寥寥几辆车。停好车做好防晒措施后买门票进景区，在售票处还遇到了上一天在鸣沙山遇到的一对夫妻。本来我一开始是没注意到的，但是对方先打招呼了我才想起来。在上一天爬上鸣沙山的时候，就被他们问休息了多久，然后他们还感叹了一下大哥的体力好，居然还负重爬沙丘。</p><p>买了门票后我们跟在他们后面一点往景区走，在进大厅之后大哥看了一下讲解的价格，觉得有点贵就不太想请了。然后那对夫妻就说要不要我们四个人请一个讲解，人多了之后就感觉划算了一些，那就一起请一个讲解了。付完费之后我们要在大厅里面等一下导演，这个时间大哥就去厕所了。我在这段时间就和他们聊了一下，了解到他们是从青海一路开车过来的，也就是我们原计划的青甘环线。不一样的就是我们缩短了自驾的行程，总体来说我们走的地方是差不多的。他们后面也要往雅丹的方向走，就说后面也结伴同行，但是这也是后话了。</p><p>玉门关景区里面还有其他两个景点，可能也是因为只有一个城楼遗址太单调才加到玉门关景区的。景区观光车的路线是汉长城-大方盘城-玉门关遗址。汉长城是用就地取材的芦苇和沙石修建的，据说原来能有7m高，而现在仅存的只有1~2m高的遗迹了。在这边听讲解的时候还有观光车上另外一些人凑过来听，可能是因为讲解在车上用广播的时候被误会成观光车的导游了。然后那对夫妻里面的大哥应该也是有点看不下去，才问导游这帮人也是和我们一起的吗，他们才自己走开了。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211635355.jpg" alt="汉长城和远处的烽火台"></p><p>在这边停留了几分钟后上车去离得比较远的大方盘城，大方盘城是一个粮仓遗址，相比于玉门关来说留下来的遗迹会更多一些（感觉这样说不太恰当）。<del>在这边看到这些残留的土墙老是让我想到在刺客信条起源里面爬墙暗杀</del></p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211651755.jpg" alt="DSC01245"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211651702.jpg" alt="DSC01248"></p>          </div><p>我们围着这边转了一圈就回去了，在这种人文景点里面确实也只能看一看，听一听讲解来了解一下。而且在来之前一直在忙论文的事情也就没怎么查过相关的资料（就算查资料也不会想到会到这边来）。回到了起点大厅附近，然后又去看玉门关遗址。在来之前根据我看的网图我一直觉得它就是个只有一面的城楼遗址，而实际上玉门关遗址是一个四方的，有两个口可以出入。据讲解说的是，有一边的口还是以前放牧的人把它当作一个羊圈用的时候凿开的。。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211703213.jpg" alt="DSC01278"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211704734.jpg" alt="DSC01290"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211706750.jpg" alt="DSC01299"></p>          </div><p>到这里玉门关的景点算是逛完了，大厅里面的一些展示也就是听了听讲解，也没有太多能记住的（<del>出去整个脑子都是放空的能记住啥</del>）</p><p>出门之后因为太渴太饿在门口的小店里面点了一份冰粉和西瓜，之前那对夫妻在窗外看到我还示意我一会过去。而我出门回车上的时候也没有遇到他们，我们也因为比较赶时间在吃完西瓜之后就直接上路去雅丹魔鬼城了。第一次看到雅丹魔鬼城应该是在小学的时候，父亲买了一本地质相关的书，那个时候的我就拿出来翻，而那个时候也没想到能有一天自己亲自过来看一看。</p><p>到了雅丹的时候算是那边的正午，一开车门就能感受到一股热浪。由于上午没有吃东西，在这边找到了餐厅就吃了48元一份的盒饭，离市区这么远也算是能对得起这个价格了。然后又是固定的买票、坐观光车环境。到魔鬼城来就是看雅丹地貌，连导游都说过来看就是“八分靠想象”，游览的景点都是在自然形成之后，人们靠想象脑补，并且换一个角度就是另外一个样貌了，这边也先随便放点照片了。（在轻薄本上调照片是真的折磨）</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211737950.jpg" alt="DSC01362"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211737329.jpg" alt="DSC01410"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211737130.jpg" alt="DSC01437"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211738970.jpg" alt="DSC01464"><br><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202208211738962.jpg" alt="DSC01479"></p>          </div><p>在这边看完之后我们就往市区的方向走，本来还打算去一趟阳关但是时间不太够了，因为预订的沙漠露营的活动有点赶。在出省道的时候还有一个设卡检查，我们还猜测是不是新疆过来的有安全检查，排队排了快半个小时才知道是在查健康码。在路上还能一直看到道路左边一直有一个东西在发光，在后面我们才确认那是附近的光伏电站聚集起来发电的光。</p><p>出卡后没多久经过了敦煌古城，是一个中日合资建成的影视基地。由于赶时间的原因我们也没有进去看，只在外面看了有宫殿和一些其他的建筑，好像还有一个狮身人面像（？）然后到了沙漠营地，在一开始我想象的沙漠营地是在最起码两个沙丘后到的地方，由那边的人用越野车送过去。到了之后才发现其实也就是在市区边缘的沙漠附近弄的营地，想来倒也合理，如果远了的话电和水什么的供应不上，而且维护成本也会更高一些。下面是在沙丘上拍的日落，第一张为了能看到下面的营地稍微调低了对比度(<del>他们说的沙漠腹地算不算虚假宣传</del>)</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202209172242802.jpg" alt></p><p>在青海和甘肃这段时间不是赶着看日出就是等着看日落，那个时候也开始觉得好像两者并没有什么太大的差别。在日落后回到营地下面，等着营地里面搞的篝火晚会。无非也就是和其他到这边来玩的人一起坐着吃火锅，然后同时看这边的人办办活动。总的来说还算是一种很难得的体验，在烟花升起的时候还让我恍惚了一下，多少感觉有点小时候过节的那种氛围了。而随着年龄的增长和回家的时间越来越短，能让我有这种感觉的场景也越来越少了。（后面还有篝火和蹦迪，感觉没啥写的就略过了）</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112104125.jpg" alt="DSC01634"></p><p>这边晚会差不多结束后我和 f1ag 大哥就回帐篷了，因为接人去沙丘的队列还要等会。而后面到了之后才发现所谓“沙漠腹地”就是在看日落的沙丘上。不过在远离了帐篷区后，确实能够看到很多的星星，也不是不能拍。记忆里看到这么多星星还是在老家停电的时候，大概是初中的时候，偶尔遇到停电的时候能看到漫天星河，不过那个时候没有怎么注意观察过银河。爬上沙丘，在眼睛短暂地适应后能够明显地看到银河。而这个时候我们带了一路的三脚架也终于可以用上了，架好脚架先试着拍两张，然而焦没对上直接糊了。而且比较不好的一点是那边经常会有 ATV 经过，导致有灯光的污染，我旁边的大叔就一直在吐槽这怎么拍= =</p><p>然后大叔带了相机没带脚架，找我借脚架折腾了差不多十分钟，我感觉时间有点长了才要回来，然后大叔又去找了别人借脚架。我自己拍了很多张后感觉差不多了，拍多的好像也就哪样。而且因为延时比较长又没有赤道仪（太贵了），导致拍出来的银河放大能够看到很明显的星轨。后面回来了才想到应该可以多拍点低延时的再堆栈，确实也是经验不够足也没想到，下次不知道是啥时候了。老是感觉可以啥时候回老家可以试试，不过大多数时间都是回市里回不去村里。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112124053.jpg" alt="DSC01772"></p><p>而在沙丘上回头能够一样看到北斗七星，应该来说是头一次看到北斗七星，确实来说活了20多年都没有怎么好好地抬头看过星星。一方面也是条件不允许，在城市里面抬头只能看到寥寥几颗星星。在此之前也没有注意到过原来北斗七星能有这么大，它大概占据了人的视角的一半，怪不得会有人看到后会有巨物恐惧症。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112131000.jpg" alt="DSC01798"></p><p>在沙丘上待到了凌晨一点才坐那边的 ATV 下去，我实在顶不住困意下去就直接睡觉了。随身携带的耳塞也正好派上了用场，挡住了其他帐篷传来的吵闹声。后面醒过来是凌晨5点，醒来发现 f1ag 大哥还醒着，合着是一整夜没睡。后面才知道他在帐篷外面折腾了几个小时在拍星轨，还说中间还想过自己走到山丘上去，又怕出问题。然后我们又开始守着看日出了，其实最好的还是到山丘上去，但是那个时候太冷也不太想动，我们就守在帐篷外面看坐了一个小时。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112141435.jpg" alt="DSC01827"></p><p>时间差不多了之后就开车回酒店，因为头一天没订上莫高窟的票，导致我们今天没法去看，只能在敦煌又歇一天。由于大哥通宵了一整晚，然后只能让我开车。战战兢兢开了十多公里后才回到市区，然后在市区里面还因为没及时变道在十字路口转了好几圈（搁这逛街呢）。然后我们找了个加油站加油，回到酒店下面还了车，拖着行李上楼倒头就睡。休息到晚上在酒店后面敦煌夜市找吃的，然后现在也忘记吃了除了驴肉黄面还有什么了（下次一定吃的都记录一下）。</p><p>第二天快到中午了就直接打车去莫高窟，本来在我原计划里面环线甘肃没法走就直接不来的，但是大哥死活都要来莫高窟那就加了后面这段行程。在去洞窟之前先在游客中心看了又见敦煌的纪录片，里面就具体讲了附近几个景点，还有莫高窟的文化背景。而且还有球幕的展厅，算是比较新奇，但是看的时候感觉也就这样。在看完之后才被带着去莫高窟。莫高窟距离游客中心应该有30km，下车后能够看到没有开放的北窟，据导游说北窟的一些洞窟里面还留有以前一些僧人的骸骨。然后还有一条很宽的河道，不太清楚甘肃的雨季是什么时候，这个时候是8月份，在这边的河道里面也没有见过一点水，只能看到水流侵蚀过的痕迹。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112159249.jpg" alt="DSC01842"></p><p>莫高窟里面的洞窟是不给拍照的，所以在里面参观就没有图片了。最后参观大佛的时候在外面拍了点九层塔的照片，九层塔里面就是大佛，在里面看的时候也能感觉到特别壮观（什么叫做巨构建筑啊）。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112202154.jpg" alt="DSC01845"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112202913.jpg" alt="DSC01849"></p><p>在这边一共能参观的有8个洞窟，里面除了九层塔里面的大佛之外让我印象比较深刻的是323窟，里面有个元素是张骞出使西域图，因为以前在历史书上见过所以记得比较清楚。其他的洞窟在参观时基本上是左耳进右耳出，确实也只是了解一下了。参观完了出来后我们就在外面的陈列馆转转，里面是一些国家对莫高窟探索、保护的记录。陈列馆也就是以前的工作人员在这边生活的住处，只是看着的话感觉蛮惬意的，但是再看看周遭的环境就能知道在这边工作需要多大的信念了。</p><div class="justified-gallery"><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112207762.jpg" alt="DSC01852"></p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112211464.jpg" alt="DSC01864"></p>          </div><p>在这边出来后就到了卖纪念品的地方，逛了一圈感觉没什么特别想买的。还说和在青海一样，买了一套明信片，在这边还能自己盖印，然后就有了奇怪的收集欲。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202210112223041.jpg" alt="DSC01948"></p><p>（莫高窟这边还逛了另外有两个展览馆，先放着后面再写了= =，咕咕咕）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;8月2日（&lt;em&gt;Day.10&lt;/em&gt;）中午在机场还车后赶飞机，从西宁飞到</summary>
      
    
    
    
    <category term="杂记" scheme="https://decision01.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="游记" scheme="https://decision01.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
